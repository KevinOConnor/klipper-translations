# Протокол

Протоколът за съобщения на Klipper се използва за комуникация на ниско ниво между хост софтуера на Klipper и софтуера на микроконтролера Klipper. На високо ниво протоколът може да се разглежда като поредица от низове с команди и отговори, които се компресират, предават и след това се обработват от приемащата страна. Примерна поредица от команди в некомпресиран формат, удобен за четене от човека, може да изглежда така:

```
set_digital_out pin=PA3 value=1
set_digital_out pin=PA7 value=1
schedule_digital_out oid=8 clock=4000000 value=0
queue_step oid=7 interval=7458 count=10 add=331
queue_step oid=7 interval=11717 count=4 add=1281
```

Вижте документа [mcu commands](MCU_Commands.md) за информация относно наличните команди. Вижте документа [debugging](Debugging.md) за информация как да преведете G-Code файл в съответните му четими за човека команди за микроконтролера.

Тази страница съдържа описание на високо ниво на самия протокол за обмен на съобщения Klipper. Тя описва как съобщенията се декларират, кодират в двоичен формат ("компресираща" схема) и предават.

Целта на протокола е да осигури безпогрешен комуникационен канал между хоста и микроконтролера, който е с ниска латентност, ниска честотна лента и ниска сложност за микроконтролера.

## Интерфейс на микроконтролера

Протоколът за предаване Klipper може да се разглежда като механизъм [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) между микроконтролера и хоста. Софтуерът на микроконтролера декларира командите, които хостът може да извика, заедно със съобщенията за отговор, които може да генерира. Домакинът използва тази информация, за да командва микроконтролера да извършва действия и да интерпретира резултатите.

### Деклариране на команди

Софтуерът на микроконтролера декларира "команда", като използва макроса DECL_COMMAND() в кода на езика С. Например:

```
DECL_COMMAND(command_update_digital_out, "update_digital_out oid=%c value=%c");
```

Горното декларира команда с име "update_digital_out". Това позволява на хоста да "извика" тази команда, което ще доведе до изпълнение на функцията command_update_digital_out() C в микроконтролера. Горното също така показва, че командата приема два целочислени параметъра. Когато кодът command_update_digital_out() C бъде изпълнен, ще му бъде предаден масив, съдържащ тези две цели числа - първото, съответстващо на "oid", и второто, съответстващо на "value".

По принцип параметрите се описват със синтаксис в стил printf() (например "%u"). Форматирането пряко съответства на разбираемия за човека вид на командите (напр. "update_digital_out oid=7 value=1"). В горния пример "value=" е име на параметър, а "%c" показва, че параметърът е цяло число. Вътрешно името на параметъра се използва само като документация. В този пример "%c" се използва и като документация, за да покаже, че очакваното цяло число е с размер 1 байт (декларираният размер на цялото число не влияе на парсинга или кодирането).

Изграждането на микроконтролера ще събере всички команди, декларирани с DECL_COMMAND(), ще определи техните параметри и ще ги подготви за извикване.

### Деклариране на отговори

За да се изпрати информация от микроконтролера към хоста, се генерира "отговор". Те се декларират и предават с помощта на макроса sendf() C. Например:

```
sendf("status clock=%u status=%c", sched_read_time(), sched_is_shutdown());
```

В горния случай се предава съобщение за отговор "статус", което съдържа два целочислени параметъра ("clock" и "status"). Изграждането на микроконтролера автоматично открива всички sendf() повиквания и генерира енкодери за тях. Първият параметър на функцията sendf() описва отговора и е в същия формат като декларациите на командите.

Домакинът може да регистрира функция за обратно извикване за всеки отговор. Така на практика командите позволяват на хоста да извиква C функции в микроконтролера, а отговорите позволяват на софтуера на микроконтролера да извиква код в хоста.

Макросът sendf() трябва да се извиква само от обработчици на команди или задачи и не трябва да се извиква от прекъсвачи или таймери. Не е необходимо кодът да издава sendf() в отговор на получена команда, той не е ограничен в броя на случаите, в които може да бъде извикан sendf(), и може да извика sendf() по всяко време от обработчик на задачи.

#### Изходни отговори

За да се улесни отстраняването на грешки, има и функция output() C. Например:

```
output("The value of %u is %s with size %u.", x, buf, buf_len);
```

Функцията output() е подобна на printf() - тя е предназначена за генериране и форматиране на произволни съобщения за човешка употреба.

### Деклариране на изброявания

Изброяването позволява на кода на хоста да използва символни низове за параметри, които микроконтролерът обработва като цели числа. Те се декларират в кода на микроконтролера - например:

```
DECL_ENUMERATION("spi_bus", "spi", 0);

DECL_ENUMERATION_RANGE("pin", "PC0", 16, 8);
```

В първия пример макросът DECL_ENUMERATION() дефинира изброяване за всяко съобщение за команда/отговор с име на параметър "spi_bus" или име на параметър със суфикс "_spi_bus". За тези параметри низът "spi" е валидна стойност и тя ще бъде предадена с цяло число, равно на нула.

Възможно е също така да декларирате обхват на изброяване. Във втория пример параметърът "pin" (или всеки параметър със суфикс "_pin") ще приема като валидни стойности PC0, PC1, PC2, ..., PC7. Низовете ще се предават с цели числа 16, 17, 18, ..., 23.

### Деклариране на константи

Константите също могат да бъдат експортирани. Например, следното:

```
DECL_CONSTANT("SERIAL_BAUD", 250000);
```

ще експортира константа с име "SERIAL_BAUD" със стойност 250000 от микроконтролера към хоста. Възможно е също така да декларирате константа, която представлява низ - например:

```
DECL_CONSTANT_STR("MCU", "pru");
```

## Кодиране на съобщения на ниско ниво

За да се осъществи горепосоченият механизъм RPC, всяка команда и отговор се кодират в двоичен формат за предаване. Този раздел описва системата за предаване.

### Блокове за съобщения

Всички данни, изпращани от хоста към микроконтролера и обратно, се съдържат в "блокове за съобщения". Блокът от съобщения има два байта заглавие и три байта трейлър. Форматът на блока от съобщения е:

```
<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>
```

Байтът за дължина съдържа броя на байтовете в блока на съобщението, включително байтовете на заглавието и трейлъра (по този начин минималната дължина на съобщението е 5 байта). В момента максималната дължина на блока от съобщения е 64 байта. Байтът на последователността съдържа 4-битов номер на последователността в ниските битове, а високите битове винаги съдържат 0x10 (високите битове са запазени за бъдеща употреба). Байтовете със съдържание съдържат произволни данни и техният формат е описан в следващия раздел. Байтовете crc съдържат 16-битов CCITT [CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) на блока от съобщения, включително байтовете на заглавието, но без байтовете на ремаркето. Синхронизиращият байт е 0x7e.

Форматът на блока от съобщения е вдъхновен от рамките от съобщения [HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control). Подобно на HDLC, блокът от съобщения може по желание да съдържа допълнителен синхронизиращ символ в началото на блока. За разлика от HDLC, символът за синхронизация не е изключителен за рамкирането и може да присъства в съдържанието на блока от съобщения.

### Съдържание на блока от съобщения

Всеки блок от съобщения, изпратен от хоста към микроконтролера, съдържа поредица от нула или повече команди за съобщения. Всяка команда започва с [Variable Length Quantity](#variable-length-quantities) (VLQ) кодирано цяло число command-id, последвано от нула или повече VLQ параметри за дадената команда.

Например, следните четири команди могат да бъдат поставени в един блок от съобщения:

```
update_digital_out oid=6 value=1
update_digital_out oid=5 value=0
get_config
get_clock
```

и се кодират в следните осем VLQ цели числа:

```
<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>
```

За да се кодира и анализира съдържанието на съобщението, хостът и микроконтролерът трябва да се споразумеят за идентификаторите на командите и броя на параметрите на всяка команда. Така в горния пример и хостът, и микроконтролерът ще знаят, че "id_update_digital_out" винаги е последвана от два параметъра, а "id_get_config" и "id_get_clock" имат нула параметри. Домакинът и микроконтролерът споделят "речник на данните", който съпоставя описанията на командите (например "update_digital_out oid=%c value=%c") с техните целочислени идентификатори на командите. Когато обработва данните, анализаторът знае, че трябва да очаква определен брой VLQ кодирани параметри след даден идентификатор на команда.

Съдържанието на съобщенията за блоковете, изпращани от микроконтролера към хоста, следва същия формат. Идентификаторите в тези съобщения са "идентификатори на отговора", но те служат за същата цел и следват същите правила за кодиране. На практика блоковете от съобщения, изпращани от микроконтролера към хоста, никога не съдържат повече от един отговор в съдържанието на блока от съобщения.

#### Количества с променлива дължина

Вижте статията в [Уикипедия](https://en.wikipedia.org/wiki/Variable-length_quantity) за повече информация относно общия формат на VLQ кодираните цели числа. Klipper използва схема за кодиране, която поддържа както положителни, така и отрицателни цели числа. Цели числа, близки до нула, използват по-малко байтове за кодиране, а положителните цели числа обикновено се кодират с по-малко байтове, отколкото отрицателните цели числа. Следващата таблица показва броя на байтовете, необходими за кодиране на всяко цяло число:

| Цели числа | Кодиран размер |
| --- | --- |
| -32 .. 95 | 1 |
| -4096 .. 12287 | 2 |
| -524288 .. 1572863 | 3 |
| -67108864 .. 201326591 | 4 |
| -2147483648 .. 4294967295 | 5 |

#### Низове с променлива дължина

Като изключение от горните правила за кодиране, ако параметър на команда или отговор е динамичен низ, тогава параметърът не се кодира като просто цяло число VLQ. Вместо това той се кодира чрез предаване на дължината като VLQ кодирано цяло число, последвано от самото съдържание:

```
<VLQ encoded length><n-byte contents>
```

Описанията на командите, които се намират в речника на данните, позволяват на хоста и микроконтролера да разберат кои параметри на командите използват просто VLQ кодиране и кои параметри използват символно кодиране.

## Речник на данните

За да може да се установи смислена комуникация между микроконтролера и хоста, двете страни трябва да се споразумеят за "речник на данните". Този речник на данните съдържа целочислените идентификатори на командите и отговорите, както и техните описания.

Изграждането на микроконтролера използва съдържанието на макросите DECL_COMMAND() и sendf(), за да генерира речника с данни. Изграждането автоматично присвоява уникални идентификатори на всяка команда и отговор. Тази система позволява както на кода на хоста, така и на кода на микроконтролера безпроблемно да използват описателни имена, които могат да се четат от човека, като същевременно използват минимална честотна лента.

При първоначалното свързване с микроконтролера хостът прави запитване към речника с данни. След като хостът изтегли речника на данните от микроконтролера, той използва този речник на данните, за да кодира всички команди и да анализира всички отговори от микроконтролера. Следователно хостът трябва да работи с динамичен речник на данните. Въпреки това, за да се запази софтуерът на микроконтролера прост, микроконтролерът винаги използва своя статичен (компилиран) речник на данните.

В речника с данни се правят справки чрез изпращане на команди "идентификация" към микроконтролера. Микроконтролерът отговаря на всяка команда за идентификация със съобщение "identify_response". Тъй като тези две команди са необходими преди получаването на речника на данните, техните целочислени идентификатори и типове параметри са твърдо кодирани както в микроконтролера, така и в хоста. Идентификаторът на отговора "identify_response" е 0, а идентификаторът на командата "identify" е 1. Освен че имат твърдо кодирани идентификатори, командата "identify" и нейният отговор се декларират и предават по същия начин, както другите команди и отговори. Нито една друга команда или отговор не са твърдо кодирани.

Самият формат на предавания речник с данни е компресиран от zlib JSON низ. Процесът на изграждане на микроконтролера генерира този низ, компресира го и го съхранява в текстовата секция на флаш паметта на микроконтролера. Речникът на данните може да бъде много по-голям от максималния размер на блока за съобщения - хостът го изтегля, като изпраща множество команди за идентификация, изискващи прогресивни части от речника на данните. След като получи всички части, хостът сглобява частите, разкомпресира данните и анализира съдържанието.

В допълнение към информацията за комуникационния протокол, речникът на данните съдържа и версията на софтуера, изброявания (както са дефинирани от DECL_ENUMERATION) и константи (както са дефинирани от DECL_CONSTANT).

## Поток на съобщението

Командите за съобщения, изпращани от хоста към микроконтролера, са предназначени да бъдат без грешки. Микроконтролерът проверява CRC и поредните номера във всеки блок от съобщения, за да гарантира, че командите са точни и подредени. Микроконтролерът винаги обработва блоковете със съобщения в правилен ред - ако получи блок с нарушен ред, той ще го изхвърли, както и всички други блокове с нарушен ред, докато не получи блокове с правилна последователност.

Кодът на ниско ниво на хоста имплементира система за автоматично препредаване на изгубени и повредени блокове от съобщения, изпратени към микроконтролера. За да се улесни това, микроконтролерът предава "блок със съобщение за потвърждение" след всеки успешно получен блок със съобщение. Домакинът планира времетраене след изпращането на всеки блок и ще препредава, ако времетраенето изтече, без да получи съответното "ack". Освен това, ако микроконтролерът открие повреден или неподреден блок, той може да предаде "nak message block", за да улесни бързото повторно предаване.

"Ack" е блок от съобщения с празно съдържание (т.е. блок от 5 байта) и номер на последователността, по-голям от последния получен номер на последователността на хоста. "Nak" е блок от съобщения с празно съдържание и номер на последователността, по-малък от последния получен номер на последователността на хоста.

Протоколът улеснява системата за предаване на "прозорци", така че хостът може да разполага с много неизпратени блокове от съобщения в движение в даден момент. (Това е в допълнение към многото команди, които могат да се съдържат в даден блок от съобщения.) Това позволява максимално използване на честотната лента дори в случай на забавяне на предаването. Механизмите за прекъсване на времето, препредаване, прозорци и потвърждение са вдъхновени от подобни механизми в [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol).

В другата посока блоковете със съобщения, изпращани от микроконтролера към хоста, са проектирани така, че да не допускат грешки, но нямат гарантирано предаване. (Отговорите не трябва да са повредени, но могат да липсват.) Това е направено, за да се запази реализацията в микроконтролера проста. Няма автоматична система за препредаване на отговорите - очаква се кодът на високо ниво да може да се справя със случайни липсващи отговори (обикновено чрез повторно поискване на съдържанието или създаване на повтарящ се график за предаване на отговорите). Полето за пореден номер в блоковете от съобщения, изпращани към хоста, винаги е с единица по-голямо от последния получен пореден номер на блоковете от съобщения, получени от хоста. То не се използва за проследяване на последователността на блоковете със съобщения за отговор.
