# Актуализации на SDCard

Много от популярните днес контролни платки се доставят с буутлоудър, който може да актуализира фърмуера чрез SD карта. Въпреки че това е удобно при много обстоятелства, тези буутлоудъри обикновено не предоставят друг начин за актуализиране на фърмуера. Това може да бъде неудобно, ако вашата платка е монтирана на място, което е труднодостъпно, или ако трябва често да актуализирате фърмуера. След като Klipper е бил първоначално флашнат на контролер, е възможно да се прехвърли нов фърмуер на SD картата и да се започне процедура за флашване чрез ssh.

## Типична процедура за надграждане

Процедурата за актуализиране на фърмуера на MCU чрез SD картата е подобна на тази при другите методи. Вместо да се използва `make flash`, е необходимо да се стартира помощен скрипт, `flash-sdcard.sh`. Обновяването на BigTreeTech SKR 1.3 може да изглежда по следния начин:

```
sudo service klipper stop
cd ~/klipper
git pull
make clean
make menuconfig
make
./scripts/flash-sdcard.sh /dev/ttyACM0 btt-skr-v1.3
sudo service klipper start
```

Потребителят трябва да определи местоположението на устройството и името на борда. Ако потребителят трябва да флашне няколко платки, `flash-sdcard.sh` (или `make flash`, ако е подходящо) трябва да се стартира за всяка платка преди рестартиране на услугата Klipper.

Поддържаните платки могат да бъдат изброени със следната команда:

```
./scripts/flash-sdcard.sh -l
```

Ако не виждате своя борд в списъка, може да се наложи да добавите нова дефиниция на борд, както е описано по-долу (#board-definitions).

## Усъвършенствана употреба

Горните команди предполагат, че вашият MCU се свързва със скорост по подразбиране 250000 бода, а фърмуерът се намира на адрес `~/klipper/out/klipper.bin`. Скриптът `flash-sdcard.sh` предоставя опции за промяна на тези настройки по подразбиране. Всички опции могат да бъдат разгледани от помощния екран:

```
./scripts/flash-sdcard.sh -h
SD Card upload utility for Klipper

usage: flash_sdcard.sh [-h] [-l] [-c] [-b <baud>] [-f <firmware>]
                       <device> <board>

positional arguments:
  <device>        device serial port
  <board>         board type

optional arguments:
  -h              show this message
  -l              list available boards
  -c              run flash check/verify only (skip upload)
  -b <baud>       serial baud rate (default is 250000)
  -f <firmware>   path to klipper.bin
```

Ако вашата платка е подсилена с фърмуер, който се свързва с потребителска скорост на предаване, е възможно да се актуализира чрез посочване на опцията `-b`:

```
./scripts/flash-sdcard.sh -b 115200 /dev/ttyAMA0 btt-skr-v1.3
```

Ако желаете да флашнете компилация на Klipper, намираща се на място, различно от мястото по подразбиране, това може да стане, като посочите опцията `-f`:

```
./scripts/flash-sdcard.sh -f ~/downloads/klipper.bin /dev/ttyAMA0 btt-skr-v1.3
```

Имайте предвид, че при обновяване на MKS Robin E3 не е необходимо да стартирате ръчно файла `update_mks_robin.py` и да предоставяте получената бинарна информация на файла `flash-sdcard.sh`. Тази процедура е автоматизирана по време на процеса на качване.

Опцията `-c` се използва за извършване на операция за проверка или само за проверка, за да се провери дали платката работи с посочения фърмуер правилно. Тази опция е предназначена предимно за случаи, в които е необходим ръчен цикъл на захранване, за да се завърши процедурата по флаширане, като например при буутлоудъри, които използват SDIO режим вместо SPI за достъп до своите SD карти. (Вижте "Предупреждения" по-долу) Но тя може да се използва и по всяко време, за да се провери дали кодът, флашнат в платката, съответства на версията във вашата папка за изграждане на всяка поддържана платка.

## Предупреждения

- Както беше споменато във въведението, този метод работи само за обновяване на фърмуера. Процедурата за първоначално проблясване трябва да се извърши ръчно съгласно инструкциите, които се отнасят за вашата контролна платка.
- Въпреки че е възможно да флашнете компилация, която променя интерфейса за серийно предаване или връзката (т.е. от USB към UART), проверката винаги ще бъде неуспешна, тъй като скриптът няма да може да се свърже отново с MCU, за да провери текущата версия.
- Поддържат се само платки, които използват SPI за комуникация с SD картата. Платките, които използват SDIO, като Flymaker Flyboard и MKS Robin Nano V1/V2, няма да работят в режим SDIO. Обикновено обаче е възможно да флашнете такива платки, като вместо това използвате софтуерен SPI режим. Но ако буутлоудърът на платката използва само режим SDIO за достъп до SD картата, ще е необходим захранващ цикъл на платката и SD картата, за да може режимът да премине от SPI обратно към SDIO и да завърши препрограмирането. Такива платки трябва да бъдат дефинирани с активирана функция `skip_verify`, за да се прескочи стъпката за проверка веднага след флашване. След това, след ръчно включване на захранването, можете да изпълните отново същата команда `./scripts/flash-sdcard.sh`, но да добавите опцията `-c`, за да завършите операцията по проверка/верификация. Вижте [Flashing Boards that use SDIO](#flashing-boards-that-use-sdio) за примери.

## Определения на борда

Най-често срещаните табла трябва да са налични, но при необходимост е възможно да се добави ново определение на табло. Дефинициите на платки се намират в `~/klipper/scripts/spi_flash/board_defs.py`. Дефинициите се съхраняват в речник, например:

```python
BOARD_DEFS = {
    'generic-lpc1768': {
        'mcu': "lpc1768",
        'spi_bus': "ssp1",
        "cs_pin": "P0.6"
    },
    ...<further definitions>
}
```

Могат да бъдат зададени следните полета:

- `mcu`: Типът mcu. Той може да бъде получен след конфигуриране на компилацията чрез `make menuconfig`, като се стартира `cat .config | grep CONFIG_MCU`. Това поле е задължително.
- `spi_bus`: SPI шината, свързана към SD картата. Това трябва да се извлече от схемата на платката. Това поле е задължително.
- `cs_pin`: Пинът за избор на чип, свързан към SD картата. Той трябва да се извлече от схемата на платката. Това поле е задължително.
- `firmware_path`: Пътят в SD картата, по който трябва да се прехвърли фърмуерът. По подразбиране е `firmware.bin`.
- `current_firmware_path`: Пътят на SD картата, където се намира преименуваният файл с фърмуера след успешна флаш памет. По подразбиране е `firmware.cur`.
- `skip_verify`: Това е булева стойност, която указва на скриптовете да прескочат етапа на проверка на фърмуера по време на процеса на флашване. По подразбиране е `False`. Тя може да бъде зададена на `True` за платки, които изискват ръчен цикъл на захранване, за да завършат мигането. За да проверите фърмуера след това, стартирайте скрипта отново с опцията `-c`, за да извършите стъпката за проверка. [Вижте предупрежденията при SDIO картите](#caveats)

Ако се изисква софтуерен SPI, полето `spi_bus` трябва да се зададе на `swspi` и да се посочи следното допълнително поле:

- `spi_pins`: Това трябва да са 3 щифта, разделени със запетая, които са свързани към SD картата под формата на `miso,mosi,sclk`.

Софтуерният SPI е необходим изключително рядко, обикновено това се налага само при платки с грешки в дизайна или при платки, които обикновено поддържат само режим SDIO за своята SD карта. Дефиницията на платката `btt-skr-pro` дава пример за първото, а дефиницията на платката `btt-octopus-f446-v1` дава пример за второто.

Преди да създадете нова дефиниция на съвет, трябва да проверите дали съществуваща дефиниция на съвет отговаря на критериите, необходими за новия съвет. Ако това е така, може да се посочи `BOARD_ALIAS`. Например може да се добави следният псевдоним, за да се посочи `my-new-board` като псевдоним на `generic-lpc1768`:

```python
BOARD_ALIASES = {
    ...<previous aliases>,
    'my-new-board': BOARD_DEFS['generic-lpc1768'],
}
```

Ако се нуждаете от нова дефиниция на дъската и не ви е удобна процедурата, описана по-горе, препоръчваме да я поискате в [Klipper Community Discord](Contact.md#discord).

## Мигащи платки, които използват SDIO

[Както е споменато в Caveats](#caveats), платките, чийто буутлоудър използва SDIO режим за достъп до SD картата, изискват захранващ цикъл на платката и по-специално на самата SD карта, за да се превключи от SPI режим, използван при записването на файла в SD картата, обратно към SDIO режим, за да може буутлоудърът да го флашне в платката. При тези дефиниции на платки ще се използва флагът `skip_verify`, който указва на инструмента за флашване да спре след записването на фърмуера на SD картата, така че платката да може да се захрани ръчно и стъпката за проверка да се отложи, докато приключи.

Има два сценария - единият с RPi Host, работещ с отделно захранване, а другият - когато RPi Host работи със същото захранване като основната платка, която се флашва. Разликата е в това дали е необходимо да се изключи RPi и след това отново да се `ssh` след приключване на флашването, за да се извърши проверката, или проверката може да се извърши веднага. Ето примери за двата сценария:

### Програмиране на SDIO с RPi на отделно захранване

Една типична сесия с RPi с отделно захранване изглежда по следния начин. Разбира се, ще трябва да използвате правилния път до устройството и името на платката:

```
sudo service klipper stop
cd ~/klipper
git pull
make clean
make menuconfig
make
./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1
[[[manually power-cycle the printer board here when instructed]]]
./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1
sudo service klipper start
```

### Програмиране на SDIO с RPi на едно и също захранване

Една типична сесия с RPi на същото захранване изглежда по следния начин. Разбира се, ще трябва да използвате правилния път до устройството и името на платката:

```
sudo service klipper stop
cd ~/klipper
git pull
make clean
make menuconfig
make
./scripts/flash-sdcard.sh /dev/ttyACM0 btt-octopus-f446-v1
sudo shutdown -h now
[[[wait for the RPi to shutdown, then power-cycle and ssh again to the RPi when it restarts]]]
sudo service klipper stop
cd ~/klipper
./scripts/flash-sdcard.sh -c /dev/ttyACM0 btt-octopus-f446-v1
sudo service klipper start
```

В този случай, тъй като RPi Host се рестартира, което ще доведе до рестартиране на услугата `klipper`, е необходимо да спрете `klipper` отново, преди да извършите стъпката за проверка, и да я рестартирате след приключване на проверката.

### Картографиране на изводите SDIO към SPI

Ако схемата на вашата платка използва SDIO за SD картата, можете да картографирате изводите, както е описано в таблицата по-долу, за да определите съвместимите софтуерни SPI изводи, които да зададете във файла `board_defs.py`:

| Щифт за SD карта | Щифт за Micro SD карта | Име на щифта SDIO | Име на SPI извод |
| :-: | :-: | :-: | :-: |
| 9 | 1 | DATA2 | Няма (PU)* |
| 1 | 2 | CD/DATA3 | CS |
| 2 | 3 | CMD | MOSI |
| 4 | 4 | +3.3V (VDD) | +3.3V (VDD) |
| 5 | 5 | CLK | SCLK |
| 3 | 6 | GND (VSS) | GND (VSS) |
| 7 | 7 | DATA0 | MISO |
| 8 | 8 | DATA1 | Няма (PU)* |
| N/A | 9 | Разпознаване на карти (CD) | Разпознаване на карти (CD) |
| 6 | 10 | GND | GND |

\* Няма (PU) показва неизползван извод с издърпващ резистор
