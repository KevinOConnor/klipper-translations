# Сервер API

В этом документе описывается интерфейс прикладного программиста Klipper (API). Этот интерфейс позволяет внешним приложениям запрашивать программное обеспечение хоста Klipper и управлять им.

## Включение сокета API

Для того, чтобы использовать сервер API, необходимо klippy.py программное обеспечение хоста должно быть запущено с параметром `-a`. Например:

```
~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log
```

Это приводит к тому, что программное обеспечение хоста создает доменный сокет Unix. Затем клиент может открыть соединение с этим сокетом и отправлять команды Klipper.

Смотрите проект [Moonraker](https://github.com/Arksine/moonraker) для популярного инструмента, который может перенаправлять HTTP-запросы на API-сервер Klipper's Unix Domain Socket.

## Формат запроса

Сообщения, передаваемые и принимаемые по сокету, представляют собой строки в кодировке JSON, завершаемые символом ASCII 0x03:

```
<json_object_1><0x03><json_object_2><0x03>...
```

Klipper содержит инструмент `scripts/whconsole.py`, который может выполнять указанное выше обрамление сообщений. Например:

```
~/klipper/scripts/whconsole.py /tmp/klippy_uds
```

Этот инструмент может считывать серию JSON-команд из stdin, отправлять их в Klipper и сообщать о результатах. Инструмент ожидает, что каждая команда JSON будет в одной строке, и при передаче запроса он автоматически добавит терминатор 0x03. (Сервер API Klipper не требует ставить новую строку)

## Протокол API

Протокол команд, используемый на коммуникационном сокете, вдохновлен [json-rpc](https://www.jsonrpc.org/).

Запрос может выглядеть следующим образом:

`{" идентификатор": 123, ""метод": " "информация", "параметры": {}}`

и ответ может выглядеть следующим образом:

`{" идентификатор": 123, " результат": {"state_message": "Принтер готов", " klipper_path": "/home/pi/klipper", "config_file": "/home/pi/printer.cfg", " программная_версия": "v0.8.0-823-g883b1cb6", "hostname": "octopi", "cpu_info": "4-ядерный процессор ARMv7 rev 4 (v7l)", ""состояние": " готов", "python_path": "/home/pi/klippy-env/bin/python", " лог_файл": "/tmp/klippy.log"}}`

Каждый запрос должен представлять собой JSON-словарь. (В этом документе используется термин Python "словарь" для описания "объекта JSON" - отображения пар ключ/значение, содержащихся в `{}`)

Словарь запросов должен содержать параметр " метод", который представляет собой строковое имя доступной "конечной точки" Klipper.

Словарь запроса может содержать параметр "params", который должен иметь тип словаря. Параметр "params" предоставляет дополнительную информацию о параметрах для "конечной точки" Klipper, обрабатывающей запрос. Его содержание зависит от конкретной "конечной точки".

Словарь запроса может содержать параметр "id", который может быть любого типа JSON. Если "id" присутствует, то Klipper ответит на запрос сообщением, содержащим этот "id". Если параметр "id" опущен (или установлен в значение JSON " нуль"), то Klipper не будет предоставлять никакого ответа на запрос. Ответное сообщение - это JSON-словарь, содержащий "id" и "result". Результат" всегда является словарем - его содержимое зависит от "конечной точки", обрабатывающей запрос.

Если в результате обработки запроса возникла ошибка, то в ответном сообщении вместо поля "результат" будет содержаться поле "ошибка". Например, запрос: `{"идентификатор": 123, ""метод": "gcode/скрипт", "параметры": { "скрипт": "G1 X200"}}` может привести к ответу об ошибке, например: `{"id": 123, "ошибка": {"сообщение": "Сначала должна быть домашняя ось: 200.000 0.000 0.000 [0.000]", "ошибка": "WebRequestError"}}`

Klipper всегда начинает обработку запросов в порядке их поступления. Однако некоторые запросы могут быть завершены не сразу, что может привести к тому, что связанный с ними ответ будет отправлен не по порядку относительно ответов от других запросов. JSON-запрос никогда не приостанавливает обработку последующих JSON-запросов.

## Подписки

Некоторые запросы "конечной точки" Klipper позволяют "подписаться" на будущие асинхронные сообщения об обновлениях.

Например:

`{"идентификатор": 123, "метод": "gcode/subscribe_output", "параметры": {"response_template":{"ключ": 345}}}`

может первоначально ответить:

`{" идентификатор": 123, "результат": {}}`

и заставить Klipper отправлять в будущем сообщения, подобные этому:

`{" параметры": { " ответ": "ok B:22.8 /0.0 T0:22.4 /0.0"}, " ключ": 345}`

Запрос на подписку принимает словарь "response_template" в поле "params" запроса. Этот словарь "response_template" используется в качестве шаблона для будущих асинхронных сообщений - он может содержать произвольные пары ключ/значение. При отправке этих будущих асинхронных сообщений Klipper добавит в шаблон ответа поле "params", содержащее словарь с содержимым, специфичным для "конечной точки", и затем отправит этот шаблон. Если поле "response_template" не указано, то по умолчанию будет использоваться пустой словарь (`{}`).

## Доступные "конечные точки"

По условию, "конечные точки" Klipper имеют вид `<имя_модуля>/<имя_модуля>`. При выполнении запроса к "конечной точке" полное имя должно быть задано в параметре "method" словаря запроса (например, `{"метод"="gcode/restart"}`).

### информация

Конечная точка "info" используется для получения информации о системе и версии от Klipper. Она также используется для предоставления Klipper информации о версии клиента. Например: `{"идентификатор": 123, "метод": "информация ", " параметры ": { "client_info": { " версия": "v1"}}}`

Если параметр "client_info" присутствует, он должен быть словарем, но этот словарь может иметь произвольное содержимое. Клиентам рекомендуется указывать имя клиента и версию его программного обеспечения при первом подключении к серверу Klipper API.

### emergency_stop

Конечная точка "emergency_stop" используется для указания Klipper перейти в состояние "выключения". Она ведет себя аналогично команде G-кода `M112`. Например: `{" идентификатор": 123, "метод": "emergency_stop"}}

### register_remote_method

Эта конечная точка позволяет клиентам регистрировать методы, которые могут быть вызваны из klipper. В случае успеха он вернет пустой объект.

Например: `{" идентификатор": 123, " метод": "register_remote_method", " параметры": { "response_template": {" действие": "run_paneldue_beep"}, "remote_method": "paneldue_beep"}}` вернет: `{" идентификатор": 123, " результат": {}}`

Удаленный метод `paneldue_beep` теперь может быть вызван из Klipper. Обратите внимание, что если метод принимает параметры, то они должны быть предоставлены как аргументы ключевого слова. Ниже приведен пример вызова метода из gcode_macro:

```
[gcode_macro PANELDUE_BEEP]
gcode:
  {action_call_remote_method("paneldue_beep", frequency=300, duration=1.0)}
```

Когда выполняется макрос gcode PANELDUE_BEEP, Klipper отправляет по сокету что-то вроде следующего: `{" действие": "run_paneldue_beep", "параметры": {" частота": 300, "продолжительность": 1.0}}`

### объекты/списки

Эта конечная точка запрашивает список доступных "объектов" принтера, которые можно запросить (через конечную точку " объекты/запрос"). Например: `{" идентификатор": 123, "метод": " объекты/список"}` может вернуть: `{" идентификатор": 123, " результат": { " объекты": [" вебхуки", " конфигфайл", "нагреватели", "gcode_move", "query_endstops", "idle_timeout", " инструментальная головка", "экструдер"]}}''

### объекты/запросы

Эта конечная точка позволяет запрашивать информацию из объектов принтера. Например: `{" идентификатор": 123, " метод": " объекты/запрос", "параметры": {" объекты": {" инструменты": [" позиция"], " вебхуки": null}}}}" может вернуть: `{" идентификатор": 123, " результат": { " статус": {" вебхуки": {" состояние": "готов", "state_message": "Принтер готов"}, " инструментарий": { " позиция": [0.0, 0.0, 0.0, 0.0]}}, " время события": 3051555.377933684}}`

Параметр "объекты" в запросе должен представлять собой словарь, содержащий объекты принтера, которые необходимо запросить - ключ содержит имя объекта принтера, а значение - либо "ноль" (для запроса всех полей), либо список имен полей.

Ответное сообщение будет содержать поле "статус", содержащее словарь с запрашиваемой информацией - ключ содержит имя объекта принтера, а значение - словарь, содержащий его поля. Ответное сообщение также будет содержать поле "время события", содержащее метку времени, когда был сделан запрос.

Доступные поля описаны в документе [Справочник статуса](Status_Reference.md).

### объекты/подписка

Эта конечная точка позволяет запрашивать и затем подписываться на информацию от объектов принтера. Запрос и ответ конечной точки идентичны конечной точке "objects/query". Например: `{" идентификатор": 123, " метод": "objects/subscribe", " параметры": { " объекты":{ " инструменты": [" позиция"], " вебхуки": [" состояние"]}, "response_template":{}}}` может вернуть: `{" идентификатор": 123, " результат": { " статус": { " вебхуки": { " состояние": " готов"}, " головка инструмента": { " позиция": [0.0, 0.0, 0.0, 0.0]}}, " событие": 3052153.382083195}}'' и привести к последующим асинхронным сообщениям, таким как: `{" параметры": {" статус": {" Вебхуки": {" состояние": " отключение"}}, " время событий": 3052165.418815847}}`

### gcode/help

Эта конечная точка позволяет запрашивать доступные команды G-Code, для которых определена строка помощи. Например: `{" идентификатор": 123, " метод": "gcode/help"}` может вернуть: `{" идентификатор": 123, " результат": { "RESTORE_GCODE_STATE": "Восстановить ранее сохраненное состояние G-кода", "PID_CALIBRATE": "Запустить тест калибровки ПИД", "QUERY_ADC": "Сообщить последнее значение аналогового пина", ...}}`

### gcode/script

Эта конечная точка позволяет выполнить серию команд G-Code. Например: `{" идентификатор": 123, " метод": "gcode/script", " параметры": {" скрипт": "G90"}}`

Если предоставленный сценарий G-кода приводит к ошибке, то генерируется ответ об ошибке. Однако если команда G-Code выводит терминальный вывод, то этот вывод не будет предоставлен в ответе. (Для получения терминального вывода G-кода используйте конечную точку "gcode/subscribe_output")

Если в момент получения этого запроса выполняется команда G-Code, то предоставленный сценарий будет поставлен в очередь. Эта задержка может быть значительной (например, если выполняется команда G-Code wait for temperature). Ответное сообщение JSON отправляется, когда обработка сценария полностью завершена.

### gcode/restart

Эта конечная точка позволяет запросить перезапуск - это аналогично выполнению команды G-Code "RESTART". Например: `{"id": 123, "method": "gcode/restart"}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### gcode/firmware_restart

Это аналогично конечной точке "gcode/restart" - она реализует команду G-кода "FIRMWARE_RESTART". Например: `{"id": 123, "method": "gcode/firmware_restart"}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### gcode/subscribe_output

Эта конечная точка используется для подписки на сообщения терминала G-Code, которые генерируются Klipper. Например: `{"id": 123, "method": "gcode/subscribe_output", "params": {"response_template":{}}}}` может впоследствии выдать такие асинхронные сообщения, как: `{"params": {"response": "// Состояние клиппера: Shutdown"}}`

Эта конечная точка предназначена для поддержки взаимодействия с человеком через интерфейс "окно терминала". Разбор содержимого терминального вывода G-Code не рекомендуется. Используйте конечную точку "objects/subscribe" для получения обновлений о состоянии Klipper.

### motion_report/dump_stepper

Эта конечная точка используется для подписки на внутренний поток команд queue_step для шагового механизма Klipper. Получение этих низкоуровневых обновлений движения может быть полезно для целей диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{"id": 123, "method": "motion_report/dump_stepper", "params": { "name": "stepper_x", "response_template": {}}}` и может вернуть: `{"id": 123, "result": { "header": ["interval", "count", "add"]}}` и в дальнейшем может выдавать асинхронные сообщения, такие как: `{"params": {"first_clock": 179601081, "first_time": 8.98, "first_position": 0, "last_clock": 219686097, "last_time": 10.984, "data": [[179601081, 1, 0], [29573, 2, -8685], [16230, 4, -1525], [10559, 6, -160], [10000, 976, 0], [10000, 1000, 0], [10000, 1000, 0], [10000, 1000, 0], [9855, 5, 187], [11632, 4, 1534], [20756, 2, 9442]]}}`

Поле "заголовок" в первоначальном ответе на запрос используется для описания полей, содержащихся в последующих ответах "данные".

### motion_report/dump_trapq

Эта конечная точка используется для подписки на внутреннюю "очередь движения трапеции" Klipper. Получение этих низкоуровневых обновлений движения может быть полезно для диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{" идентификатор": 123, " метод": "motion_report/dump_trapq", " параметры": { " название": " инструментальная головка", "response_template":{}}}` и может возвращать: `{" идентификатор": 1, " результат": { " заголовок": [" время", "продолжительность", "start_velocity", " ускорение", "start_position", "direction"]}}` и впоследствии может выдать асинхронные сообщения, такие как: `{" параметры": {"data": [[4.05, 1.0, 0.0, 0.0, [300.0, 0.0, 0.0], [0.0, 0.0, 0.0]], [5.054, 0.001, 0.0, 3000.0, [300.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]]}}`

Поле "заголовок" в первоначальном ответе на запрос используется для описания полей, содержащихся в последующих ответах "данные".

### adxl345/dump_adxl345

Эта конечная точка используется для подписки на данные акселерометра ADXL345. Получение этих низкоуровневых обновлений движения может быть полезно для целей диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{"id": 123, "method": "adxl345/dump_adxl345", "params": { "sensor": "adxl345", "response_template": {}}}` и может вернуть: `{"id": 123, "result":{"header":["time", "x_acceleration", "y_acceleration", "z_acceleration"]}}` и может позже выдать асинхронные сообщения, такие как: `{"params":{"overflows":0,"data":[[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,9561.48375]]}}`

Поле "заголовок" в первоначальном ответе на запрос используется для описания полей, содержащихся в последующих ответах "данные".

### angle/dump_angle

Эта конечная точка используется для подписки на [данные датчика угла](Config_Reference.md#angle). Получение этих низкоуровневых обновлений движения может быть полезно для диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{"id": 123, "method": "angle/dump_angle", "params": { "sensor": "my_angle_sensor", "response_template": {}}}` и может вернуть: `{"id": 123, "result":{"header":["time", "angle"]}}` и в дальнейшем может выдавать асинхронные сообщения, такие как: `{"params":{"position_offset":3.151562,"errors":0, "data":[[1290.951905,-5063],[1290.952321,-5065]]}}`

Поле "заголовок" в первоначальном ответе на запрос используется для описания полей, содержащихся в последующих ответах "данные".

### hx71x/dump_hx71x

Эта конечная точка используется для подписки на необработанные данные АЦП HX711 и HX717. Получение этих низкоуровневых обновлений АЦП может быть полезно для целей диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{"id": 123, "method": "hx71x/dump_hx71x", "params": { "sensor": "load_cell", "response_template": {}}}` и может вернуть: `{"id": 123, "result":{"header":["time", "counts", "value"]}}` и в дальнейшем может выдавать асинхронные сообщения, такие как: `{"params":{"data":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}`

### ads1220/dump_ads1220

Эта конечная точка используется для подписки на необработанные данные АЦП ADS1220. Получение этих низкоуровневых обновлений АЦП может быть полезно для целей диагностики и отладки. Использование этой конечной точки может увеличить нагрузку на систему Klipper.

Запрос может выглядеть следующим образом: `{"id": 123, "method": "ads1220/dump_ads1220", "params": { "sensor": "load_cell", "response_template": {}}}` и может вернуть: `{"id": 123, "result":{"header":["time", "counts", "value"]}}` и в дальнейшем может выдавать асинхронные сообщения, такие как: `{"params":{"data":[[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}`

### pause_resume/cancel

Эта конечная точка аналогична выполнению команды G-кода "PRINT_CANCEL". Например: `{"id": 123, "method": "pause_resume/cancel"}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### pause_resume/pause

Эта конечная точка аналогична выполнению команды G-кода "PAUSE". Например: `{"id": 123, "method": "pause_resume/pause"}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### pause_resume/resume

Эта конечная точка аналогична выполнению команды G-кода "RESUME". Например: `{"id": 123, "method": "pause_resume/resume"}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### query_endstops/status

Эта конечная точка будет запрашивать активные конечные точки и возвращать их статус. Например: `{"id": 123, "method": "query_endstops/status"}` может вернуть: `{"id": 123, "result": {"y": "открыто", "x": "открыто", "z": "TRIGGERED"}}`

Как и в случае с конечной точкой "gcode/script", эта конечная точка завершается только после выполнения всех ожидающих команд G-Code.

### bed_mesh/dump_mesh

Сбрасывает конфигурацию и состояние для текущей сетки и всех сохраненных профилей.

Например: `{"id": 123, "method": "bed_mesh/dump_mesh"}`

может вернуться:

```
{
    "current_mesh": {
        "name": "eddy-scan-test",
        "probed_matrix": [...],
        "mesh_matrix": [...],
        "mesh_params": {
            "x_count": 9,
            "y_count": 9,
            "mesh_x_pps": 2,
            "mesh_y_pps": 2,
            "algo": "bicubic",
            "tension": 0.5,
            "min_x": 20,
            "max_x": 330,
            "min_y": 30,
            "max_y": 320
        }
    },
    "profiles": {
        "default": {
            "points": [...],
            "mesh_params": {
                "min_x": 20,
                "max_x": 330,
                "min_y": 30,
                "max_y": 320,
                "x_count": 9,
                "y_count": 9,
                "mesh_x_pps": 2,
                "mesh_y_pps": 2,
                "algo": "bicubic",
                "tension": 0.5
            }
        },
        "eddy-scan-test": {
            "points": [...],
            "mesh_params": {
                "x_count": 9,
                "y_count": 9,
                "mesh_x_pps": 2,
                "mesh_y_pps": 2,
                "algo": "bicubic",
                "tension": 0.5,
                "min_x": 20,
                "max_x": 330,
                "min_y": 30,
                "max_y": 320
            }
        },
        "eddy-rapid-test": {
            "points": [...],
            "mesh_params": {
                "x_count": 9,
                "y_count": 9,
                "mesh_x_pps": 2,
                "mesh_y_pps": 2,
                "algo": "bicubic",
                "tension": 0.5,
                "min_x": 20,
                "max_x": 330,
                "min_y": 30,
                "max_y": 320
            }
        }
    },
    "calibration": {
        "points": [...],
        "config": {
            "x_count": 9,
            "y_count": 9,
            "mesh_x_pps": 2,
            "mesh_y_pps": 2,
            "algo": "bicubic",
            "tension": 0.5,
            "mesh_min": [
                20,
                30
            ],
            "mesh_max": [
                330,
                320
            ],
            "origin": null,
            "radius": null
        },
        "probe_path": [...],
        "rapid_path": [...]
    },
    "probe_offsets": [
        0,
        25,
        0.5
    ],
    "axis_minimum": [
        0,
        0,
        -5,
        0
    ],
    "axis_maximum": [
        351,
        358,
        330,
        0
    ]
}
```

Конечная точка `dump_mesh` принимает один необязательный параметр, `mesh_args`. Этот параметр должен быть объектом, где ключами и значениями являются параметры, доступные для [BED_MESH_CALIBRATE](#bed_mesh_calibrate). Перед возвратом результата будет обновлена конфигурация сетки и точки зондирования с использованием предоставленных параметров. Рекомендуется опустить параметры сетки, если не требуется визуализировать точки зондирования и/или траекторию движения перед выполнением `BED_MESH_CALIBRATE`.
