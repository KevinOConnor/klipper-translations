# Плата BeagleBone

В этом документе описывается процесс запуска Klipper на Beaglebone PRU.

## Сборка образа ОС

Начните с установки образа [Debian 11.7 2023-09-02 4GB microSD IoT](https://beagleboard.org/latest-images). Образ можно запустить как с карты micro-SD, так и со встроенной eMMC. Если вы используете eMMC, установите его на eMMC, следуя инструкциям по ссылке выше.

Затем зайдите по ssh на машину Beaglebone (`ssh debian@beaglebone` -- пароль `temppwd`).

Перед началом установки Klipper необходимо освободить дополнительное пространство. Для этого есть 3 варианта:

1. удалить некоторые "демонстрационные" ресурсы BeagleBone
1. Если вы загрузились с SD-карты, и ее объем превышает 4 Гб - вы можете расширить текущую файловую систему, чтобы она заняла все пространство карты
1. выполните варианты №1 и №2 вместе.

Чтобы удалить некоторые ресурсы BeagleBone "Демо", выполните следующие команды

```
sudo apt remove bb-node-red-installer
sudo apt remove bb-code-server
```

Чтобы расширить файловую систему до полного размера SD-карты, выполните эту команду, перезагрузка не требуется.

```
sudo growpart /dev/mmcblk0 1
sudo resize2fs /dev/mmcblk0p1
```

Установите Klipper, выполнив следующие команды:

```
git clone https://github.com/Klipper3d/klipper.git
./klipper/scripts/install-beaglebone.sh
```

После установки Klipper вам нужно решить, какой тип развертки вам нужен, но учтите, что BeagleBone - это оборудование на базе 3,3 В, и в большинстве случаев вы не можете напрямую подключить контакты к оборудованию на базе 5 или 12 В без плат-переходников.

Поскольку Klipper имеет многомодульную архитектуру на BeagleBone, вы можете реализовать множество различных сценариев использования, но общие из них следующие:

Вариант использования 1: использование BeagleBone только в качестве хост-системы для запуска Klipper и дополнительного программного обеспечения, такого как OctoPrint/Fluidd + Moonraker/... и эта конфигурация будет управлять внешними микроконтроллерами через последовательные/usb/canbus соединения.

Вариант использования 2: использование BeagleBone с платой расширения (накидкой), подобной плате CRAMPS. В этой конфигурации BeagleBone будет размещать Klipper + дополнительное программное обеспечение, и он будет управлять платой расширения с помощью ядер BeagleBone PRU (2 дополнительных ядра 200Mh, 32Bit).

Пример 3: То же самое, что и в случае 1, но дополнительно вы хотите управлять GPIO BeagleBone с высокой скоростью, используя ядра PRU, чтобы разгрузить основной процессор.

## Установка Octoprint

После этого можно установить Octoprint или полностью пропустить этот раздел при желании установить другое программное обеспечение:

```
git clone https://github.com/foosel/OctoPrint.git
cd OctoPrint/
virtualenv venv
./venv/bin/python setup.py install
```

И настройте OctoPrint на запуск при загрузке:

```
sudo cp ~/OctoPrint/scripts/octoprint.init /etc/init.d/octoprint
sudo chmod +x /etc/init.d/octoprint
sudo cp ~/OctoPrint/scripts/octoprint.default /etc/default/octoprint
sudo update-rc.d octoprint defaults
```

Необходимо изменить файл конфигурации **/etc/default/octoprint** OctoPrint. Необходимо изменить пользователя OCTOPRINT_USER на debian, NICELEVEL на 0, раскомментировать настройки BASEDIR, CONFIGFILE и DAEMON и изменить ссылки с /home/pi/ на `/home/debian/`:

```
sudo nano /etc/default/octoprint
```

Затем запустите сервис Octoprint:

```
sudo systemctl start octoprint
```

Подождите 1-2 минуты и убедитесь, что веб-сервер OctoPrint доступен - он должен находиться по адресу: <http://beaglebone:5000/>

## Создание кода микроконтроллера BeagleBone PRU (прошивка PRU)

Этот раздел необходим для "Варианта использования 2" и "Варианта использования 3", упомянутых выше, для "Варианта использования 1" его следует пропустить.

Проверьте наличие необходимых устройств

```
sudo beagle-version
```

Необходимо проверить, что вывод содержит успешную загрузку драйверов "remoteproc" и наличие ядер PRU, в Kernel 5.10 это должны быть "remoteproc1" и "remoteproc2" (4a334000.pru, 4a338000.pru) Также проверьте, что многие GPIO загружены, они будут выглядеть как "Allocated GPIO id=0 name='P8_03'" Обычно все в порядке и не требуется аппаратная настройка. Если чего-то не хватает - попробуйте поиграть с опциями "uboot overlays" или с cape-overlays Просто для справки несколько выводов рабочей конфигурации BeagleBone Black с платой CRAMPS:

```
модель:[TI_AM335x_BeagleBone_Black]
UBOOT: Загруженное дерево устройств:[am335x-boneblack-uboot-univ.dts]
UBOOT: Загружен оверлей:[BB-ADC-00A0.bb.org-overlays]
UBOOT: Загружен оверлей:[BB-BONE-eMMC1-01-00A0.bb.org-overlays]
kernel:[5.10.168-ti-r71]
/boot/uEnv.txt Настройки:
uboot_overlay_options:[enable_uboot_overlays=1]
uboot_overlay_options:[disable_uboot_overlay_video=0]
uboot_overlay_options:[disable_uboot_overlay_audio=1]
uboot_overlay_options:[disable_uboot_overlay_wireless=1]
uboot_overlay_options:[enable_uboot_cape_universal=1]
pkg:[bb-cape-overlays]:[4.14.20210821.0-0~bullseye+20210821]
pkg:[bb-customizations]:[1.20230720.1-0~bullseye+20230720]
pkg:[bb-usb-gadgets]:[1.20230414.0-0~bullseye+20230414]
pkg:[bb-wl18xx-firmware]:[1.20230414.0-0~bullseye+20230414]
.............
.............
```

Чтобы скомпилировать код микроконтроллера Klipper, начните с его настройки для "Beaglebone PRU", для "BeagleBone Black" дополнительно отключите опции " Поддержка GPIO Bit-banging устройств" и отключите "Поддержка LCD устройств" в разделе "Дополнительные функции", так как они не поместятся в 8 Кб памяти прошивки PRU, затем выйдите и сохраните конфиг:

```
cd ~/klipper/
make menuconfig
```

Чтобы собрать и установить новый код микроконтроллера PRU, выполните команду:

```
sudo service klipper stop
make flash
sudo service klipper start
```

После выполнения предыдущих команд прошивка вашего PRU должна быть готова и запущена, чтобы проверить, все ли в порядке, выполните следующую команду

```
dmesg
```

и сравните последние сообщения с образцом, который показывает, что все запустилось правильно:

```
[ 71.105499] remoteproc remoteproc1: 4a334000.pru доступен
[ 71.157155] remoteproc remoteproc2: 4a338000.pru доступен
[ 73.256287] remoteproc remoteproc1: включение питания 4a334000.pru
[ 73.279246] remoteproc remoteproc1: Загрузка образа fw am335x-pru0-fw, размер 97112
[ 73.285807] remoteproc1#vdev0buffer: зарегистрирован virtio0 (тип 7)
[ 73.285836] remoteproc remoteproc1: удаленный процессор 4a334000.pru теперь работает
[ 73.286322] remoteproc remoteproc2: включение питания 4a338000.pru
[ 73.313717] remoteproc remoteproc2: Загрузка образа fw am335x-pru1-fw, размер 188560
[ 73.313753] remoteproc remoteproc2: таблица ресурсов без заголовков
[ 73.329964] remoteproc remoteproc2: таблица ресурсов без заголовков
[ 73.348321] remoteproc remoteproc2: удаленный процессор 4a338000.pru теперь работает
[ 73.443355] virtio_rpmsg_bus virtio0: создание канала rpmsg-pru addr 0x1e
[ 73.443727] virtio_rpmsg_bus virtio0: msg received with no recipient
[ 73.444352] virtio_rpmsg_bus virtio0: rpmsg host is online
[ 73.540993] rpmsg_pru virtio0.rpmsg-pru.-1.30: новое устройство rpmsg_pru: /dev/rpmsg_pru30
```

обратите внимание на "/dev/rpmsg_pru30" - это ваше будущее последовательное устройство для основной конфигурации mcu. Это устройство должно присутствовать, если оно отсутствует - ваши ядра PRU не запустились должным образом.

## Сборка и установка кода микроконтроллера на хост Linux

Этот раздел обязателен для "Варианта использования 2" и необязателен для "Варианта использования 3", упомянутого выше

Также необходимо скомпилировать и установить код микроконтроллера для хост-процесса Linux. Настройте его второй раз для «процесса Linux»:

```
make menuconfig
```

Затем установите также этот код микроконтроллера:

```
sudo service klipper stop
make flash
sudo service klipper start
```

обратите внимание на "/tmp/klipper_host_mcu" - это будет ваше будущее последовательное устройство для "mcu host", если этот файл не существует - обратитесь к файлу "scripts/klipper-mcu.service", он был установлен предыдущими командами и отвечает за это.

Обратите внимание для "Use case 2" на следующее: когда вы будете определять конфигурацию принтера, вы всегда должны использовать датчики температуры из "mcu host", потому что АЦП не присутствуют в "mcu" по умолчанию (ядра PRU). Примеры конфигурации "sensor_pin" для экструдера и подогреваемого ложа доступны в "generic-cramps.cfg" Вы можете использовать любые другие GPIO непосредственно с "mcu host", ссылаясь на них таким образом "host:gpiochip1/gpio17", но этого следует избегать, поскольку это будет создавать дополнительную нагрузку на основной процессор и, скорее всего, вы не сможете использовать их для управления шаговиками.

## Оставшаяся конфигурация

Завершите установку, настроив Klipper в соответствии с инструкциями в основном документе [Установка](Installation.md#configuring-octoprint-to-use-klipper).

## Печать на Beaglebone

К сожалению, процессор Beaglebone иногда не справляется с работой OctoPrint. Известно, что при сложных отпечатках происходят задержки печати (принтер может двигаться быстрее, чем OctoPrint может отправлять команды перемещения). Если это происходит, воспользуйтесь функцией "virtual_sdcard" (подробности см. в [Config Reference](Config_Reference.md#virtual_sdcard)) для печати непосредственно из Klipper и отключите любые опции протоколирования DEBUG или VERBOSE, если вы их включили.

## Сборка кода микроконтроллера AVR

В этой среде есть все для сборки необходимого кода микроконтроллера, кроме AVR, пакеты AVR были удалены из-за конфликта с пакетами PRU. Если вы все еще хотите собирать код микроконтроллера AVR в этой среде, вам нужно удалить пакеты PRU и установить пакеты AVR, выполнив следующие команды

```
sudo apt-get remove gcc-pru
sudo apt-get install avrdude gcc-avr binutils-avr avr-libc
```

если вам нужно восстановить пакеты PRU, удалите перед этим пакеты ARV

```
sudo apt-get remove avrdude gcc-avr binutils-avr avr-libc
sudo apt-get install gcc-pru
```

## Обозначение выводов аппаратного обеспечения

BeagleBone очень гибкий в плане обозначения выводов, один и тот же вывод может быть настроен на разные функции, но всегда одна функция для одного вывода, одна и та же функция может присутствовать на разных выводах. Таким образом, вы не можете иметь несколько функций на одном выводе или иметь одну и ту же функцию на нескольких выводах. Пример: P9_20 - i2c2_sda/can0_tx/spi1_cs0/gpio0_12/uart1_ctsn P9_19 - i2c2_scl/can0_rx/spi1_cs1/gpio0_13/uart1_rtsn P9_24 - i2c1_scl/can1_rx/gpio0_15/uart1_tx P9_26 - i2c1_sda/can1_tx/gpio0_14/uart1_rx

Назначение выводов определяется с помощью специальных "оверлеев", которые будут загружаться при загрузке linux, они настраиваются путем редактирования файла /boot/uEnv.txt с повышенными правами

```
sudo editor /boot/uEnv.txt
```

и определение функциональности, которую нужно загрузить, например, чтобы включить CAN1, нужно определить для него оверлей

```
uboot_overlay_addr4=/lib/firmware/BB-CAN1-00A0.dtbo
```

Этот оверлей BB-CAN1-00A0.dtbo перенастроит все необходимые контакты для CAN1 и создаст CAN-устройство в Linux. Для применения любых изменений в оверлеях потребуется перезагрузка системы. Если вам нужно понять, какие пины задействованы в том или ином оверлее - вы можете проанализировать исходные файлы в этом месте: /opt/sources/bb.org-overlays/src/arm/ или поискать информацию на форумах BeagleBone.

## Включение аппаратного SPI

BeagleBone обычно имеет несколько аппаратных шин SPI, например, BeagleBone Black может иметь 2 из них, они могут работать до 48Mhz, но обычно они ограничены 16Mhz деревом устройств ядра. По умолчанию в BeagleBone Black некоторые из выводов SPI1 сконфигурированы для вывода HDMI-Audio, чтобы полностью включить 4-проводной SPI1, необходимо отключить HDMI Audio и включить SPI1 Для этого отредактируйте файл /boot/uEnv.txt с повышенными правами

```
sudo editor /boot/uEnv.txt
```

некомментируемая переменная

```
disable_uboot_overlay_audio=1
```

затем отмените переменную и определите ее следующим образом

```
uboot_overlay_addr4=/lib/firmware/BB-SPIDEV1-00A0.dtbo
```

Сохраните изменения в файле /boot/uEnv.txt и перезагрузите плату. Теперь у вас включен SPI1, чтобы проверить его наличие, выполните команду

```
ls /dev/spidev1.*
```

Обратите внимание, что BeagleBone обычно работает на 3,3 В, и для использования 5 В SPI-устройств необходимо добавить микросхему Level-Shifting, например SN74CBTD3861, SN74LVC1G34 или аналогичную. Если вы используете плату CRAMPS - она уже содержит микросхему Level-Shifting, и контакты SPI1 станут доступны на порту P503, и они могут принимать 5В оборудование, проверьте схемы платы CRAMPS на предмет ссылок на контакты.

## Включение аппаратного I2C

BeagleBone обычно имеет несколько аппаратных шин I2C, например, у BeagleBone Black их может быть 3, они поддерживают скорость до 400 Кбит в режиме Fast. По умолчанию в BeagleBone Black их две (i2c-1 и i2c-2), обычно обе уже настроены и присутствуют на P9, третья ic2-0 обычно зарезервирована для внутреннего использования. Если вы используете плату CRAMPS, то i2c-2 присутствует на порту P303 с уровнем 3.3v, если вы хотите получить I2c-1 в плате CRAMPS - вы можете получить их на контактах Extruder1.Step, Extruder1.Dir, они также основаны на 3.3v, проверьте схемы платы CRAMPS для ссылок на контакты. Соответствующие накладки для [Hardware Pin designation](#hardware-pin-designation): I2C1(100Kbit): BB-I2C1-00A0.dtbo I2C1(400Kbit): BB-I2C1-FAST-00A0.dtbo I2C2(100Kbit): BB-I2C2-00A0.dtbo I2C2(400Kbit): BB-I2C2-FAST-00A0.dtbo

## Включение аппаратного UART(Serial)/CAN

BeagleBone имеет до 6 аппаратных шин UART(Serial) (до 3 Мбит) и до 2 аппаратных шин CAN(1 Мбит). UART1(RX,TX) и CAN1(TX,RX) и I2C2(SDA,SCL) используют одни и те же контакты - поэтому вам нужно выбрать, что использовать UART1(CTSN,RTSN) и CAN0(TX,RX) и I2C1(SDA,SCL) используют одни и те же контакты - поэтому вам нужно выбрать, что использовать Все контакты, связанные с UART/CAN, имеют напряжение 3. 3v, поэтому вам нужно использовать чипы/платы трансиверов, такие как SN74LVC2G241DCUR (для UART), SN65HVD230 (для CAN), TTL-RS485 (для RS-485) или что-то подобное, что может преобразовывать сигналы 3.3v в соответствующие уровни.

Связанные накладки, для [Hardware Pin designation](#hardware-pin-designation) CAN0: BB-CAN0-00A0.dtbo CAN1: BB-CAN1-00A0.dtbo UART0: - используется для консоли UART1(RX,TX): BB-UART1-00A0.dtbo UART1(RTS,CTS): BB-UART1-RTSCTS-00A0.dtbo UART2(RX,TX): BB-UART2-00A0.dtbo UART3(RX,TX): BB-UART3-00A0.dtbo UART4(RS-485): BB-UART4-RS485-00A0.dtbo UART5(RX,TX): BB-UART5-00A0.dtbo
