# Сетка стола

Модуль Bed Mesh можно использовать для компенсации неровностей поверхности кровати, чтобы добиться лучшего первого слоя по всей кровати. Следует отметить, что программная коррекция не позволяет достичь идеальных результатов, она может лишь приблизительно повторить форму ложа. Сетка станины также не может компенсировать механические и электрические проблемы. Если ось перекошена или датчик неточен, модуль bed_mesh не получит точных результатов от процесса измерения.

Перед калибровкой сетки необходимо убедиться, что Z-смещение зонда откалибровано. Если для наведения по Z используется концевой упор, его также необходимо откалибровать. Дополнительные сведения см. в разделе [Калибровка зонда](Probe_Calibrate.md) и Z_ENDSTOP_CALIBRATE в разделе [Ручной уровень](Manual_Level.md).

## Основные настройки

### Прямоугольные Кровати

В этом примере предполагается, что принтер имеет прямоугольную станину размером 250 x 220 мм и датчик со смещением по оси x 24 мм и по оси y 5 мм.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
```

- `speed: 120` *Default Value: 50* Скорость, с которой инструмент перемещается между точками.
- `horizontal_move_z: 5` *Default Value: 5* Координата Z, по которой поднимается зонд перед перемещением между точками.
- `mesh_min: 35, 6` *Обязательно* Первая координата зонда, ближайшая к началу координат. Эта координата является относительной по отношению к местоположению зонда.
- `mesh_max: 240, 198` *Обязательно* Самая удаленная от начала координата. Это не обязательно последняя точка, так как процесс зондирования происходит зигзагообразно. Как и в случае с `mesh_min`, эта координата является относительной по отношению к местоположению зонда.
- `probe_count: 5, 3` *Значение по умолчанию: 3, 3* Количество точек для зондирования по каждой оси, заданное как целочисленные значения X, Y. В этом примере по оси X будет прощупано 5 точек, а по оси Y - 3 точки, итого 15 точек. Обратите внимание, что если вам нужна квадратная сетка, например 3x3, это можно указать как одно целое значение, которое будет использоваться для обеих осей, то есть `probe_count: 3`. Обратите внимание, что для сетки требуется минимальное количество зондов (probe_count) по 3 вдоль каждой оси.

На рисунке ниже показано, как опции `mesh_min`, `mesh_max` и `probe_count` используются для генерации точек зондирования. Стрелки указывают направление процедуры зондирования, начиная с точки `mesh_min`. Для примера, когда зонд находится в точке `mesh_min`, сопло будет находиться в точке (11, 1), а когда зонд находится в точке `mesh_max`, сопло будет находиться в точке (206, 193).

![bedmesh_rect_basic](img/bedmesh_rect_basic.svg)

### Круглые лежаки

В этом примере предполагается, что принтер оснащен круглой станиной радиусом 100 мм. Мы будем использовать те же смещения датчиков, что и в прямоугольном примере: 24 мм по оси X и 5 мм по оси Y.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_radius: 75
mesh_origin: 0, 0
round_probe_count: 5
```

- `mesh_radius: 75` *Required* Радиус сетки зонда в мм относительно `mesh_origin`. Обратите внимание, что смещение зонда ограничивает размер радиуса сетки. В данном примере радиус, превышающий 76, выведет инструмент за пределы диапазона принтера.
- `mesh_origin: 0, 0` *Значение по умолчанию: 0, 0* Центральная точка сетки. Эта координата находится относительно местоположения зонда. Хотя по умолчанию используется значение 0, 0, может оказаться полезным изменить начало координат, чтобы прозондировать большую часть кровати. См. иллюстрацию ниже.
- `round_probe_count: 5` *Значение по умолчанию: 5* Это целочисленное значение, определяющее максимальное количество точек, прощупываемых по осям X и Y. Под "максимальным" подразумевается количество точек, прощупываемых вдоль начала сетки. Это значение должно быть нечетным, так как требуется, чтобы центр сетки был прозондирован.

На рисунке ниже показано, как генерируются точки зондирования. Как видите, установка `mesh_origin` в (-10, 0) позволяет нам задать больший радиус сетки - 85.

![bedmesh_round_basic](img/bedmesh_round_basic.svg)

## Расширенная конфигурация

Ниже подробно описаны более сложные варианты конфигурации. Каждый пример основан на базовой конфигурации прямоугольной кровати, показанной выше. Все дополнительные опции аналогичным образом применяются к круглым кроватям.

### Интерполяция сетки

Хотя для определения Z-величин между точками зондирования можно напрямую использовать матрицу зондирования с помощью простой билинейной интерполяции, часто бывает полезно интерполировать дополнительные точки с помощью более сложных алгоритмов интерполяции для увеличения плотности сетки. Эти алгоритмы добавляют кривизну в сетку, пытаясь имитировать свойства материала постели. В Bed Mesh для этого используются алгоритмы интерполяции Лагранжа и бикубической интерполяции.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
mesh_pps: 2, 3
алгоритм: бикубический
bicubic_tension: 0.2
```

- `mesh_pps: 2, 3` *Значение по умолчанию: 2, 2* Параметр `mesh_pps` - это сокращение от Mesh Points Per Segment. Эта опция указывает, сколько точек интерполировать для каждого сегмента по осям X и Y. Считайте, что "сегмент" - это пространство между каждой точкой зондирования. Как и `probe_count`, `mesh_pps` задается как пара целых чисел X, Y, а также может быть задано одно целое число, которое применяется к обеим осям. В данном примере имеется 4 сегмента по оси X и 2 сегмента по оси Y. В результате получается 8 интерполированных точек по оси X, 6 интерполированных точек по оси Y, что дает сетку 13x8. Обратите внимание, что если значение mesh_pps равно 0, то интерполяция сетки отключается и матрица зондирования будет сэмплироваться напрямую.
- `алгоритм: lagrange` *Значение по умолчанию: lagrange* Алгоритм, используемый для интерполяции сетки. Может быть `lagrange` или `bicubic`. Интерполяция Лагранжа ограничена 6 точками зондирования, так как при большем количестве выборок возникают колебания. Бикубическая интерполяция требует минимум 4 точки вдоль каждой оси, если указано менее 4 точек, то выборка по Лагранжу будет принудительной. Если `mesh_pps` установлено в 0, то это значение игнорируется, так как интерполяция сетки не выполняется.
- `bicubic_tension: 0.2` *Значение по умолчанию: 0.2* Если опция `алгоритм` установлена на bicubic, то можно указать значение натяжения. Чем выше натяжение, тем больше наклон интерполируется. Будьте осторожны при настройке этого параметра, так как более высокие значения также создают большую перегрузку, что приведет к тому, что интерполированные значения будут выше или ниже, чем ваши измеренные точки.

На рисунке ниже показано, как перечисленные выше параметры используются для создания интерполированной сетки.

![bedmesh_interpolated](img/bedmesh_interpolated.svg)

### Разделение движений

Bed Mesh работает, перехватывая команды перемещения gcode и применяя трансформацию к их координате Z. Длинные перемещения должны быть разбиты на более мелкие, чтобы правильно следовать форме кровати. Опции ниже управляют поведением разбиения.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
move_check_distance: 5
split_delta_z: .025
```

- `move_check_distance: 5` *Значение по умолчанию: 5* Минимальное расстояние для проверки желаемого изменения Z перед выполнением разбиения. В данном примере алгоритм будет проверять перемещения длиной более 5 мм. Через каждые 5 мм будет выполняться поиск Z сетки, сравнивая его со значением Z предыдущего хода. Если дельта соответствует порогу, заданному параметром `split_delta_z`, ход будет разделен и обход продолжится. Этот процесс повторяется до тех пор, пока не будет достигнут конец перемещения, где будет применена окончательная корректировка. К перемещениям, длина которых меньше `move_check_distance`, правильная корректировка Z применяется непосредственно к перемещению без обхода или разбиения.
- `split_delta_z: .025` *Значение по умолчанию: .025* Как упоминалось выше, это минимальное отклонение, необходимое для запуска разделения движения. В данном примере любое значение Z с отклонением +/- .025 мм вызовет сплит.

Как правило, значений по умолчанию для этих параметров достаточно, а значение по умолчанию 5 мм для `move_check_distance` может оказаться излишним. Однако опытный пользователь может захотеть поэкспериментировать с этими параметрами, пытаясь выжать оптимальный первый слой.

### Сетчатый оттенок

Когда включено "затухание", регулировка Z постепенно уменьшается на расстояние, определенное конфигурацией. Это достигается путем применения небольших корректировок высоты слоя, которые либо увеличиваются, либо уменьшаются в зависимости от формы ложа. По окончании затухания регулировка Z больше не применяется, что позволяет верхней части отпечатка быть плоской, а не зеркально отражать форму ложа. Затухание также может иметь некоторые нежелательные свойства: если затухать слишком быстро, это может привести к появлению видимых артефактов на отпечатке. Кроме того, если ваша кровать сильно деформирована, затухание может уменьшить или растянуть высоту Z отпечатка. Поэтому по умолчанию затухание отключено.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
fade_start: 1
fade_end: 10
fade_target: 0
```

- `fade_start: 1` *Значение по умолчанию: 1* Высота Z, с которой следует начинать постепенное выравнивание. Перед началом процесса затухания рекомендуется спустить несколько слоев.
- `fade_end: 10` *Значение по умолчанию: 0* Высота Z, на которой должно завершиться затухание. Если это значение меньше, чем `fade_start`, то затухание будет отключено. Это значение может быть изменено в зависимости от того, насколько деформирована поверхность печати. Сильно деформированная поверхность должна затухать на большем расстоянии. На почти плоской поверхности это значение можно уменьшить, чтобы затухание происходило быстрее. 10 мм - разумное значение для начала, если использовать значение по умолчанию 1 для `fade_start`.
- `fade_target: 0` *Значение по умолчанию: Среднее значение Z сетки* Значение `fade_target` можно рассматривать как дополнительное смещение Z, применяемое ко всему слою после завершения затухания. Вообще говоря, мы хотели бы, чтобы это значение было равно 0, однако есть обстоятельства, при которых оно не должно быть таким. Например, предположим, что ваше положение самонаведения на кровати - это выброс, оно на 0,2 мм ниже, чем средняя измеренная высота кровати. Если `fade_target` равно 0, fade уменьшит отпечаток в среднем на .2 мм по всей станине. Если задать `fade_target` равным .2, то область, в которую попадает отпечаток, расширится на .2 мм, однако остальная часть ложа будет иметь точные размеры. Обычно рекомендуется не задавать `fade_target` в конфигурации, чтобы использовалась средняя высота сетки, однако может быть желательно вручную настроить цель затухания, если требуется печать на определенной части ложа.

### Настройка нулевого опорного положения

Many probes are susceptible to "drift", ie: inaccuracies in probing introduced by heat or interference. This can make calculating the probe's z-offset challenging, particularly at different bed temperatures. As such, some printers use an endstop for homing the Z axis and a probe for calibrating the mesh. In this configuration it is possible offset the mesh so that the (X, Y) `reference position` applies zero adjustment. The `reference postion` should be the location on the bed where a [Z_ENDSTOP_CALIBRATE](./Manual_Level.md#calibrating-a-z-endstop) paper test is performed. The bed_mesh module provides the `zero_reference_position` option for specifying this coordinate:

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
zero_reference_position: 125, 110
probe_count: 5, 3
```

- `zero_reference_position: ` *Значение по умолчанию: None (отключено)* Функция `zero_reference_position` ожидает координату (X, Y), совпадающую с координатой `reference position`, описанной выше. Если координата находится внутри сетки, то сетка будет смещена, так что к опорной позиции будет применена нулевая корректировка. Если координата лежит вне сетки, то она будет измерена после калибровки, а полученное значение z будет использовано в качестве z-смещения. Обратите внимание, что эта координата НЕ должна находиться в месте, указанном как `faulty_region`, если необходимо выполнить зондирование.

#### Устаревший индекс relative_reference_index

Существующие конфигурации, использующие опцию `relative_reference_index`, должны быть обновлены для использования `zero_reference_position`. Ответ на команду [BED_MESH_OUTPUT PGP=1](#output) gcode будет включать координату (X, Y), связанную с индексом; эта позиция может быть использована в качестве значения для `нулевой позиции_ссылки`. Вывод будет выглядеть следующим образом:

```
// bed_mesh: сгенерированные точки
// Индекс | Настроенный инструмент | Зонд
// 0 | (1.0, 1.0) | (24.0, 6.0)
// 1 | (36.7, 1.0) | (59.7, 6.0)
// 2 | (72.3, 1.0) | (95.3, 6.0)
// 3 | (108.0, 1.0) | (131.0, 6.0)
... (дополнительные сгенерированные точки)
// bed_mesh: relative_reference_index 24 is (131.5, 108.0)
```

*Примечание: Вышеприведенный вывод также выводится в `klippy.log` во время инициализации.*

На примере выше мы видим, что `относительный_индекс_ссылки` выводится вместе с его координатой. Таким образом, `нулевая_позиция_ссылки` равна `131.5, 108`.

### Неисправные регионы

Некоторые участки кровати могут показывать неточные результаты при зондировании из-за "неисправности" в определенных местах. Лучшим примером этого являются кровати с рядом встроенных магнитов, используемых для удержания съемных стальных листов. Магнитное поле на этих магнитах и вокруг них может заставить индуктивный датчик сработать на расстоянии выше или ниже, чем в противном случае, что приведет к получению сетки, которая неточно отображает поверхность в этих местах. **Примечание: Не следует путать это со смещением местоположения датчика, которое приводит к неточным результатам по всему слою**

Опции `faulty_region` могут быть настроены для компенсации этого влияния. Если сгенерированная точка находится в неисправной области, сетка попытается прощупать до 4 точек на границах этой области. Эти значения будут усреднены и вставлены в сетку как значение Z в сгенерированной координате (X, Y).

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
faulty_region_1_min: 130.0, 0.0
faulty_region_1_max: 145.0, 40.0
faulty_region_2_min: 225.0, 0.0
faulty_region_2_max: 250.0, 25.0
faulty_region_3_min: 165.0, 95.0
faulty_region_3_max: 205.0, 110.0
faulty_region_4_min: 30.0, 170.0
faulty_region_4_max: 45.0, 210.0
```

- `faulty_region_{1...99}_min` `faulty_region_{1..99}_max` *Значение по умолчанию: None (отключено)* Дефектные регионы определяются аналогично сетке, где для каждого региона должны быть указаны минимальные и максимальные координаты (X, Y). Неисправный регион может выходить за пределы сетки, однако генерируемые альтернативные точки всегда будут находиться в границах сетки. Два региона не могут пересекаться.

На изображении ниже показано, как генерируются точки замены, если сгенерированная точка находится в неисправном регионе. Показанные области соответствуют областям в приведенном выше примере конфигурации. Точки замены и их координаты выделены зеленым цветом.

![bedmesh_interpolated](img/bedmesh_faulty_regions.svg)

### Адаптивные сетки

Адаптивное зацепление станины - это способ ускорить генерацию сетки станины, используя только область станины, занятую печатаемыми объектами. При использовании этого метода параметры сетки автоматически настраиваются в зависимости от площади, занимаемой заданными объектами печати.

Адаптированная область сетки будет вычислена из области, определенной границами всех определенных объектов печати, так что она охватывает все объекты, включая любые поля, определенные в конфигурации. После вычисления области количество точек зондирования будет уменьшено на основе соотношения площади сетки по умолчанию и адаптированной площади сетки. Для иллюстрации этого рассмотрим следующий пример:

Для кровати 150x150 мм с `mesh_min`, установленной на `25,25`, и `mesh_max`, установленной на `125,125`, площадь сетки по умолчанию составляет квадрат 100 ммx100 мм. Адаптированная площадь сетки `50,50` означает соотношение `0,5x0,5` между адаптированной площадью и площадью сетки по умолчанию.

Если в конфигурации `bed_mesh` указано `probe_count` как `7x7`, то адаптированная сетка кровати будет использовать 4x4 точки зондирования (7 * 0.5 с округлением вверх).

![adaptive_bedmesh](img/adaptive_bed_mesh.svg)

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5, 3
adaptive_margin: 5
```

- `adaptive_margin` *Значение по умолчанию: 0* Граница (в мм) для добавления вокруг области кровати, используемой определенными объектами. На рисунке ниже показана адаптированная область сетки кровати с `adaptive_margin` в 5 мм. Адаптированная площадь сетки (площадь, выделенная зеленым цветом) рассчитывается как используемая площадь ложа (площадь, выделенная синим цветом) плюс определенная маржа.

   ![adaptive_bedmesh_margin](img/adaptive_bed_mesh_margin.svg)

По своей природе адаптивные сетки печатной основы используют объекты, определенные файлом Gcode, на котором выполняется печать. Поэтому ожидается, что каждый Gcode-файл будет генерировать сетку, которая будет охватывать разные области печатного слоя. Поэтому адаптированные сетки станины не следует использовать повторно. При использовании адаптивного зацепления предполагается, что для каждой печати будет создаваться новая сетка.

Также важно учитывать, что адаптивное зацепление ложа лучше всего использовать на машинах, которые могут нормально прощупать все ложе и достичь максимального отклонения менее или равного 1 высоте слоя. Машины с механическими проблемами, которые обычно компенсируются полной сеткой станины, могут получить нежелательные результаты при попытке перемещения печати **за пределами** зоны зондирования. Если полная сетка кровати имеет дисперсию более 1 высоты слоя, необходимо соблюдать осторожность при использовании адаптивных сеток кровати и попытках перемещения печати за пределы зоны сетки.

## Сканирование поверхности

Некоторые датчики, например [Eddy Current Probe](./Eddy_Probe.md), способны "сканировать" поверхность станины. То есть эти зонды могут брать пробы сетки, не поднимая инструмент между пробами. Чтобы активировать режим сканирования, в gcode-команде `BED_MESH_CALIBRATE` следует передать параметр зонда `METHOD=scan` или `METHOD=rapid_scan`.

### Высота сканирования

Высота сканирования задается параметром `horizontal_move_z` в `[bed_mesh]`. Кроме того, она может быть задана командой gcode `BED_MESH_CALIBRATE` через параметр `HORIZONTAL_MOVE_Z`.

Высота сканирования должна быть достаточно низкой, чтобы избежать ошибок сканирования. Обычно высота в 2 мм (т.е. `HORIZONTAL_MOVE_Z=2`) должна работать хорошо, при условии, что датчик установлен правильно.

Следует отметить, что если зонд находится на высоте более 4 мм от поверхности, результаты будут недействительными. Таким образом, сканирование невозможно на кроватях с сильным отклонением поверхности или на кроватях с сильным наклоном, который не был исправлен.

### Быстрое (непрерывное) сканирование

При выполнении `быстрого_сканирования` следует учитывать, что результаты будут иметь некоторую погрешность. Эта погрешность должна быть достаточно низкой, чтобы быть полезной для больших областей печати с достаточно большой высотой слоя. Некоторые датчики могут быть более склонны к ошибкам, чем другие.

Не рекомендуется использовать быстрый режим для сканирования "плотной" сетки. Часть ошибки, вносимой при быстром сканировании, может быть гауссовым шумом от датчика, и плотная сетка будет отражать этот шум (т. е. будут пики и долины).

Bed Mesh попытается оптимизировать траекторию движения, чтобы обеспечить наилучший результат в зависимости от конфигурации. Это включает в себя избегание дефектных областей при сборе образцов и "проскакивание" сетки при изменении направления. Такой пролет улучшает отбор проб на краях сетки, однако для этого необходимо, чтобы сетка была настроена таким образом, чтобы инструмент мог перемещаться за ее пределы.

```
[bed_mesh]
скорость: 120
horizontal_move_z: 5
mesh_min: 35, 6
mesh_max: 240, 198
probe_count: 5
scan_overshoot: 8
```

- `scan_overshoot` *Значение по умолчанию: 0 (отключено)* Максимальная величина перемещения (в мм), доступная за пределами сетки. Для прямоугольных станин это значение относится к перемещению по оси X, а для круглых станин - по всему радиусу. Инструмент должен иметь возможность перемещаться на указанную величину за пределами сетки. Это значение используется для оптимизации траектории движения при выполнении "быстрого сканирования". Минимальное значение, которое может быть указано, - 1. По умолчанию проскакивание отсутствует.

Если не настроено превышение сканирования, то оптимизация траектории движения не будет применяться при изменении направления.

## Кроватная сетка Gcodes

### Калибровка

`BED_MESH_CALIBRATE PROFILE=<имя> METHOD=[ ручное | автоматическое | сканирование | rapid_scan] \ [<probe_parameter>=<значение>] [<mesh_parameter>=<значение>] [ADAPTIVE=[0|1] \ [ADAPTIVE_MARGIN=<значение>]` * Профиль по умолчанию: по умолчанию* * Метод по умолчанию: автоматический, если обнаружен зонд, иначе ручной* * Адаптивный по умолчанию: 0* * Адаптивный маржа по умолчанию: 0*

Запускает процедуру зондирования для калибровки сетки кровати.

Сетка будет сохранена в профиль, указанный параметром `ПРОФИЛЬ`, или `по умолчанию`, если он не указан. Параметр `МЕТОД` принимает одно из следующих значений:

- `METHOD=manual`: включает ручное зондирование с помощью насадки и бумажного теста
- `METHOD=автоматический`: Автоматическое (стандартное) зондирование. Используется по умолчанию.
- `METHOD=scan`: Включает сканирование поверхности. Инструмент будет останавливаться на каждой позиции, чтобы собрать образец.
- `METHOD=rapid_scan`: Включает непрерывное сканирование поверхности.

Позиции XY автоматически корректируются с учетом смещений X и/или Y, если выбран метод зондирования, отличный от `ручного`.

Можно задать параметры сетки, чтобы изменить зондируемую область. Доступны следующие параметры:

- Прямоугольные кровати (картезианские):
   - `MESH_MIN`
   - `MESH_MAX`
   - `PROBE_COUNT`
- Круглые кровати (дельта):
   - `MESH_RADIUS`
   - `MESH_ORIGIN`
   - `ROUND_PROBE_COUNT`
- Все кровати:
   - `MESH_PPS`
   - `АЛГОРИТМ`
   - `АДАПТИВНОСТЬ`
   - `ADAPTIVE_MARGIN`

Подробную информацию о том, как каждый параметр применяется к сетке, смотрите в документации по конфигурации выше.

### Профили

`BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name>`

После выполнения BED_MESH_CALIBRATE можно сохранить текущее состояние сетки в именованном профиле. Это позволяет загрузить сетку без повторного зондирования кровати. После сохранения профиля с помощью команды `BED_MESH_PROFILE SAVE=<имя>` может быть выполнен код `SAVE_CONFIG` для записи профиля в файл printer.cfg.

Профили можно загрузить, выполнив команду `BED_MESH_PROFILE LOAD=<имя>`.

Следует отметить, что каждый раз, когда происходит BED_MESH_CALIBRATE, текущее состояние автоматически сохраняется в профиль *по умолчанию*. Профиль *по умолчанию* можно удалить следующим образом:

`BED_MESH_PROFILE REMOVE=по умолчанию`

Любой другой сохраненный профиль можно удалить таким же образом, заменив * по умолчанию* на именованный профиль, который вы хотите удалить.

#### Загрузка профиля по умолчанию

Предыдущие версии `bed_mesh` при запуске всегда загружали профиль с именем *default*, если он присутствовал. Это поведение было удалено в пользу того, чтобы позволить пользователю определять, когда загружать профиль. Если пользователь хочет загружать профиль `default`, рекомендуется добавить `BED_MESH_PROFILE LOAD=default` либо в макрос `START_PRINT`, либо в конфигурацию "Start G-Code" слайсера, в зависимости от того, что применимо.

В качестве альтернативы можно восстановить старое поведение загрузки профиля при запуске с помощью `[delayed_gcode]`:

```ini
[delayed_gcode bed_mesh_init]
initial_duration: .01
gcode:
  BED_MESH_PROFILE LOAD=default
```

### Выход

`BED_MESH_OUTPUT PGP=[0 | 1]`

Выводит текущее состояние сетки на терминал. Обратите внимание, что сама сетка выводится

Параметр PGP - это сокращение от "Print Generated Points". Если задано `PGP=1`, сгенерированные точки зондирования будут выводиться на терминал:

```
// bed_mesh: сгенерированные точки
// Index | Tool Adjusted | Probe
// 0 | (11.0, 1.0) | (35.0, 6.0)
// 1 | (62.2, 1.0) | (86.2, 6.0)
// 2 | (113.5, 1.0) | (137.5, 6.0)
// 3 | (164.8, 1.0) | (188.8, 6.0)
// 4 | (216.0, 1.0) | (240.0, 6.0)
// 5 | (216.0, 97.0) | (240.0, 102.0)
// 6 | (164.8, 97.0) | (188.8, 102.0)
// 7 | (113.5, 97.0) | (137.5, 102.0)
// 8 | (62.2, 97.0) | (86.2, 102.0)
// 9 | (11.0, 97.0) | (35.0, 102.0)
// 10 | (11.0, 193.0) | (35.0, 198.0)
// 11 | (62.2, 193.0) | (86.2, 198.0)
// 12 | (113.5, 193.0) | (137.5, 198.0)
// 13 | (164.8, 193.0) | (188.8, 198.0)
// 14 | (216.0, 193.0) | (240.0, 198.0)
```

Точки "Инструмент настроен" относятся к местоположению сопла для каждой точки, а точки "Зонд" - к местоположению зонда. Обратите внимание, что при ручном зондировании точки " Зонд" будут относиться как к месту расположения инструмента, так и к месту расположения сопла.

### Очистить состояние сетки

`BED_MESH_CLEAR`

Этот код можно использовать для очистки внутреннего состояния сетки.

### Применить смещение по оси X/Y

`BED_MESH_OFFSET [X=<значение>] [Y=<значение>] [ZFADE=<значение>]`

Это полезно для принтеров с несколькими независимыми экструдерами, поскольку смещение необходимо для правильной регулировки Z после смены инструмента. Смещение следует указывать относительно первичного экструдера. То есть положительное смещение по X должно быть указано, если вторичный экструдер установлен справа от первичного, положительное смещение по Y должно быть указано, если вторичный экструдер установлен "позади" первичного, и положительное смещение по ZFADE должно быть указано, если сопло вторичного экструдера находится над соплом первичного экструдера.

Обратите внимание, что смещение ZFADE *НЕ* непосредственно применяет дополнительную корректировку. Оно предназначено для компенсации `смещения gcode` при включении [mesh fade](#mesh-fade). Например, если вторичный экструдер расположен выше основного и ему требуется отрицательное смещение gcode, т.е. `SET_GCODE_OFFSET Z=-.2`, это может быть учтено в `bed_mesh` с `BED_MESH_OFFSET ZFADE=.2`.

## API-интерфейсы Bed Mesh Webhooks

### Выгрузка данных о сетке

`{" идентификатор": 123, "метод": "bed_mesh/dump_mesh"}`.

Dumps the configuration and state for the current mesh and all saved profiles.

The `dump_mesh` endpoint takes one optional parameter, `mesh_args`. This parameter must be an object, where the keys and values are parameters available to [BED_MESH_CALIBRATE](#bed_mesh_calibrate). This will update the mesh configuration and probe points using the supplied parameters prior to returning the result. It is recommended to omit mesh parameters unless it is desired to visualize the probe points and/or travel path before performing `BED_MESH_CALIBRATE`.

## Визуализация и анализ

Большинство пользователей, скорее всего, сочтут, что визуализаторов, входящих в состав таких приложений, как Mainsail, Fluidd и Octoprint, достаточно для базового анализа. Однако в папке scripts Klipper находится скрипт `graph_mesh.py`, который можно использовать для дополнительной визуализации и более детального анализа, особенно полезного для отладки оборудования или результатов, полученных с помощью `bed_mesh`:

```
Использование: graph_mesh.py [-h] {list,plot,analyze,dump} ...

График данных сетки кровати

позиционные аргументы:
  {list,plot,analyze,dump}
    list Список доступных типов графиков
    plot Построить график указанного типа
    analyze Выполнить анализ данных сетки
    dump Выгрузить ответ API в json-файл

опции:
  -h, --help Показать сообщение о помощи и выйти
```

### Пререквизиты

Как и большинство инструментов для построения графиков, предоставляемых Klipper, `graph_mesh.py` требует python-зависимости `matplotlib` и `numpy`. Кроме того, для подключения к Klipper через веб-сокет Moonraker требуется python-зависимость `websockets`. Хотя все визуализации могут быть выведены в файл `svg, большинство визуализаций, предлагаемых `graph_mesh.py`, лучше просматривать в режиме живого просмотра на настольном компьютере. Например, 3D-визуализации можно поворачивать и масштабировать в режиме предварительного просмотра, а визуализации путей могут быть анимированы в режиме предварительного просмотра.

### Построение графика данных сетки

Инструмент `graph_mesh.py` может строить несколько типов визуализаций. Доступные типы можно посмотреть, выполнив команду `graph_mesh.py list`:

```
graph_mesh.py list
точки     Построить исходные сгенерированные точки
path       Построить траекторию движения зонда
rapid      Построить путь быстрого сканирования
probedz    Построить значения Z зонда
meshz      Построить значения Z сетки
Наложение    Изображает текущую сетку, наложенную на профиль
delta      Показывает дельту между текущей зондированной сеткой и профилем
```

При построении визуализаций доступно несколько вариантов:

```
использование: graph_mesh.py plot [-h] [-a] [-s] [-p PROFILE_NAME] [-o OUTPUT] <тип графика> <вход>

позиционные аргументы:
  <plot type> Тип данных для построения графика
  <input> Path/url к Klipper Socket или путь к json-файлу

опции:
  -h, --help показать это справочное сообщение и выйти
  -a, --анимировать Анимировать пути в живом предварительном просмотре
  -s, --scale-plot Использовать пределы осей, сообщаемые Klipper, для масштабирования графика X/Y
  -p PROFILE_NAME, --profile-name PROFILE_NAME
                        Опциональное имя профиля для построения графика для 'probedz'
  -o OUTPUT, --output OUTPUT
                        Output file path
```

Ниже приведено описание каждого аргумента:

- `Тип участка`: Необходимый позиционный аргумент, указывающий тип генерируемой визуализации. Должен быть одним из типов, выводимых командой `graph_mesh.py list`.
- `ввод`: Обязательный позиционный аргумент, содержащий путь или url к источнику входных данных. Это должно быть одно из следующих значений:
   - Путь к Unix-доменному сокету Клиппера
   - url на экземпляр Moonraker
   - Путь к json-файлу, создаваемому командой `graph_mesh.py dump <input>`
- `-a`: Необязательная анимация для типов визуализации `путь` и `скорость`. Анимация применяется только для живого предварительного просмотра.
- `-s`: Опционально масштабирует график, используя значения `axis_minimum` и `axis_maximum`, сообщенные объектом Klipper `toolhead` при создании файла дампа.
- `-p`: Имя профиля, которое может быть указано при генерации 3D-визуализации сетки `probedz`. При генерации визуализации `overlay` или `delta` этот аргумент должен быть указан.
- `-o`: Необязательный путь к файлу, указывающий, что скрипт должен сохранить визуализацию в этом месте, а не запускать в режиме предварительного просмотра. Изображения сохраняются в формате `svg`.

Например, чтобы построить анимированный быстрый путь, подключившись через unix-сокет Klipper:

```
graph_mesh.py plot -a rapid ~/printer_data/comms/klippy.sock
```

Или постройте 3d-визуализацию сетки, подключившись через Moonraker:

```
graph_mesh.py plot meshz http://my-printer.local
```

### Анализ сетки кровати

Инструмент `graph_mesh.py` также может быть использован для анализа данных, предоставляемых API [bed_mesh/dump_mesh](#dumping-mesh-data):

```
graph_mesh.py analyze <input>
```

Как и в команде `plot`, `<input>` должен представлять собой путь к unix-сокету Klipper, URL-адрес экземпляра Moonraker или путь к json-файлу, сгенерированному командой dump.

Для начала анализ выполнит различные проверки точек и траекторий зондов, сгенерированных `bed_mesh` во время создания дампа. К ним относятся следующие:

- Количество точек зондирования, созданных без каких-либо дополнений
- Количество сгенерированных точек зонда, включая любые точки, сгенерированные в результате неисправных областей и/или сконфигурированного нулевого опорного положения.
- Количество точек зондирования, создаваемых при выполнении быстрого сканирования.
- Общее количество ходов, созданных для быстрого сканирования.
- Проверка того, что точки зондирования, созданные для быстрого сканирования, идентичны точкам зондирования, созданным для стандартной процедуры зондирования.
- Проверка "обратного хода" как для стандартной траектории зондирования, так и для траектории быстрого сканирования. Обратный ход можно определить как перемещение в одну и ту же позицию более одного раза во время процедуры зондирования. Обратный путь никогда не должен возникать во время стандартного зондирования. Неисправные области *могут* привести к отступлению во время быстрого сканирования в попытке избежать попадания в неисправную область при приближении или удалении от места зондирования, однако в противном случае этого не должно происходить.

Далее анализируется каждая зондируемая сетка, присутствующая в дампе, начиная с сетки, загруженной во время дампа (если она присутствует), и затем все сохраненные профили. Извлекаются следующие данные:

- Форма сетки (минимальное количество зондов X,Y, максимальное количество зондов X,Y)
- Диапазон Z сетки, (минимальный Z, максимальный Z)
- Среднее значение Z в сетке
- Стандартное отклонение значений Z в сетке

Кроме того, между сетками одинаковой формы проводится дельта-анализ, который дает следующие результаты:

- Диапазон дельты между сетками (минимум и максимум)
- Средняя дельта
- Стандартное отклонение дельты
- Абсолютная максимальная разница
- Среднее абсолютное значение

### Сохраните данные сетки в файл

Команда `dump` может быть использована для сохранения ответа в файл, который можно использовать для анализа при устранении неполадок:

```
graph_mesh.py dump -o <output file name> <input>
```

Параметр `<input>` должен представлять собой путь к unix-сокету Klipper или URL-адрес экземпляра Moonraker. Опция `-o` может быть использована для указания пути к выходному файлу. Если опция опущена, файл будет сохранен в рабочем каталоге с именем в следующем формате:

`klipper-bedmesh-{year}{month}{day}{hour}{minute}{second}.json`
