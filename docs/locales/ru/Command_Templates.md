# Шаблоны команд

Этот документ предоставляет информацию о реализации последовательностей команд G-Code в разделах конфигурации gcode_macro (и аналогичных).

## Названия макросов G-Кода

Регистр не важен для имени макроса G-Code - MY_MACRO и my_macro будут вычисляться одинаково и могут вызываться как в верхнем, так и в нижнем регистре. Если в имени макроса используются какие-либо числа, то все они должны быть в конце имени (например, TEST_MACRO25 является допустимым, но MACRO25_TEST3 - нет).

## Форматирование G-кода в конфигурации

Отступы важны при определении макроса в конфигурационном файле. Чтобы указать многострочную последовательность G-кода, важно, чтобы каждая строка имела правильный отступ. Например:

```
[gcode_macro blink_led]
gcode:
  SET_PIN PIN=my_led VALUE=1
  G4 P2000
  SET_PIN PIN=my_led VALUE=0
```

Обратите внимание, что опция конфигурации `gcode:` всегда начинается с начала строки, а последующие строки в макросе G-Code никогда не начинаются с начала.

## Добавьте описание своему макросу

Чтобы помочь идентифицировать функциональность, можно добавить краткое описание. Добавьте `description:` с коротким текстом для описания функциональности. По умолчанию это "макрос G-кода", если не указано. Например:

```
[gcode_macro blink_led]
описание: Blink my_led one time
gcode:
  SET_PIN PIN=my_led VALUE=1
  G4 P2000
  SET_PIN PIN=my_led VALUE=0
```

Терминал отобразит описание, когда вы воспользуетесь командой `HELP` или функцией автозаполнения.

## Сохранение/восстановление состояния для перемещений G-кода

К сожалению, командный язык G-Code может оказаться сложным в использовании. Стандартным механизмом перемещения инструментальной головки является команда `G1` (команда `G0` является псевдонимом для `G1` и может использоваться как взаимозаменяемая с ней). Однако эта команда опирается на "состояние разбора G-кода", установленное командами `M82`, `M83`, `G90`, `G91`, `G92` и предыдущими командами `G1`. При создании макроса G-кода целесообразно всегда явно устанавливать состояние разбора G-кода перед подачей команды `G1`. (В противном случае есть риск, что команда `G1` выполнит нежелательный запрос)

Обычный способ добиться этого - обернуть движения `G1` в `SAVE_GCODE_STATE`, `G91` и `RESTORE_GCODE_STATE`. Например:

```
[gcode_macro MOVE_UP]
gcode:
  SAVE_GCODE_STATE NAME=my_move_up_state
  G91
  G1 Z10 F300
  RESTORE_GCODE_STATE NAME=my_move_up_state
```

Команда `G91` переводит состояние разбора G-кода в "режим относительного перемещения", а команда `RESTORE_GCODE_STATE` восстанавливает состояние до того, каким оно было до ввода макроса. Обязательно укажите явную скорость (через параметр `F`) в первой команде `G1`.

## Расширение шаблона

Конфигурационная секция gcode_macro `gcode:` оценивается с помощью шаблонного языка Jinja2. Можно оценивать выражения во время выполнения, обернув их в символы `{ }`, или использовать условные операторы, обернутые в `{% %}`. Более подробную информацию о синтаксисе см. в [документации Jinja2](http://jinja.pocoo.org/docs/2.10/templates/).

Пример сложного макроса:

```
[gcode_macro cleanan_nozzle]
gcode:
  {% set wipe_count = 8 %}
  SAVE_GCODE_STATE NAME=clean_nozzle_state
  G90
  G0 Z15 F300
  {% for wipe in range(wipe_count) %}
    {% for coordinate in [(275, 4),(235, 4)] %}
      G0 X{координата[0]} Y{координата[1] + 0.25 * wipe} Z9.7 F12000
    {% endfor %}
  {% endfor %}
  RESTORE_GCODE_STATE NAME=clean_nozzle_state
```

### Макропараметры

Часто бывает полезно проверить параметры, передаваемые макросу при его вызове. Эти параметры доступны через псевдопеременную `params`. Например, если макрос:

```
[gcode_macro SET_PERCENT]
gcode:
  M117 Теперь при { params.VALUE|float * 100 }%
```

если бы он был вызван как `SET_PERCENT VALUE=.2`, то его значение было бы равно `M117 Теперь на 20%`. Обратите внимание, что имена параметров всегда пишутся в верхнем регистре при оценке в макросе и всегда передаются как строки. При выполнении математических операций они должны быть явно преобразованы в целые числа или плавающие.

Обычно в Jinja2 используется директива `set`, чтобы использовать параметр по умолчанию и присвоить результат локальному имени. Например:

```
[gcode_macro SET_BED_TEMPERATURE]
gcode:
  {% set bed_temp = params.TEMPERATURE|default(40)|float %}
  M140 S{bed_temp}
```

### Переменная "rawparams"

Доступ к полным непарсированным параметрам запущенного макроса можно получить через псевдопеременную `rawparams`.

Обратите внимание, что при этом будут включены все комментарии, которые были частью исходной команды.

Смотрите файл [sample-macros.cfg](../config/sample-macros.cfg) для примера, показывающего, как переопределить команду `M117` с помощью `rawparams`.

### Переменная "принтер"

Через псевдопеременную `printer` можно проверять (и изменять) текущее состояние принтера. Например:

```
[gcode_macro slow_fan]
gcode:
  M106 S{ printer.fan.speed * 0.9 * 255}
```

Доступные поля определены в документе [Справочник состояния](Status_Reference.md).

Важно! Макросы сначала оцениваются целиком, и только потом выполняются полученные команды. Если макрос выдает команду, которая изменяет состояние принтера, результаты изменения состояния не будут видны во время оценки макроса. Это также может привести к нечеткому поведению, когда макрос генерирует команды, вызывающие другие макросы, поскольку вызываемый макрос оценивается при его вызове (то есть после полной оценки вызывающего макроса).

По соглашению, имя, следующее сразу за `printer`, является именем секции конфигурации. Так, например, `printer.fan` ссылается на объект fan, созданный секцией конфигурации `[fan]`. Из этого правила есть некоторые исключения - в частности, объекты `gcode_move` и `toolhead`. Если секция конфигурации содержит пробелы, то доступ к ней можно получить через аксессор `[ ]` - например: `printer["generic_heater my_chamber_heater"].temperature`.

Обратите внимание, что директива Jinja2 `set` может присваивать локальное имя объекту в иерархии `принтер`. Это может сделать макросы более читабельными и сократить количество вводимых символов. Например:

```
[gcode_macro QUERY_HTU21D]
gcode:
    {% set sensor = printer["htu21d my_sensor"] %}
    M117 Temp:{sensor.temperature} Humidity:{sensor.humidity}
```

## Действия

Есть несколько команд, которые могут изменять состояние принтера. Например, `{ action_emergency_stop() }` приведет к тому, что принтер перейдет в состояние выключения. Обратите внимание, что эти действия выполняются в момент оценки макроса, что может занять значительное время до выполнения сгенерированных команд g-кода.

Доступные команды "действия":

- `action_respond_info(msg)`: Записывает заданное `msg` в псевдотерминал /tmp/printer. Каждая строка `msg` будет отправлена с префиксом "//".
- `action_raise_error(msg)`: Прерывает текущий макрос (и все вызывающие макросы) и записывает заданное `msg` в псевдотерминал /tmp/printer. Первая строка `msg` будет отправлена с префиксом "!!! ", а последующие строки - с префиксом "//".
- `action_emergency_stop(msg)`: Переводит принтер в состояние выключения. Параметр `msg` необязателен, он может быть полезен для описания причины выключения.
- `action_call_remote_method(method_name)`: Вызывает метод, зарегистрированный удаленным клиентом. Если метод принимает параметры, они должны быть предоставлены через ключевые аргументы, т.е.: `action_call_remote_method("print_stuff", my_arg="hello_world")`

## Переменные

Команда SET_GCODE_VARIABLE может быть полезна для сохранения состояния между вызовами макросов. Имена переменных не должны содержать символов верхнего регистра. Например:

```
[gcode_macro start_probe]
variable_bed_temp: 0
gcode:
  # Сохранить целевую температуру в переменной bed_temp
  SET_GCODE_VARIABLE MACRO=start_probe VARIABLE=bed_temp VALUE={printer.heater_bed.target}
  # Отключить нагреватель кровати
  M140
  # Выполнить зондирование
  PROBE
  # Вызов макроса finish_probe по завершении зондирования
  finish_probe
[gcode_macro finish_probe]
gcode:
  # Восстановление температуры
  M140 S{printer["gcode_macro start_probe"].bed_temp}
```

При использовании SET_GCODE_VARIABLE обязательно учитывайте время выполнения макроса и команды.

## Задержанные G-коды

Опция конфигурации [delayed_gcode] может использоваться для выполнения последовательности gcode с задержкой:

```
[delayed_gcode clear_display]
gcode:
  M117

[gcode_macro load_filament]
gcode:
 G91
 G1 E50
 G90
 M400
 Загрузка M117 завершена!
 UPDATE_DELAYED_GCODE ID=clear_display DURATION=10
```

При выполнении макроса `load_filament` на экране появится сообщение "Load Complete!" после завершения экструзии. Последняя строка gcode включает отложенный_gcode "clear_display", настроенный на выполнение через 10 секунд.

Опция конфигурации `initial_duration` может быть установлена для выполнения delayed_gcode при запуске принтера. Отсчет времени начинается, когда принтер переходит в состояние "готов". Например, приведенный ниже код delayed_gcode будет выполнен через 5 секунд после готовности принтера, инициализируя дисплей сообщением " Добро пожаловать!":

```
[delayed_gcode welcome]
initial_duration: 5.
gcode:
    M117 Добро пожаловать!
```

Отложенный gcode может повториться, обновившись в опции gcode:

```
[delayed_gcode report_temp]
initial_duration: 2.
gcode:
  {action_respond_info("Extruder Temp: %.1f" % (printer.extruder0.temperature))}
  UPDATE_DELAYED_GCODE ID=report_temp DURATION=2
```

Приведенный выше код delayed_gcode будет отправлять Octoprint сообщение "// Extruder Temp: [ex0_temp]" каждые 2 секунды. Это можно отменить с помощью следующего gcode:

```
UPDATE_DELAYED_GCODE ID=report_temp DURATION=0
```

## Шаблоны меню

Если включен раздел конфигурации [дисплей](Config_Reference.md#display)], то можно настроить меню с помощью разделов конфигурации [меню](Config_Reference.md#menu).

В шаблонах меню доступны следующие атрибуты, доступные только для чтения:

* `menu.width` - ширина элемента (количество отображаемых колонок)
* `menu.ns` - пространство имен элемента
* `menu.event` - имя события, вызвавшего скрипт
* `menu.input` - значение ввода, доступно только в контексте сценария ввода

В шаблонах меню доступны следующие действия:

* `menu.back(force, update)`: выполнит команду возврата к меню, необязательные булевы параметры `<force>` и `<update>`.
   * Если для `<force>` установлено значение True, то редактирование также будет остановлено. Значение по умолчанию - False.
   * Если значение `<обновить>` установлено Ложь, то элементы родительского контейнера не обновляются. Значение по умолчанию - Истина.
* `menu.exit(force)` - выполнит команду выхода из меню, необязательный булевский параметр `<force>` по умолчанию имеет значение Ложь.
   * Если для `<force>` установлено значение True, то редактирование также будет остановлено. Значение по умолчанию - False.

## Сохранить переменные на диске

Если включен раздел конфигурации [save_variables](Config_Reference.md#save_variables), то `SAVE_VARIABLE VARIABLE=<имя> VALUE=<значение>` можно использовать для сохранения переменной на диск, чтобы ее можно было использовать при перезапуске. Все сохраненные переменные при запуске загружаются в дикту `printer.save_variables.variables` и могут быть использованы в макросах gcode. Чтобы избежать слишком длинных строк, можно добавить в начало макроса следующее:

```
{% set svv = printer.save_variables.variables %}
```

Например, его можно использовать для сохранения состояния хотэнда 2-in-1-out и при запуске печати убедиться, что используется активный экструдер, а не T0:

```
[gcode_macro T1]
gcode:
  ACTIVATE_EXTRUDER extruder=extruder1
  SAVE_VARIABLE VARIABLE=currentextruder VALUE='"extruder1"'

[gcode_macro T0]
gcode:
  ACTIVATE_EXTRUDER extruder=extruder
  SAVE_VARIABLE VARIABLE=currentextruder VALUE='"extruder"'

[gcode_macro START_GCODE]
gcode:
  {% set svv = printer.save_variables.variables %}
  ACTIVATE_EXTRUDER extruder={svv.currentextruder}
```
