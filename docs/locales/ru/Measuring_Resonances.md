# Изменения Резонансов

Klipper has built-in support for the ADXL345, MPU-9250, LIS2DW and LIS3DH compatible accelerometers which can be used to measure resonance frequencies of the printer for different axes, and auto-tune [input shapers](Resonance_Compensation.md) to compensate for resonances. Note that using accelerometers requires some soldering and crimping. The ADXL345 can be connected to the SPI interface of a Raspberry Pi or MCU board (it needs to be reasonably fast). The MPU family can be connected to the I2C interface of a Raspberry Pi directly, or to an I2C interface of an MCU board that supports 400kbit/s *fast mode* in Klipper. The LIS2DW and LIS3DH can be connected to either SPI or I2C with the same considerations as above.

При поиске акселерометров имейте в виду, что существует множество различных конструкций печатных плат и их клонов. Если акселерометр будет подключен к MCU принтера с напряжением 5 В, убедитесь, что он оснащен стабилизатором напряжения и переключателями уровней.

For ADXL345s, make sure that the board supports SPI mode (a small number of boards appear to be hard-configured for I2C by pulling SDO to GND).

For MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s and LIS2DW/LIS3DH there are also a variety of board designs and clones with different I2C pull-up resistors which will need supplementing.

## MCU с поддержкой *быстрого режима* I2C от Klipper

| Семейство MCU | Тестируемый микроконтроллер(ы) | MCU с поддержкой |
| :-: | :-- | :-- |
| Raspberry Pi | 3B+, Pico | 3A, 3A+, 3B, 4 |
| AVR ATmega | ATmega328p | ATmega32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 |
| AVR AT90 | - | AT90usb646, AT90usb1286 |
| SAMD | SAMC21G18 | SAMC21G18, SAMD21G18, SAMD21E18, SAMD21J18, SAMD21E15, SAMD51G19, SAMD51J19, SAMD51N19, SAMD51P20, SAME51J19, SAME51N19, SAME54P20 |

## Инструкции по установке

### Электропроводка

Для обеспечения целостности сигнала на большом расстоянии рекомендуется использовать кабель ethernet с экранированными витыми парами (cat5e или лучше). Если вы по-прежнему испытываете проблемы с целостностью сигнала (ошибки SPI/I2C):

- Дважды проверьте проводку с помощью цифрового мультиметра:
   - Правильные соединения в выключенном состоянии (целостность)
   - Правильное напряжение питания и заземления
- Только I2C:
   - Проверьте, что сопротивление линий SCL и SDA по отношению к 3,3 В находится в диапазоне от 900 Ом до 1,8K
   - Для получения полной технической информации обратитесь к [главе 7 спецификации шины I2C и руководству пользователя UM10204](https://www.pololu.com/file/0J435/UM10204.pdf) для *быстрого режима*
- Укоротить кабель

Подключите экран кабеля Ethernet только к заземлению платы MCU/Pi.

***Двойная проверка проводов перед включением питания, чтобы не повредить MCU/Raspberry Pi или акселерометр.***

### Акселерометры SPI

Предлагаемый порядок витой пары для трех витых пар:

```
GND+MISO
3.3V+MOSI
SCLK+CS
```

Обратите внимание, что в отличие от экрана кабеля, GND должен быть подключен с обоих концов.

#### ADXL345

##### Прямое подключение к Raspberry Pi

**Примечание: Многие MCU будут работать с ADXL345 в режиме SPI (например, Pi Pico), подключение и конфигурация зависят от конкретной платы и доступных выводов**

Вам необходимо подключить ADXL345 к вашему Raspberry Pi через SPI. Обратите внимание, что соединение I2C, которое предлагается в документации ADXL345, имеет слишком низкую пропускную способность и ** не будет работать **. Рекомендуемая схема подключения:

| ADXL345 pin | Контакт RPi | Название выводов RPi |
| :-: | :-: | :-: |
| 3V3 (или VCC) | 01 | Питание 3,3 В постоянного тока |
| GND | 06 | Земля |
| CS | 24 | GPIO08 (SPI0_CE0_N) |
| SDO | 21 | GPIO09 (SPI0_MISO) |
| SDA | 19 | GPIO10 (SPI0_MOSI) |
| SCL | 23 | GPIO11 (SPI0_SCLK) |

Схемы подключения некоторых плат ADXL345:

![ADXL345-Rpi](img/adxl345-fritzing.png)

##### Использование Raspberry Pi Pico

Вы можете подключить ADXL345 к Raspberry Pi Pico, а затем подключить Pico к Raspberry Pi через USB. Это упрощает повторное использование акселерометра в других устройствах Klipper, так как вы можете подключить его через USB, а не через GPIO. Pico не обладает большой вычислительной мощностью, поэтому убедитесь, что он работает только с акселерометром и не выполняет никаких других функций.

Во избежание повреждения RPi убедитесь, что ADXL345 подключен только к 3,3 В. В зависимости от разводки платы может присутствовать переключатель уровней, что сделает 5 В опасным для вашей RPi.

| ADXL345 pin | Pico pin | Название вывода Pico |
| :-: | :-: | :-: |
| 3V3 (или VCC) | 36 | Питание 3,3 В постоянного тока |
| GND | 38 | Земля |
| CS | 2 | GP1 (SPI0_CSn) |
| SDO | 1 | GP0 (SPI0_RX) |
| SDA | 5 | GP3 (SPI0_TX) |
| SCL | 4 | GP2 (SPI0_SCK) |

Схемы подключения некоторых плат ADXL345:

![ADXL345-Pico](img/adxl345-pico.png)

### Акселерометры I2C

Предлагаемый порядок витой пары - три пары (предпочтительно):

```
3.3V+GND
SDA+GND
SCL+GND
```

или для двух пар:

```
3.3V+SDA
GND+SCL
```

Обратите внимание, что в отличие от экрана кабеля, любые GND(ы) должны быть подключены с обоих концов.

#### MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500

Эти акселерометры протестированы на работу по протоколу I2C на RPi, RP2040 (Pico) и AVR со скоростью 400 кбит/с (*быстрый режим*). Некоторые модули акселерометров MPU включают подтягивающие резисторы, но некоторые из них слишком велики - 10K, и их необходимо заменить или дополнить меньшими параллельными резисторами.

Рекомендуемая схема подключения I2C на Raspberry Pi:

| MPU-9250 pin | Контакт RPi | Название выводов RPi |
| :-: | :-: | :-: |
| VCC | 01 | Питание 3,3 В постоянного тока |
| GND | 09 | Земля |
| SDA | 03 | GPIO02 (SDA1) |
| SCL | 05 | GPIO03 (SCL1) |

RPi имеет встроенные подтяжки 1,8K на SCL и SDA.

![MPU-9250 подключен к Pi](img/mpu9250-PI-fritzing.png)

Рекомендуемая схема подключения I2C (i2c0a) на RP2040:

| MPU-9250 pin | RP2040 pin | Название выводов RP2040 |
| :-: | :-: | :-: |
| VCC | 36 | 3v3 |
| GND | 38 | Земля |
| SDA | 01 | GP0 (I2C0 SDA) |
| SCL | 02 | GP1 (I2C0 SCL) |

В Pico нет встроенных подтягивающих резисторов I2C.

![MPU-9250 подключен к Pico](img/mpu9250-PICO-fritzing.png)

##### Рекомендуемая схема подключения I2C(TWI) на AVR ATmega328P Arduino Nano:

| MPU-9250 pin | Atmega328P TQFP32 pin | Название выводов Atmega328P | Arduino Nano pin |
| :-: | :-: | :-: | :-: |
| VCC | 39 | - | - |
| GND | 38 | Земля | GND |
| SDA | 27 | SDA | A4 |
| SCL | 28 | SCL | A5 |

В Arduino Nano нет ни встроенных подтягивающих резисторов, ни вывода питания 3,3 В.

### Монтаж акселерометра

Акселерометр должен быть прикреплен к инструментальной головке. Необходимо разработать соответствующее крепление, которое подойдет для вашего 3D-принтера. Оси акселерометра лучше совместить с осями принтера (но если так будет удобнее, оси можно поменять местами - то есть не нужно совмещать ось X с X и так далее - все будет хорошо, даже если ось Z акселерометра будет совпадать с осью X принтера и т. д.).

Пример установки ADXL345 на SmartEffector:

![ADXL345 on SmartEffector](img/adxl345-mount.jpg)

Обратите внимание, что для принтера со станиной необходимо разработать два крепления: одно для инструментальной головки и одно для станины, и выполнить измерения дважды. Более подробную информацию смотрите в соответствующем [разделе](#bed-slinger-printers).

**Внимание:** убедитесь, что акселерометр и винты, удерживающие его на месте, не касаются металлических частей принтера. В принципе, крепление должно быть спроектировано таким образом, чтобы обеспечить электрическую изоляцию акселерометра от рамы принтера. Если этого не сделать, в системе может возникнуть контур заземления, который может повредить электронику.

### Установка программного обеспечения

Обратите внимание, что для измерения резонанса и автоматической калибровки шейпера требуются дополнительные программные зависимости, не установленные по умолчанию. Сначала выполните на вашем Raspberry Pi следующие команды:

```
sudo apt update
sudo apt install python3-numpy python3-matplotlib libatlas-base-dev libopenblas-dev
```

Далее, чтобы установить NumPy в среду Klipper, выполните команду:

```
~/klippy-env/bin/pip install -v "numpy<1.26"
```

Note that, depending on the performance of the CPU, it may take *a lot* of time, up to 10-20 minutes. Be patient and wait for the completion of the installation. On some occasions, if the board has too little RAM the installation may fail and you will need to enable swap. Also note the forced version, due to newer versions of NumPY having requirements that may not be satisfied in some klipper python environments.

Once installed please check that no errors show from the command:

```
~/klippy-env/bin/python -c 'import numpy;'
```

The correct output should simply be a new line.

#### Настройка ADXL345 с помощью RPi

Сначала проверьте и следуйте инструкциям в документе [RPi Microcontroller](RPi_microcontroller.md), чтобы настроить "linux mcu" на Raspberry Pi. Это позволит настроить второй экземпляр Klipper, который будет работать на вашем Pi.

Убедитесь, что драйвер Linux SPI включен, запустив `sudo raspi-config` и включив SPI в меню "Параметры взаимодействия".

Добавьте следующее в файл printer.cfg:

```
[mcu rpi]
serial: /tmp/klipper_host_mcu

[adxl345]
cs_pin: rpi: Нет

[resonance_tester]
accel_chip: adxl345
probe_points:
    100, 100, 20 # пример
```

Рекомендуется начать с 1 точки зондирования, расположенной в середине печатного слоя и немного выше него.

#### Настройка ADXL345 с Pi Pico

##### Прошивка микропрограммы Pico

На вашем Raspberry Pi скомпилируйте прошивку для Pico.

```
cd ~/klipper
make clean
make menuconfig
```

![Pico menuconfig](img/klipper_pico_menuconfig.png)

Теперь, удерживая кнопку `BOOTSEL` на Pico, подключите Pico к Raspberry Pi через USB. Скомпилируйте и прошейте прошивку.

```
make flash FLASH_DEVICE=first
```

Если это не удастся, вам будет указано, какой `FLASH_DEVICE` следует использовать. В данном примере это `make flash FLASH_DEVICE=2e8a:0003`. ![Определить флеш-устройство](img/flash_rp2040_FLASH_DEVICE.png)

##### Настройка соединения

Теперь Pico перезагрузится с новой прошивкой и будет отображаться как последовательное устройство. Найдите последовательное устройство pico с помощью `ls /dev/serial/by-id/*`. Теперь вы можете добавить файл `adxl.cfg` со следующими настройками:

```
[mcu adxl]
# Измените <mySerial> на то, что вы нашли выше. Например,
# usb-Klipper_rp2040_E661640843545B2E-if00
serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial>

[adxl345]
cs_pin: adxl:gpio1
spi_bus: spi0a
axes_map: x,z,y

[resonance_tester]
accel_chip: adxl345
probe_points:
    # Где-то чуть выше середины печатной формы
    147,154, 20

[output_pin power_mode] # Улучшение стабильности питания
вывод: adxl:gpio23
```

Если конфигурация ADXL345 задается в отдельном файле, как показано выше, вам также потребуется изменить файл `printer.cfg`, чтобы включить его:

```
[include adxl.cfg] # Закомментируйте это при отключении акселерометра
```

Перезапустите Klipper с помощью команды `RESTART`.

#### Configure LIS2DW series over SPI

```
[mcu lis]
# Измените <mySerial> на то, что вы нашли выше. Например,
# usb-Klipper_rp2040_E661640843545B2E-if00
serial: /dev/serial/by-id/usb-Klipper_rp2040_<mySerial>

[lis2dw]
cs_pin: lis:gpio1
шина spi_bus: spi0a
axes_map: x,z,y

[resonance_tester]
accel_chip: lis2dw
probe_points:
    # Где-то чуть выше середины печатной формы
    147,154, 20
```

#### Настройка MPU-6000/9000 серии с помощью RPi

Убедитесь, что драйвер Linux I2C включен, а скорость передачи данных установлена на 400000 (подробнее см. в разделе [Enabling I2C](RPi_microcontroller.md#optional-enabling-i2c)). Затем добавьте следующее в файл printer.cfg:

```
[mcu rpi]
serial: /tmp/klipper_host_mcu

[mpu9250]
i2c_mcu: rpi
i2c_bus: i2c.1

[resonance_tester]
accel_chip: mpu9250
probe_points:
    100, 100, 20 # пример
```

#### Настройка совместимости MPU-9520 с Pico

По умолчанию для Pico I2C установлено значение 400000. Просто добавьте следующее в файл printer.cfg:

```
[mcu pico]
serial: /dev/serial/by-id/<серийный идентификатор вашего Pico>

[mpu9250]
i2c_mcu: pico
i2c_bus: i2c0a

[resonance_tester]
accel_chip: mpu9250
probe_points:
    100, 100, 20 # пример

[static_digital_output pico_3V3pwm] # Улучшение стабильности питания
выводы: pico:gpio23
```

#### Настройка совместимости MPU-9520 с AVR

Для AVR I2C будет установлено значение 400000 с помощью опции mpu9250. Просто добавьте следующее в файл printer.cfg:

```
[mcu nano]
serial: /dev/serial/by-id/<серийный идентификатор вашего nano>

[mpu9250]
i2c_mcu: nano

[resonance_tester]
accel_chip: mpu9250
probe_points:
    100, 100, 20   # пример
```

Перезапустите Klipper с помощью команды `RESTART`.

## Измерение резонанса

### Проверка установки

Теперь вы можете проверить соединение.

- Для "не-акселерометров" (например, с одним акселерометром), в Octoprint введите `ACCELEROMETER_QUERY`
- Для "кроватных слингов" (например, более одного акселерометра) введите `ACCELEROMETER_QUERY CHIP=<chip>`, где `<chip>` - имя введенного чипа, например, `CHIP=bed` ( смотрите: [bed-slinger](#bed-slinger-printers)) для всех установленных чипов акселерометров.

Вы должны увидеть текущие измерения акселерометра, включая ускорение свободного падения, например.

```
Recv: // значения adxl345 (x, y, z): 470.719200, 941.438400, 9728.196800
```

Если вы получите ошибку типа `Invalid adxl345 id (got xx vs e5)`, где `xx` - это какой-то другой ID, немедленно повторите попытку. Это проблема с инициализацией SPI. Если вы по-прежнему получаете ошибку, это говорит о проблеме с подключением ADXL345 или неисправном датчике. Дважды проверьте питание, проводку (соответствует ли она схеме, нет ли оборванных или ослабленных проводов и т.д.) и качество пайки.

**Если вы используете акселерометр, совместимый с MPU-9250, и он отображается как `mpu-unknown`, используйте его с осторожностью! Скорее всего, это восстановленные микросхемы!**

Далее попробуйте запустить `MEASURE_AXES_NOISE` в Octoprint, вы должны получить некоторые базовые цифры для шума акселерометра по осям (должны быть где-то в диапазоне ~1-100). Слишком высокий шум по осям (например, 1000 и более) может свидетельствовать о проблемах с датчиком, проблемах с его питанием или слишком шумных несбалансированных вентиляторах на 3D-принтере.

### Измерение резонанса

Теперь вы можете провести несколько реальных тестов. Выполните следующую команду:

```
TEST_RESONANCES AXIS=X
```

Обратите внимание, что это создаст вибрации по оси X. Это также отключит формирование входного сигнала, если оно было включено ранее, так как проведение резонансного тестирования с включенным формирователем входного сигнала недопустимо.

**Внимание! ** Обязательно понаблюдайте за принтером в первый раз, чтобы убедиться, что вибрации не станут слишком сильными (команда `M112` может быть использована для прерывания теста в случае крайней необходимости; надеемся, что до этого не дойдет). Если вибрации все же становятся слишком сильными, можно попытаться задать меньшее, чем по умолчанию, значение параметра `accel_per_hz` в разделе `[resonance_tester]`, например.

```
[resonance_tester]
accel_chip: adxl345
accel_per_hz: 50  # default is 75
probe_points: ...
```

Если это работает для оси X, запустите и для оси Y:

```
TEST_RESONANCES AXIS=Y
```

В результате будут сгенерированы 2 файла CSV (`/tmp/resonances_x_*.csv` и `/tmp/resonances_y_*.csv`). Эти файлы можно обработать с помощью автономного скрипта на Raspberry Pi. Этот скрипт предназначен для запуска с одним CSV-файлом для каждой измеряемой оси, хотя его можно использовать с несколькими CSV-файлами, если вы хотите усреднить результаты. Усреднение результатов может быть полезным, например, если резонансные испытания проводились в нескольких точках. Удалите дополнительные CSV-файлы, если вы не хотите усреднять их.

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png
```

Этот скрипт сгенерирует графики `/tmp/shaper_calibrate_x.png` и `/tmp/shaper_calibrate_y.png` с частотными характеристиками. Вы также получите предлагаемые частоты для каждого входного формирователя, а также то, какой входной формирователь рекомендуется для вашей установки. Например:

![Resonances](img/calibrate-y.png)

```
Частота шейпера 'zv' = 34,4 Гц (вибрации = 4,0%, сглаживание ~= 0,132)
Чтобы избежать слишком сильного сглаживания при использовании 'zv', предлагается max_accel <= 4500 мм/сек^2
Частота шейпера 'mzv' = 34,6 Гц (вибрации = 0,0%, сглаживание ~= 0,170)
Чтобы избежать слишком сильного сглаживания при использовании 'mzv', предлагается max_accel <= 3500 мм/сек^2
Подогнанная частота шейпера 'ei' = 41,4 Гц (колебания = 0,0%, сглаживание ~= 0,188)
Чтобы избежать слишком сильного сглаживания при использовании 'ei', предлагается max_accel <= 3200 мм/сек^2
Частота шейпера '2hump_ei' = 51,8 Гц (вибрации = 0,0%, сглаживание ~= 0,201)
Чтобы избежать слишком сильного сглаживания при использовании '2hump_ei', предлагается max_accel <= 3000 мм/сек^2
Частота шейпера '3hump_ei' = 61,8 Гц (колебания = 0,0%, сглаживание ~= 0,215)
Чтобы избежать слишком сильного сглаживания с '3hump_ei', предлагается max_accel <= 2800 мм/сек^2
Рекомендуемый шейпер - mzv @ 34.6 Гц
```

Предлагаемую конфигурацию можно добавить в раздел `[input_shaper]` файла `printer.cfg`, например:

```
[input_shaper]
shaper_freq_x: ...
shaper_type_x: ...
shaper_freq_y: 34.6
shaper_type_y: mzv

[принтер]
max_accel: 3000 # не должно превышать расчетное значение max_accel для осей X и Y
```

или вы можете самостоятельно выбрать другую конфигурацию, основываясь на сгенерированных графиках: пики спектральной плотности мощности на графиках соответствуют резонансным частотам принтера.

Обратите внимание, что в качестве альтернативы вы можете запустить автокалибровку входного формирователя из Klipper [напрямую](#input-shaper-auto-calibration), что может быть удобно, например, для повторной калибровки входного формирователя [re-calibration](#input-shaper-re-calibration).

### Печатающие устройства для постельных принадлежностей

Если ваш принтер является принтером со станиной, вам нужно будет изменить расположение акселерометра между измерениями по осям X и Y: измерять резонансы по оси X с акселерометром, прикрепленным к инструментальной головке, а резонансы по оси Y - к станине (обычная установка станины).

Однако можно подключить и два акселерометра одновременно, правда, ADXL345 должны быть подключены к разным платам (например, к плате RPi и плате MCU принтера) или к двум разным физическим SPI-интерфейсам на одной плате (что бывает редко). Затем их можно сконфигурировать следующим образом:

```
[adxl345 hotend]
# Предполагается, что микросхема `hotend` подключена к RPi
cs_pin: rpi:None

[adxl345 bed]
# Предполагается, что микросхема `bed` подключена к плате MCU принтера
cs_pin: ...  # Вывод выбора микросхемы SPI платы принтера (CS)

[resonance_tester]
# Предполагается, что типичная установка принтера-раскладушки
accel_chip_x: adxl345 hotend
accel_chip_y: adxl345 bed
probe_points: ...
```

Два MPU могут использовать одну шину I2C, но они **не могут** проводить измерения одновременно, поскольку скорость шины I2C 400 кбит/с недостаточна. Один из них должен иметь вывод AD0, подтянутый к 0 В (адрес 104), а другой - вывод AD0, подтянутый к 3,3 В (адрес 105):

```
[mpu9250 hotend]
i2c_mcu: rpi
i2c_bus: i2c.1
i2c_address: 104 # У этого MPU пин AD0 подтянут к низкому уровню.

[mpu9250 bed]
i2c_mcu: rpi
i2c_bus: i2c.1
i2c_address: 105 # У этого MPU пин AD0 подтянут к высокому уровню.

[resonance_tester]
# Предполагаем типичную настройку принтера с продольными полозьями
accel_chip_x: mpu9250 hotend
accel_chip_y: mpu9250 bed
probe_points: ...
```

[Протестируйте каждый MPU по отдельности, прежде чем подключать оба к шине, чтобы облегчить отладку]

Тогда команды `TEST_RESONANCES AXIS=X` и `TEST_RESONANCES AXIS=Y` будут использовать правильный акселерометр для каждой оси.

### Максимальное сглаживание

Помните, что входной формирователь может создавать некоторое сглаживание в отдельных частях. Автоматическая настройка входного формирователя, выполняемая скриптом `calibrate_shaper.py` или командой `SHAPER_CALIBRATE`, старается не усугублять сглаживание, но в то же время пытается минимизировать возникающие вибрации. Иногда они могут сделать неоптимальный выбор частоты шейпера, или, возможно, вы просто предпочитаете меньшее сглаживание в частях за счет больших остаточных вибраций. В таких случаях можно попросить ограничить максимальное сглаживание от входного формирователя.

Рассмотрим следующие результаты автоматической настройки:

![Resonances](img/calibrate-x.png)

```
Частота шейпера 'zv' = 57,8 Гц (вибрации = 20,3%, сглаживание ~= 0,053)
Чтобы избежать слишком сильного сглаживания при использовании 'zv', предлагается max_accel <= 13000 мм/сек^2
Частота шейпера 'mzv' = 34,8 Гц (вибрации = 3,6%, сглаживание ~= 0,168)
Чтобы избежать слишком сильного сглаживания при использовании 'mzv', предлагается max_accel <= 3600 мм/сек^2
Частота шейпера 'ei' = 48,8 Гц (вибрации = 4,9%, сглаживание ~= 0,135)
Чтобы избежать слишком сильного сглаживания при использовании 'ei', предлагается max_accel <= 4400 мм/сек^2
Частота шейпера '2hump_ei' = 45,2 Гц (вибрации = 0,1%, сглаживание ~= 0,264)
Чтобы избежать слишком сильного сглаживания при использовании '2hump_ei', предлагается max_accel <= 2200 мм/сек^2
Частота шейпера '3hump_ei' = 48,0 Гц (вибрации = 0,0%, сглаживание ~= 0,356)
Чтобы избежать слишком сильного сглаживания при использовании '3hump_ei', предлагается max_accel <= 1500 мм/сек^2
Рекомендуемый шейпер - 2hump_ei @ 45,2 Гц
```

Обратите внимание, что указанные значения `сглаживания` - это некие абстрактные прогнозируемые значения. Эти значения можно использовать для сравнения различных конфигураций: чем выше значение, тем больше сглаживания создаст шейпер. Однако эти показатели сглаживания не являются реальной мерой сглаживания, поскольку фактическое сглаживание зависит от параметров [`max_accel`](#selecting-max-accel) и `square_corner_velocity`. Поэтому вам следует напечатать несколько тестовых отпечатков, чтобы узнать, сколько сглаживания создает выбранная конфигурация.

В приведенном примере предложенные параметры шейпера неплохи, но что, если вы хотите получить меньшее сглаживание по оси X? Вы можете попробовать ограничить максимальное сглаживание шейпера с помощью следующей команды:

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0.2
```

что ограничивает сглаживание до 0,2 балла. Теперь вы можете получить следующий результат:

![Resonances](img/calibrate-x-max-smoothing.png)

```
Частота шейпера 'zv' = 55,4 Гц (вибрации = 19,7%, сглаживание ~= 0,057)
Чтобы избежать слишком сильного сглаживания при использовании 'zv', предлагается max_accel <= 12000 мм/сек^2
Частота шейпера 'mzv' = 34,6 Гц (вибрации = 3,6%, сглаживание ~= 0,170)
Чтобы избежать слишком сильного сглаживания при использовании 'mzv', предлагается max_accel <= 3500 мм/сек^2
Подогнанная частота шейпера 'ei' = 48,2 Гц (колебания = 4,8%, сглаживание ~= 0,139)
Чтобы избежать слишком сильного сглаживания при использовании 'ei', предлагается max_accel <= 4300 мм/сек^2
Частота шейпера '2hump_ei' = 52,0 Гц (вибрации = 2,7%, сглаживание ~= 0,200)
Чтобы избежать слишком сильного сглаживания при использовании '2hump_ei', предлагается max_accel <= 3000 мм/сек^2
Частота шейпера '3hump_ei' = 72,6 Гц (колебания = 1,4%, сглаживание ~= 0,155)
Чтобы избежать слишком сильного сглаживания с помощью '3hump_ei', предлагается max_accel <= 3900 мм/сек^2
Рекомендуемый шейпер - 3hump_ei @ 72,6 Гц
```

Если сравнивать с ранее предложенными параметрами, то вибрации немного больше, но сглаживание значительно меньше, чем раньше, что позволяет увеличить максимальное ускорение.

При выборе параметра `max_smoothing` вы можете использовать метод проб и ошибок. Попробуйте несколько различных значений и посмотрите, какие результаты вы получите. Обратите внимание, что фактическое сглаживание, производимое входным формирователем, зависит, прежде всего, от самой низкой резонансной частоты принтера: чем выше частота самого низкого резонанса - тем меньше сглаживание. Поэтому, если вы попросите скрипт найти конфигурацию входного формирователя с нереально малым сглаживанием, это произойдет за счет увеличения звона на самых низких резонансных частотах (которые, как правило, также более заметны на отпечатках). Поэтому всегда перепроверяйте прогнозируемые остаточные колебания, сообщаемые скриптом, и убедитесь, что они не слишком высоки.

Обратите внимание, что если вы выбрали хорошее значение `max_smoothing` для обеих осей, вы можете сохранить его в файле `printer.cfg` как

```
[resonance_tester]
accel_chip: ...
probe_points: ...
max_smoothing: 0.25 # пример
```

Тогда, если в будущем вы [повторно](#input-shaper-re-calibration) запустите автонастройку входного шейпера с помощью команды `SHAPER_CALIBRATE` Klipper, он будет использовать сохраненное значение `max_smoothing` в качестве эталона.

### Selecting max_accel

Поскольку входной формирователь может создавать некоторое сглаживание деталей, особенно при высоких ускорениях, вам все равно придется выбрать значение `max_accel`, которое не будет создавать слишком сильного сглаживания на отпечатанных деталях. Сценарий калибровки предоставляет оценку параметра `max_accel`, который не должен создавать слишком сильного сглаживания. Обратите внимание, что значение `max_accel`, отображаемое калибровочным скриптом, является лишь теоретическим максимумом, при котором соответствующий формирователь еще способен работать, не создавая слишком сильного сглаживания. Ни в коем случае не рекомендуется устанавливать это ускорение для печати. Максимальное ускорение, которое способен выдержать ваш принтер, зависит от его механических свойств и максимального крутящего момента используемых шаговых двигателей. Поэтому рекомендуется установить `max_accel` в секции `[принтер]`, не превышающее расчетных значений для осей X и Y, скорее всего, с некоторым консервативным запасом прочности.

В качестве альтернативы, следуйте [this](Resonance_Compensation.md#selecting-max_accel) части руководства по настройке входного формирователя и распечатайте тестовую модель для экспериментального выбора параметра `max_accel`.

Это же замечание относится и к входному шейперу [автокалибровка](#input-shaper-auto-calibration) с командой `SHAPER_CALIBRATE`: после автокалибровки по-прежнему необходимо выбрать правильное значение `max_accel`, и предложенные ограничения ускорения не будут применяться автоматически.

Помните, что максимальное ускорение без слишком сильного сглаживания зависит от значения `square_corner_velocity`. Общая рекомендация - не изменять его от значения по умолчанию 5.0, и именно это значение используется по умолчанию скриптом `calibrate_shaper.py`. Если вы все же изменили его, то сообщите об этом скрипту, передав параметр `--square_corner_velocity=...`, например.

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --square_corner_velocity=10.0
```

чтобы правильно рассчитать рекомендации по максимальному ускорению. Обратите внимание, что команда `SHAPER_CALIBRATE` уже учитывает настроенный параметр `square_corner_velocity`, и нет необходимости указывать его явно.

Если вы выполняете повторную калибровку формирователя и полученное значение сглаживания для предложенной конфигурации формирователя почти такое же, как и при предыдущей калибровке, этот шаг можно пропустить.

### Unreliable measurements of resonance frequencies

Sometimes the resonance measurements can produce bogus results, leading to the incorrect suggestions for the input shapers. This can be caused by a variety of reasons, including running fans on the toolhead, incorrect position or non-rigid mounting of the accelerometer, or mechanical problems such as loose belts or binding or bumpy axis. Keep in mind that all fans should be disabled for resonance testing, especially the noisy ones, and that the accelerometer should be rigidly mounted on the corresponding moving part (e.g. on the bed itself for the bed slinger, or on the extruder of the printer itself and not the carriage, and some people get better results by mounting the accelerometer on the nozzle itself). As for mechanical problems, the user should inspect if there is any fault that can be fixed with a moving axis (e.g. linear guide rails cleaned up and lubricated and V-slot wheels tension adjusted correctly). If none of that helps, a user may try the other shapers from the produced list besides the one recommended by default.

### Тестирование пользовательских осей

Команда `TEST_RESONANCES` поддерживает пользовательские оси. Хотя это не очень полезно для калибровки входного формирователя, ее можно использовать для углубленного изучения резонансов принтера и, например, для проверки натяжения ремня.

Чтобы проверить натяжение ремня на принтерах CoreXY, выполните команду

```
TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data
TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data
```

и используйте `graph_accelerometer.py` для обработки сгенерированных файлов, например

```
~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png
```

который создаст файл `/tmp/resonances.png`, сравнивающий резонансы.

Для принтеров Delta с размещением башни по умолчанию (башня A ~= 210 градусов, B ~= 330 градусов и C ~= 90 градусов) выполните команду

```
TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data
TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data
TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data
```

а затем выполните ту же команду

```
~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png
```

чтобы создать файл `/tmp/resonances.png`, сравнивающий резонансы.

## Автоматическая калибровка входного формирователя

Помимо ручного выбора подходящих параметров для функции входного формирователя, можно также запустить автонастройку входного формирователя непосредственно из Klipper. Выполните следующую команду через терминал Octoprint:

```
SHAPER_CALIBRATE
```

Это запустит полный тест для обеих осей и сгенерирует выходной файл csv (по умолчанию `/tmp/calibration_data_*.csv`) для частотной характеристики и предлагаемых входных формирователей. Вы также получите предлагаемые частоты для каждого входного формирователя, а также информацию о том, какой входной формирователь рекомендуется для вашей установки, на консоли Octoprint. Например:

```
Расчет оптимальных параметров входного формирователя для оси y
Подходящая частота шейвера 'zv' = 39,0 Гц (вибрации = 13,2%, сглаживание ~= 0,105)
Чтобы избежать слишком сильного сглаживания при использовании 'zv', предлагается max_accel <= 5900 мм/сек^2
Частота шейпера 'mzv' = 36,8 Гц (вибрации = 1,7%, сглаживание ~= 0,150)
Чтобы избежать слишком сильного сглаживания при использовании 'mzv', предлагается max_accel <= 4000 мм/сек^2
Частота шейпера 'ei' = 36,6 Гц (вибрации = 2,2%, сглаживание ~= 0,240)
Чтобы избежать слишком сильного сглаживания при использовании 'ei', предлагается max_accel <= 2500 мм/сек^2
Частота шейпера '2hump_ei' = 48,0 Гц (вибрации = 0,0%, сглаживание ~= 0,234)
Чтобы избежать слишком сильного сглаживания при использовании '2hump_ei', предлагается max_accel <= 2500 мм/сек^2
Частота шейпера '3hump_ei' = 59,0 Гц (вибрации = 0,0%, сглаживание ~= 0,235)
Чтобы избежать слишком сильного сглаживания при использовании '3hump_ei', предлагается max_accel <= 2500 мм/сек^2
Рекомендуемый тип шейпера_y = mzv, частота шейпера_y = 36,8 Гц
```

Если вы согласны с предложенными параметрами, вы можете выполнить команду `SAVE_CONFIG`, чтобы сохранить их и перезапустить Klipper. Обратите внимание, что это не приведет к обновлению значения `max_accel` в разделе `[принтер]`. Вы должны обновить его вручную, следуя указаниям в разделе [Выбор max_accel](#selecting-max_accel).

Если ваш принтер является принтером со станиной, вы можете указать, какую ось тестировать, чтобы между тестами можно было менять точку установки акселерометра (по умолчанию тест выполняется для обеих осей):

```
SHAPER_CALIBRATE AXIS=Y
```

Вы можете выполнить `SAVE_CONFIG` дважды - после калибровки каждой оси.

Однако если вы подключили два акселерометра одновременно, достаточно запустить `SHAPER_CALIBRATE` без указания оси, чтобы откалибровать входной формирователь для обеих осей за один раз.

### Повторная калибровка входного формирователя

Команда `SHAPER_CALIBRATE` может также использоваться для повторной калибровки входного формирователя в будущем, особенно если в принтер были внесены некоторые изменения, которые могут повлиять на его кинематику. Можно либо повторно выполнить полную калибровку с помощью команды `SHAPER_CALIBRATE`, либо ограничить автокалибровку одной осью, указав параметр `AXIS=`, например

```
SHAPER_CALIBRATE AXIS=X
```

**Предупреждение!** Не рекомендуется выполнять автокалибровку шейпера очень часто (например, перед каждой печатью или каждый день). Для определения резонансных частот автокалибровка создает интенсивные вибрации по каждой из осей. Как правило, 3D-принтеры не рассчитаны на длительное воздействие вибраций, близких к резонансным частотам. Это может увеличить износ компонентов принтера и сократить срок их службы. Также повышается риск откручивания или ослабления некоторых деталей. Всегда проверяйте, чтобы все детали принтера (включая те, которые обычно не двигаются) были надежно закреплены на месте после каждой автонастройки.

Кроме того, из-за некоторого шума при измерениях возможно, что результаты настройки будут немного отличаться от одного прогона калибровки к другому. Тем не менее, не ожидается, что шум сильно повлияет на качество печати. Тем не менее, рекомендуется перепроверить предложенные параметры и напечатать несколько пробных отпечатков перед использованием, чтобы убедиться в их правильности.

## Обработка данных акселерометра в автономном режиме

Можно сгенерировать необработанные данные акселерометра и обработать их в автономном режиме (например, на хост-машине), например, для поиска резонансов. Для этого выполните следующие команды через терминал Octoprint:

```
SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0
TEST_RESONANCES AXIS=X OUTPUT=raw_data
```

игнорируя любые ошибки для команды `SET_INPUT_SHAPER`. Для команды `TEST_RESONANCES` укажите желаемую тестовую ось. Необработанные данные будут записаны в каталог `/tmp` на RPi.

Необработанные данные можно также получить, выполнив команду `ACCELEROMETER_MEASURE` дважды во время обычной работы принтера - сначала для запуска измерений, а затем для их остановки и записи выходного файла. Более подробную информацию см. в [G-Codes](G-Codes.md#adxl345).

Полученные данные могут быть обработаны следующими скриптами: `scripts/graph_accelerometer.py` и `scripts/calibrate_shaper.py`. Оба они принимают на вход один или несколько необработанных csv-файлов в зависимости от режима. Скрипт graph_accelerometer.py поддерживает несколько режимов работы:

* При построении графика необработанных данных акселерометра (используйте параметр `-r`), поддерживается только 1 вход;
* построение частотной характеристики (дополнительные параметры не требуются), если задано несколько входов, вычисляется средняя частотная характеристика;
* сравнение частотных характеристик между несколькими входами (используется параметр `-c`); вы можете дополнительно указать, какую ось акселерометра учитывать через параметр `-a x`, `-a y` или `-a z` (если он не указан, используется сумма колебаний по всем осям);
* При построении спектрограммы (используется параметр `-s`) поддерживается только 1 вход; дополнительно можно указать, какую ось акселерометра учитывать через параметр `-a x`, `-a y` или `-a z` (если он не указан, используется сумма колебаний по всем осям).

Обратите внимание, что скрипт graph_accelerometer.py поддерживает только файлы raw_data\*.csv, но не файлы resonances\*.csv или calibration_data\*.csv.

Например,

```
~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o /tmp/resonances_x.png -c -a z
```

построит график сравнения нескольких файлов `/tmp/raw_data_x_*.csv` для оси Z с файлом `/tmp/resonances_x.png`.

Скрипт shaper_calibrate.py принимает 1 или несколько входных данных и может выполнить автоматическую настройку входного формирователя и предложить наилучшие параметры, которые хорошо работают для всех предоставленных входных данных. Он выводит предложенные параметры на консоль, а также может дополнительно сгенерировать график, если указан параметр `-o output.png`, или CSV-файл, если указан параметр `-c output.csv`.

Предоставление нескольких входов скрипту shaper_calibrate.py может быть полезно, например, при выполнении расширенной настройки входных шейперов:

* Запуск `TEST_RESONANCES AXIS=X OUTPUT=raw_data` (и оси `Y`) для одной оси дважды на принтере со станиной с акселерометром, прикрепленным к головке инструмента в первый раз, и акселерометром, прикрепленным к станине во второй раз, чтобы обнаружить кросс-резонансы осей и попытаться устранить их с помощью входных формирователей.
* Запустите `TEST_RESONANCES AXIS=Y OUTPUT=raw_data` дважды на стропальщике со стеклянной и магнитной поверхностями (которая легче), чтобы найти входные параметры формирователя, которые хорошо работают для любой конфигурации поверхности печати.
* Объединение резонансных данных из нескольких точек тестирования.
* Комбинирование данных резонанса по двум осям (например, в принтере с продольным механизмом печати для настройки X-axis input_shaper на основе резонансов по осям X и Y для устранения вибраций *кровати* в случае, если сопло "ловит" печать при движении в направлении оси X).
