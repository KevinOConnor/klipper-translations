# Протокол

Протокол обмена сообщениями Klipper используется для низкоуровневой связи между программным обеспечением хоста Klipper и программным обеспечением микроконтроллера Klipper. На высоком уровне протокол можно рассматривать как последовательность строк команд и ответов, которые сжимаются, передаются, а затем обрабатываются на принимающей стороне. Примерная серия команд в несжатом удобочитаемом формате может выглядеть следующим образом:

```
set_digital_out pin=PA3 значение=1
set_digital_out pin=PA7 значение=1
schedule_digital_out oid=8 часы=4000000 значение=0
queue_step oid=7 интервал=7458 счет=10 добавить=331
queue_step oid=7 интервал=11717 счет=4 добавить=1281
```

Смотрите [mcu commands](MCU_Commands.md) документ для получения информации о доступных командах. См. документ [отладка](Debugging.md) для получения информации о том, как преобразовать файл G-кода в соответствующие команды микроконтроллера, доступные для чтения человеком.

На этой странице представлено высокоуровневое описание самого протокола обмена сообщениями Klipper. В нем описывается, как сообщения объявляются, кодируются в двоичном формате (схема "сжатия") и передаются.

Цель протокола — обеспечить безошибочную работу канала связи между хостом и микроконтроллером с низкой задержкой, низкой пропускной способностью и низкой сложностью для микроконтроллера.

## Интерфейс микроконтроллера

Протокол передачи данных Klipper можно представить как механизм [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) между микроконтроллером и хостом. Программное обеспечение микроконтроллера объявляет команды, которые может вызывать хост, а также ответные сообщения, которые он может генерировать. Хост использует эту информацию, чтобы дать команду микроконтроллеру на выполнение действий и интерпретировать их результаты.

### Объявление команд

Программное обеспечение микроконтроллера объявляет "команду" с помощью макроса DECL_COMMAND() в коде на C. Например:

```
DECL_COMMAND(command_update_digital_out, "update_digital_out oid=%c value=%c");
```

Выше объявлена команда с именем "update_digital_out". Это позволяет хосту "вызвать" эту команду, что приведет к выполнению C-функции command_update_digital_out() в микроконтроллере. Выше также указано, что команда принимает два целочисленных параметра. При выполнении C-кода command_update_digital_out() ему будет передан массив, содержащий эти два целых числа - первое, соответствующее 'oid', и второе, соответствующее 'value'.

В общем случае параметры описываются с помощью синтаксиса в стиле printf() (например, "%u"). Форматирование напрямую соответствует человекочитаемому виду команд (например, "update_digital_out oid=7 value=1"). В приведенном выше примере "value=" - это имя параметра, а "%c" указывает на то, что параметр является целым числом. Внутри программы имя параметра используется только в качестве документации. В этом примере "%c" также используется в качестве документации, чтобы указать, что ожидаемое целое число имеет размер 1 байт (объявленный размер целого числа не влияет на синтаксический анализ или кодировку).

Сборка микроконтроллера соберет все команды, объявленные с помощью DECL_COMMAND(), определит их параметры и сделает их вызываемыми.

### Объявление ответов

Для передачи информации от микроконтроллера к хосту генерируется "ответ". Они объявляются и передаются с помощью макроса sendf() C. Например:

```
sendf("status clock=%u status=%c", sched_read_time(), sched_is_shutdown());
```

Выше передается ответное сообщение "status", содержащее два целочисленных параметра ("clock" и "status"). Сборка микроконтроллера автоматически находит все вызовы sendf() и генерирует для них кодировщики. Первый параметр функции sendf() описывает ответ и имеет тот же формат, что и объявления команд.

Хост может зарегистрировать функцию обратного вызова для каждого ответа. Таким образом, команды позволяют хосту вызывать функции C в микроконтроллере, а ответы позволяют программному обеспечению микроконтроллера вызывать код в хосте.

Макрос sendf() должен вызываться только из обработчиков команд или задач и не должен вызываться из прерываний или таймеров. Коду не нужно выдавать sendf() в ответ на полученную команду, он не ограничен в количестве вызовов sendf() и может вызывать sendf() в любое время из обработчика задачи.

#### Выходные ответы

Для упрощения отладки также имеется функция вывода() на Си. Например:

```
output("Значение %u равно %s с размером %u.", x, buf, buf_len);
```

Функция output() по своему назначению похожа на printf() - она предназначена для генерации и форматирования произвольных сообщений для человеческого потребления.

### Объявление перечислений

Перечисления позволяют коду хоста использовать строковые идентификаторы для параметров, которые микроконтроллер обрабатывает как целые числа. Они объявляются в коде микроконтроллера - например:

```
DECL_ENUMERATION("spi_bus", "spi", 0);

DECL_ENUMERATION_RANGE("pin", "PC0", 16, 8);
```

В первом примере макрос DECL_ENUMERATION() определяет перечисление для любого сообщения команды/ответа с именем параметра "spi_bus" или именем параметра с суффиксом "_spi_bus". Для этих параметров строка "spi" является допустимым значением и будет передаваться с целым значением, равным нулю.

Также можно объявить диапазон перечислений. Во втором примере параметр "pin" (или любой другой параметр с суффиксом "_pin") будет принимать в качестве допустимых значений PC0, PC1, PC2, ..., PC7. Строки будут передаваться целыми числами 16, 17, 18, ..., 23.

### Объявление констант

Константы также можно экспортировать. Например, следующее:

```
DECL_CONSTANT("SERIAL_BAUD", 250000);
```

экспортирует из микроконтроллера в хост константу с именем "SERIAL_BAUD" со значением 250000. Также можно объявить константу, которая является строкой - например:

```
DECL_CONSTANT_STR("MCU", "pru");
```

## Низкоуровневое кодирование сообщений

Чтобы реализовать описанный выше механизм RPC, каждая команда и ответ кодируются в двоичный формат для передачи. В этом разделе описывается система передачи данных.

### Блоки сообщений

Все данные, передаваемые от хоста к микроконтроллеру и наоборот, содержатся в "блоках сообщений". Блок сообщения имеет двухбайтовый заголовок и трехбайтовый трейлер. Формат блока сообщений следующий:

```
<1 байт длины><1 байт последовательности><n байт содержимого><2 байта crc><1 байт sync>
```

Байт длины содержит количество байт в блоке сообщения, включая байты заголовка и трейлера (таким образом, минимальная длина сообщения составляет 5 байт). Максимальная длина блока сообщения в настоящее время составляет 64 байта. Байт последовательности содержит 4-битный номер последовательности в младших битах, а старшие биты всегда содержат 0x10 (старшие биты зарезервированы для будущего использования). Байт содержимого содержит произвольные данные, их формат описан в следующем разделе. Байт crc содержит 16-битный CCITT [CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) блока сообщения, включая байты заголовка, но исключая байты трейлера. Байт синхронизации имеет значение 0x7e.

Формат блока сообщений разработан по образцу кадров сообщений [HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control). Как и в HDLC, блок сообщений может опционально содержать дополнительный символ синхронизации в начале блока. В отличие от HDLC, символ синхронизации не является исключительной частью фрейма и может присутствовать в содержимом блока сообщений.

### Содержание блока сообщений

Каждый блок сообщений, передаваемый от хоста к микроконтроллеру, содержит серию из нуля или более команд сообщений. Каждая команда начинается с [Variable Length Quantity](#variable-length-quantities) (VLQ), закодированного целочисленного command-id, за которым следуют ноль или более VLQ-параметров для данной команды.

Например, следующие четыре команды могут быть помещены в один блок сообщений:

```
update_digital_out oid=6 value=1
update_digital_out oid=5 value=0
get_config
get_clock
```

и кодируются в следующие восемь целых чисел VLQ:

```
<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>
```

Чтобы закодировать и разобрать содержимое сообщения, хост и микроконтроллер должны договориться об идентификаторах команд и количестве параметров в каждой команде. Так, в приведенном выше примере и хост, и микроконтроллер будут знать, что за командой "id_update_digital_out" всегда следуют два параметра, а команды "id_get_config" и "id_get_clock" имеют нулевые параметры. Хост и микроконтроллер совместно используют "словарь данных", который сопоставляет описания команд (например, "update_digital_out oid=%c value=%c") с их целочисленными идентификаторами команд. При обработке данных синтаксический анализатор будет знать, что после заданного идентификатора команды следует определенное количество параметров в кодировке VLQ.

Содержание сообщений для блоков, отправляемых от микроконтроллера к хосту, имеет одинаковый формат. Идентификаторы в этих сообщениях - это "идентификаторы ответов", но они служат той же цели и подчиняются тем же правилам кодирования. На практике блоки сообщений, отправляемые от микроконтроллера к хосту, никогда не содержат более одного ответа в содержимом блока сообщений.

#### Количества переменной длины

Более подробную информацию об общем формате целых чисел, закодированных в VLQ, смотрите в статье [wikipedia](https://en.wikipedia.org/wiki/Variable-length_quantity). Klipper использует схему кодирования, которая поддерживает как положительные, так и отрицательные целые числа. Для кодирования целых чисел, близких к нулю, требуется меньше байт, а для кодирования положительных целых чисел обычно требуется меньше байт, чем для отрицательных. В следующей таблице показано количество байт, необходимых для кодирования каждого целого числа:

| Целое число | Размер в кодировке |
| --- | --- |
| -32 .. 95 | 1 |
| -4096 .. 12287 | 2 |
| -524288 .. 1572863 | 3 |
| -67108864 .. 201326591 | 4 |
| -2147483648 .. 4294967295 | 5 |

#### Строки переменной длины

В качестве исключения из вышеуказанных правил кодирования, если параметр команды или ответа представляет собой динамическую строку, то параметр не кодируется как простое целое число VLQ. Вместо этого он кодируется путем передачи длины в виде целого числа в кодировке VLQ, за которым следует само содержимое:

```
<Длина в кодировке VLQ><n-байтовое содержимое>
```

Описания команд, содержащиеся в словаре данных, позволяют хосту и микроконтроллеру узнать, какие параметры команды используют простую кодировку VLQ, а какие - строковую кодировку.

## Словарь данных

Для того чтобы между микроконтроллером и хостом установился полноценный обмен данными, обе стороны должны договориться о "словаре данных". Этот словарь данных содержит целочисленные идентификаторы команд и ответов, а также их описания.

Сборка микроконтроллера использует содержимое макросов DECL_COMMAND() и sendf() для создания словаря данных. Сборка автоматически присваивает уникальные идентификаторы каждой команде и ответу. Такая система позволяет коду хоста и микроконтроллера без проблем использовать описательные человекопонятные имена, используя при этом минимальную пропускную способность.

Хост запрашивает словарь данных при первом подключении к микроконтроллеру. Как только хост загружает словарь данных с микроконтроллера, он использует этот словарь данных для кодирования всех команд и разбора всех ответов микроконтроллера. Таким образом, хост должен работать с динамическим словарем данных. Однако, чтобы упростить программное обеспечение микроконтроллера, он всегда использует статический (скомпилированный) словарь данных.

Словарь данных запрашивается путем отправки микроконтроллеру команд "identify". Микроконтроллер отвечает на каждую команду identify сообщением "identify_response". Поскольку эти две команды необходимы для получения словаря данных, их целочисленные идентификаторы и типы параметров жестко закодированы как в микроконтроллере, так и в хосте. Идентификатор ответа "identify_response" равен 0, а идентификатор команды "identify" - 1. Кроме жестко закодированных идентификаторов, команда "identify" и ее ответ объявляются и передаются так же, как и другие команды и ответы. Никакие другие команды или ответы не имеют жестко закодированных идентификаторов.

Сам формат передаваемого словаря данных представляет собой сжатую в zlib строку JSON. Процесс сборки микроконтроллера генерирует эту строку, сжимает ее и сохраняет в текстовом разделе флэш-памяти микроконтроллера. Словарь данных может быть намного больше максимального размера блока сообщений - хост загружает его, посылая несколько команд identify, запрашивающих последовательные фрагменты словаря данных. После получения всех фрагментов хост соберет их, распакует данные и разберет их содержимое.

Помимо информации о протоколе связи, словарь данных также содержит версию программного обеспечения, перечисления (как определено в DECL_ENUMERATION) и константы (как определено в DECL_CONSTANT).

## Поток сообщений

Команды сообщений, передаваемые от хоста к микроконтроллеру, должны быть безошибочными. Микроконтроллер проверяет CRC и порядковые номера в каждом блоке сообщений, чтобы убедиться в точности и последовательности команд. Микроконтроллер всегда обрабатывает блоки сообщений по порядку - если он получит блок не по порядку, то отбросит его и все другие блоки не по порядку, пока не получит блоки с правильной последовательностью.

В низкоуровневом коде хоста реализована система автоматической ретрансляции потерянных и поврежденных блоков сообщений, отправленных на микроконтроллер. Для этого микроконтроллер передает "блок сообщений ack" после каждого успешно принятого блока сообщений. Хост устанавливает тайм-аут после отправки каждого блока и повторно передает сообщение, если по истечении тайм-аута не будет получен соответствующий "ack". Кроме того, если микроконтроллер обнаруживает поврежденный или неупорядоченный блок, он может передать "nak message block" для облегчения быстрой повторной передачи.

Ack" - это блок сообщения с пустым содержимым (т.е. блок сообщения размером 5 байт) и порядковым номером, большим, чем последний полученный порядковый номер хоста. nak" - это блок сообщения с пустым содержимым и номером последовательности, меньшим, чем последний полученный номер последовательности хоста.

Протокол поддерживает "оконную" систему передачи, так что у хоста может быть много незавершенных блоков сообщений в полете одновременно. (Это в дополнение к множеству команд, которые могут присутствовать в данном блоке сообщений). Это позволяет максимально использовать полосу пропускания даже в случае задержки передачи. Механизмы тайм-аута, повторной передачи, окна и подтверждения были вдохновлены аналогичными механизмами в [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol).

В другом направлении блоки сообщений, передаваемые от микроконтроллера к хосту, спроектированы так, чтобы не допускать ошибок, но они не имеют гарантированной передачи. (Ответы не должны быть повреждены, но они могут пропасть.) Это сделано для того, чтобы сохранить простоту реализации в микроконтроллере. Автоматической системы повторной передачи ответов не существует - предполагается, что код высокого уровня будет способен справиться со случайным отсутствием ответа (обычно путем повторного запроса содержимого или установки повторяющегося расписания передачи ответов). Поле номера последовательности в блоках сообщений, отправляемых хосту, всегда на единицу больше последнего полученного номера последовательности в блоках сообщений, полученных от хоста. Оно не используется для отслеживания последовательности блоков ответных сообщений.
