# Драйверы TMC

В этом документе содержится информация об использовании драйверов шаговых двигателей Trinamic (Тринамик) в режиме SPI/UART на Klipper.

Klipper также может использовать драйверы Trinamic в их "автономном режиме" (standalone mode). Однако, когда драйверы находятся в этом режиме, специальная настройка Klipper не требуется, и расширенные функции Klipper, обсуждаемые в этом документе, недоступны.

В дополнение к этому документу обязательно ознакомьтесь с[TMC driver config reference](Config_Reference.md#tmc-stepper-driver-configuration).

## Ток двигателя настройки

Более высокий ток драйвера увеличивает точность позиционирования и крутящий момент. Однако более высокий ток также увеличивает тепловыделение шагового двигателя и драйвера шагового двигателя. Если драйвер шагового двигателя перегревается, он отключается, и Klipper сообщает об ошибке. Если шаговый двигатель перегревается, он теряет крутящий момент и точность позиционирования. (Если он сильно нагревается, то может расплавить пластиковые детали, прикрепленные к нему или рядом с ним)

В качестве общего совета по настройке, предпочитайте более высокие значения тока, пока шаговый двигатель не нагревается слишком сильно и драйвер шагового двигателя не выдает предупреждений или ошибок. В целом, шаговый двигатель может быть теплым, но он не должен стать настолько горячим, чтобы к нему было больно прикасаться.

## Предпочтительнее не указывать hold_current

Если настроить `hold_current`, то драйвер TMC может уменьшить ток шагового двигателя, когда обнаружит, что шаговый двигатель не движется. Однако изменение тока двигателя может само по себе вызвать его движение. Это может произойти из-за "сил сдерживания" внутри шагового двигателя (постоянный магнит в роторе притягивается к железным зубцам в статоре) или из-за внешних сил на каретке оси.

Большинство шаговых двигателей не получат значительного преимущества от снижения тока во время обычной печати, потому что лишь немногие движения печати оставляют шаговый двигатель незадействованным достаточно долго, чтобы активировать функцию `hold_current`. И вряд ли кто-то захочет вносить тонкие артефакты в те немногие движения печати, которые оставляют шаговый двигатель без работы достаточно долго.

Если вы хотите уменьшить ток, подаваемый на двигатели во время запуска печати, подумайте о том, чтобы подать команду [SET_TMC_CURRENT](G-Codes.md#set_tmc_current) в макросе [START_PRINT](Slicers.md#klipper-gcode_macro) для регулировки тока до и после обычных движений печати.

Некоторые принтеры с выделенными двигателями Z, которые бездействуют во время обычных движений печати (без bed_mesh, без bed_tilt, без Z skew_correction, без печати в режиме "вазы" и т. д.), могут обнаружить, что двигатели Z работают холоднее при `hold_current`. Если это реализовано, то обязательно учитывайте этот тип необязательного движения оси Z во время выравнивания станины, зондирования станины, калибровки датчиков и т. п. Параметры `driver_TPOWERDOWN` и `driver_IHOLDDELAY` также должны быть откалиброваны соответствующим образом. Если вы не уверены, предпочтите не указывать `hold_current`.

## Установка режима "spreadCycle" против режима "stealthChop"

По умолчанию Klipper переводит драйверы TMC в режим "spreadCycle". Если драйвер поддерживает режим "stealthChop", то его можно включить, добавив `stealthchop_threshold: 999999` в секцию конфигурации TMC.

В целом, режим spreadCycle обеспечивает больший крутящий момент и большую точность позиционирования, чем режим stealthChop. Однако в некоторых принтерах режим stealthChop может издавать значительно меньше звукового шума.

Тесты, сравнивающие режимы, показали увеличение "задержки позиционирования" примерно на 75 % от полного шага при перемещениях с постоянной скоростью при использовании режима stealthChop (например, на принтере с 40 мм расстоянием_вращения и 200 шагами_на_вращение, отклонение позиции при перемещениях с постоянной скоростью увеличилось на ~0,150 мм). Однако эта "задержка в получении требуемой позиции" может не проявляться как существенный дефект печати, и можно предпочесть более спокойное поведение режима stealthChop.

Рекомендуется всегда использовать режим "spreadCycle" (не указывая `stealthchop_threshold`) или всегда использовать режим "stealthChop" (устанавливая `stealthchop_threshold` в 999999). К сожалению, драйверы часто выдают плохие и запутанные результаты, если режим меняется, когда двигатель имеет ненулевую скорость.

## Настройка интерполяции TMC приводит к небольшому отклонению положения

Настройка драйвера TMC `интерполяция` может уменьшить слышимый шум при движении принтера ценой внесения небольшой системной ошибки позиционирования. Эта системная ошибка позиционирования возникает из-за задержки драйвера при выполнении "шагов", которые посылает ему Klipper. При движении с постоянной скоростью эта задержка приводит к ошибке позиционирования почти в половину настроенного микрошага (точнее, ошибка равна половине расстояния микрошага минус 512-я часть расстояния полного шага). Например, для оси с расстоянием_вращения 40 мм, 200 шагов_на_вращение и 16 микрошагами системная ошибка, вносимая при перемещениях с постоянной скоростью, составляет ~0,006 мм.

Для достижения наилучшей точности позиционирования используйте режим spreadCycle и отключите интерполяцию (установите `interpolate: False` в конфигурации драйвера TMC). При такой конфигурации можно увеличить настройку `микрошага`, чтобы уменьшить слышимый шум при движении шаговика. Как правило, при установке микрошага `64` или `128` слышимый шум будет таким же, как при интерполяции, и при этом не будет вноситься систематическая ошибка позиционирования.

Если используется режим stealthChop, то неточность позиционирования от интерполяции мала по сравнению с неточностью позиционирования, вносимой режимом stealthChop. Поэтому настройка интерполяции не считается полезной в режиме stealthChop, и можно оставить интерполяцию в состоянии по умолчанию.

## Самонаведение без датчиков

Бессенсорная парковка позволяет перемещать ось без использования физического концевого выключателя. Вместо этого каретка на оси перемещается в механический предел, заставляя шаговый двигатель терять шаги. Драйвер шагового двигателя фиксирует потерю шага и сообщает об этом управляющему MCU (Klipper) путем переключения одного из выводов. Эта информация может быть использована Klipper в качестве конечной остановки оси.

В данном руководстве рассматривается настройка бездатчикового самонаведения для оси X вашего (картезианского) принтера. Тем не менее, она работает одинаково со всеми другими осями (требующими конечного упора). Конфигурировать и настраивать его следует для одной оси за один раз.

### Ограничения

Убедитесь, что ваши механические компоненты способны выдержать нагрузку от многократных ударов каретки о пределы оси. Особенно это касается винтов, которые могут создавать большое усилие. Наведение оси Z путем удара сопла о поверхность печати может оказаться не самой лучшей идеей. Для достижения наилучших результатов убедитесь, что каретка оси плотно соприкасается с ограничителем оси.

Кроме того, бессенсорное наведение может быть недостаточно точным для вашего принтера. В то время как наведение по осям X и Y на картезианской машине может работать хорошо, наведение по оси Z обычно недостаточно точно и может привести к неравномерной высоте первого слоя. Бессенсорное наведение дельта-принтера не рекомендуется из-за недостаточной точности.

Кроме того, обнаружение срыва шагового привода зависит от механической нагрузки на двигатель, тока двигателя и его температуры (сопротивления катушки).

Бессенсорное самонаведение лучше всего работает при средних скоростях вращения двигателя. При очень низких скоростях (менее 10 об/мин) двигатель не генерирует значительную обратную ЭДС, и TMC не может надежно обнаружить остановку двигателя. Далее, на очень высоких скоростях обратная ЭДС двигателя приближается к напряжению питания двигателя, поэтому TMC уже не может обнаружить остановку. Рекомендуется заглянуть в технический паспорт конкретного TMC. Там же можно найти более подробную информацию об ограничениях этой установки.

### Пререквизиты

Для использования бессенсорного самонаведения необходимо несколько предварительных условий:

1. Шаговый драйвер TMC с поддержкой StallGuard (tmc2130, tmc2209, tmc2660 или tmc5160).
1. Интерфейс SPI / UART драйвера TMC подключен к микроконтроллеру (автономный режим не работает).
1. Соответствующий вывод "DIAG" или "SG_TST" драйвера TMC подключается к микроконтроллеру.
1. Чтобы убедиться, что шаговые двигатели настроены и работают правильно, необходимо выполнить действия, описанные в документе [config checks](Config_checks.md).

### Тюнинг

Описанная здесь процедура состоит из шести основных этапов:

1. Выберите скорость самонаведения.
1. Настройте файл `printer.cfg`, чтобы включить бессенсорное самонаведение.
1. Найдите настройку stallguard с максимальной чувствительностью, которая успешно работает в домах.
1. Найдите настройку stallguard с наименьшей чувствительностью, которая позволяет успешно управлять домом одним касанием.
1. Обновить файл `printer.cfg` с нужными настройками stallguard.
1. Создайте или обновите макросы в файле `printer.cfg` для последовательной установки дома.

#### Выберите скорость наведения

Скорость самонаведения - важный выбор при выполнении бессенсорного самонаведения. Желательно использовать низкую скорость самонаведения, чтобы каретка не оказывала чрезмерного усилия на раму при контакте с концом рельса. Однако драйверы TMC не могут надежно обнаружить остановку на очень низких скоростях.

Хорошей отправной точкой для скорости самонаведения является то, что шаговый двигатель должен совершать полный оборот каждые две секунды. Для многих осей это будет `расстояние_вращения`, деленное на два. Например:

```
[stepper_x]
rotation_distance: 40
homing_speed: 20
...
```

#### Настройка файла printer.cfg для бессенсорного самонаведения

Чтобы отключить второе движение самонаведения, в разделе конфигурации `stepper_x` необходимо установить значение `homing_retract_dist` на ноль. Вторая попытка самонаведения не добавляет ценности при использовании бессенсорного самонаведения, она не будет работать надежно и запутает процесс настройки.

Убедитесь, что в разделе конфигурации драйвера TMC не задано значение `hold_current` (если задано значение hold_current, то после установления контакта двигатель останавливается, пока каретка прижата к концу рельса, и уменьшение тока в этом положении может привести к перемещению каретки - это приведет к ухудшению производительности и запутает процесс настройки)

Необходимо сконфигурировать контакты бессенсорного самонаведения и задать начальные настройки "stallguard". Пример конфигурации tmc2209 для оси X может выглядеть следующим образом:

```
[tmc2209 stepper_x]
diag_pin: ^PA1 # Установите на вывод MCU, подключенный к выводу TMC DIAG
driver_SGTHRS: 255 # 255 - наиболее чувствительное значение, 0 - наименее чувствительное
...

[stepper_x]
endstop_pin: tmc2209_stepper_x:virtual_endstop
homing_retract_dist: 0
...
```

Пример конфигурации tmc2130 или tmc5160 может выглядеть следующим образом:

```
[tmc2130 stepper_x]
diag1_pin: ^!PA1 # Контакт, подключенный к контакту TMC DIAG1 (или используйте diag0_pin / DIAG0 pin)
driver_SGT: -64 # -64 - наиболее чувствительное значение, 63 - наименее чувствительное
...

[stepper_x].
endstop_pin: tmc2130_stepper_x:virtual_endstop
homing_retract_dist: 0
...
```

Пример конфигурации tmc2660 может выглядеть следующим образом:

```
[tmc2660 stepper_x]
driver_SGT: -64 # -64 - наиболее чувствительное значение, 63 - наименее чувствительное
...

[stepper_x]
endstop_pin: ^PA1 # Контакт подключен к контакту TMC SG_TST
homing_retract_dist: 0
...
```

В приведенных примерах показаны только настройки, характерные для бессенсорного самонаведения. Все доступные параметры смотрите в разделе [config reference](Config_Reference.md#tmc-stepper-driver-configuration).

#### Найдите максимальную чувствительность, которая успешно справляется с домами

Установите каретку вблизи центра рельса. С помощью команды SET_TMC_FIELD установите максимальную чувствительность. Для tmc2209:

```
SET_TMC_FIELD STEPPER=stepper_x FIELD=SGTHRS VALUE=255
```

Для tmc2130, tmc5160 и tmc2660:

```
SET_TMC_FIELD STEPPER=stepper_x FIELD=sgt VALUE=-64
```

Затем подайте команду `G28 X0` и убедитесь, что ось не двигается вообще или быстро останавливается. Если ось не останавливается, подайте команду `M112` для остановки принтера - что-то не так с подключением или конфигурацией контактов diag/sg_tst, и это необходимо исправить, прежде чем продолжать.

Затем постоянно уменьшайте чувствительность параметра `VALUE` и снова выполните команды `SET_TMC_FIELD` `G28 X0`, чтобы найти максимальную чувствительность, при которой каретка успешно перемещается до конечной остановки и останавливается. (Для драйверов tmc2209 это будет уменьшение SGTHRS, для других драйверов - увеличение sgt). Обязательно начинайте каждую попытку с каретки, находящейся около центра рельса (при необходимости выдайте `M84` и вручную переместите каретку в центр). Должна быть найдена максимальная чувствительность, при которой каретка перемещается надежно (настройки с более высокой чувствительностью приводят к небольшому перемещению или его отсутствию). Запишите найденное значение как *maximum_sensitivity*. (Если минимально возможная чувствительность (SGTHRS=0 или sgt=63) достигается без какого-либо движения каретки, значит, что-то не так с подключением или конфигурацией контактов diag/sg_tst, и это необходимо исправить, прежде чем продолжать)

При поиске параметра maximum_sensitivity может оказаться удобным переходить к различным настройкам VALUE (так, чтобы пересечь параметр VALUE). При этом следует быть готовым к подаче команды `M112` для остановки принтера, поскольку настройка с очень низкой чувствительностью может привести к тому, что ось будет неоднократно "ударяться" о торец направляющей.

Не забудьте подождать пару секунд между каждой попыткой наведения. После того как драйвер TMC обнаружит сбой, ему может потребоваться некоторое время, чтобы очистить свой внутренний индикатор и обнаружить новый сбой.

Во время этих тестов настройки, если команда `G28 X0` не перемещается до конца оси, то будьте осторожны с подачей любых обычных команд перемещения (например, `G1`). Klipper не будет иметь правильного представления о положении каретки, и команда перемещения может привести к нежелательным и запутанным результатам.

#### Найдите самую низкую чувствительность, которая устанавливается одним касанием

При наведении с найденным значением *максимальной_чувствительности* ось должна двигаться к концу рельса и останавливаться "одним касанием" - то есть не должно быть звука "щелчка" или "стука". (Если при максимальной_чувствительности раздается стук или щелчок, то скорость самонаведения может быть слишком низкой, ток драйвера может быть слишком низким, или бессенсорное самонаведение может быть не лучшим выбором для данной оси)

Следующий шаг - снова постоянно перемещать каретку в положение, близкое к центру рельса, уменьшить чувствительность и выполнить команды `SET_TMC_FIELD` `G28 X0` - теперь цель состоит в том, чтобы найти наименьшую чувствительность, при которой каретка успешно наводится "одним касанием". То есть, она не "бьется" и не "щелкает" при контакте с концом рельса. Запишите найденное значение как *minimum_sensitivity*.

#### Обновление файла printer.cfg со значением чувствительности

Найдя *максимальную_чувствительность* и *минимальную_чувствительность*, воспользуйтесь калькулятором, чтобы получить рекомендуемую чувствительность как *минимальная_чувствительность + (максимальная_чувствительность - минимальная_чувствительность)/3*. Рекомендуемая чувствительность должна находиться в диапазоне между минимальной и максимальной, но немного ближе к минимальной. Округлите итоговое значение до ближайшего целого числа.

Для tmc2209 задайте в конфигурации значение `driver_SGTHRS`, для других драйверов TMC задайте в конфигурации значение `driver_SGT`.

Если диапазон между *максимальной_чувствительностью* и *минимальной_чувствительностью* мал (например, менее 5), это может привести к нестабильному наведению. Более высокая скорость наведения может увеличить диапазон и сделать работу более стабильной.

Обратите внимание, что если изменится ток драйвера, скорость наведения или произойдут заметные изменения в аппаратной части принтера, то процесс настройки придется выполнить заново.

#### Использование макросов при наведении

После завершения бессенсорного наведения каретка будет прижата к концу рельса, и шаговый механизм будет оказывать усилие на раму до тех пор, пока каретка не отойдет. Хорошей идеей будет создать макрос для установки оси и немедленного перемещения каретки от конца рельса.

Макросу желательно сделать паузу не менее 2 секунд перед началом бессенсорного наведения (или убедиться, что в течение 2 секунд на шаговом механизме не было движения). Без задержки возможно, что внутренний флаг остановки драйвера все еще установлен после предыдущего движения.

Также может быть полезно, чтобы этот макрос устанавливал ток драйвера перед наведением и устанавливал новый ток после того, как каретка отойдет.

Пример макроса может выглядеть следующим образом:

```
[gcode_macro SENSORLESS_HOME_X]
gcode:
    {% set HOME_CUR = 0.700 %}
    {% set driver_config = printer.configfile.settings['tmc2209 stepper_x'] %}
    {% set RUN_CUR = driver_config.run_current %}
    # Установка тока для бессенсорного самонаведения
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}
    # Пауза, чтобы убедиться, что флаг остановки драйвера сброшен
    G4 P2000
    # Дом
    G28 X0
    # Отъезд
    G90
    G1 X5 F1200
    # Установите ток во время печати
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}
```

Полученный макрос можно вызвать из раздела конфигурации [homing_override](Config_Reference.md#homing_override) или из макроса [START_PRINT](Slicers.md#klipper-gcode_macro).

Обратите внимание, что если ток драйвера во время самонаведения изменится, то процесс настройки следует запустить снова.

### Советы по бессенсорному самонаведению на CoreXY

Можно использовать бессенсорное самонаведение на каретки X и Y принтера CoreXY. Klipper использует шаговый механизм `[stepper_x]` для обнаружения срыва при наведении каретки X и использует шаговый механизм `[stepper_y]` для обнаружения срыва при наведении каретки Y.

Используйте руководство по настройке, описанное выше, чтобы найти подходящую "чувствительность срыва" для каждой каретки, но помните о следующих ограничениях:

1. При использовании бессенсорного самонаведения на CoreXY убедитесь, что для обоих шаговиков не настроен `hold_current`.
1. При настройке убедитесь, что каретки X и Y находятся в центре своих рельсов перед каждой попыткой возврата в исходное положение.
1. После завершения настройки при самонаведении по осям X и Y используйте макросы, чтобы обеспечить сначала самонаведение по одной оси, затем отведите каретку от ограничителя оси, сделайте паузу не менее 2 секунд, а затем начните самонаведение по другой каретке. Перемещение в сторону от оси позволяет избежать самонаведения одной оси, в то время как другая прижата к границе оси (что может исказить обнаружение срыва). Пауза необходима для того, чтобы флаг срыва привода был сброшен перед повторным наведением.

Пример макроса самонаведения CoreXY может выглядеть следующим образом:

```
[gcode_macro HOME]
gcode:
    G90
    # Дом Z
    G28 Z0
    G1 Z10 F1200
    # Дом Y
    G28 Y0
    G1 Y5 F1200
    # Дом X
    G4 P2000
    G28 X0
    G1 X5 F1200
```

## Запрос и диагностика настроек драйвера

Команда `[DUMP_TMC](G-Codes.md#dump_tmc) является полезным инструментом при настройке и диагностике драйверов. Она сообщает обо всех полях, сконфигурированных Klipper, а также обо всех полях, которые могут быть запрошены из драйвера.

Все указанные поля определены в техническом описании Trinamic для каждого драйвера. Эти технические описания можно найти на сайте [Trinamic](https://www.trinamic.com/). Получите и просмотрите технический паспорт Trinamic для драйвера, чтобы интерпретировать результаты DUMP_TMC.

## Настройка параметров драйвера_XXX

Klipper поддерживает настройку многих низкоуровневых полей драйвера с помощью параметров `driver_XXX`. В справочнике [TMC driver config reference](Config_Reference.md#tmc-stepper-driver-configuration) приведен полный список полей, доступных для каждого типа драйверов.

Кроме того, почти все поля могут быть изменены во время выполнения программы с помощью команды [SET_TMC_FIELD](G-Codes.md#set_tmc_field).

Каждое из этих полей определено в техническом описании Trinamic для каждого драйвера. Эти технические паспорта можно найти на сайте [Trinamic](https://www.trinamic.com/).

Обратите внимание, что в даташитах Trinamic иногда используются формулировки, в которых можно спутать высокоуровневую настройку (например, "конец гистерезиса") со значением низкоуровневого поля (например, "HEND"). В Klipper, `driver_XXX` и SET_TMC_FIELD всегда устанавливают значение низкоуровневого поля, которое фактически записывается в драйвер. Так, например, если в техническом описании Trinamic указано, что для получения "конца гистерезиса" 0 в поле HEND должно быть записано значение 3, то установите `driver_HEND=3`, чтобы получить значение высокого уровня 0.

## Общие вопросы

### Можно ли использовать режим stealthChop на экструдере с опережением давления?

Многие люди успешно используют режим "stealthChop" с опережением давления в Klipper. В Klipper реализовано [плавное опережение давления](Kinematics.md#pressure-advance), которое не вносит никаких мгновенных изменений в скорость.

Однако режим "stealthChop" может снижать крутящий момент двигателя и/или увеличивать его нагрев. Этот режим может подойти или не подойти для вашего конкретного принтера.

### Я продолжаю получать ошибки "Unable to read tmc uart 'stepper_x' register IFCNT"?

Это происходит, когда Klipper не может установить связь с драйвером tmc2208 или tmc2209.

Убедитесь, что питание двигателя включено, так как драйверу шагового двигателя обычно требуется питание двигателя, прежде чем он сможет взаимодействовать с микроконтроллером.

Если эта ошибка возникает после первой прошивки Klipper, то, возможно, драйвер шагового механизма был запрограммирован в состоянии, не совместимом с Klipper. Чтобы сбросить это состояние, отключите питание принтера на несколько секунд (физически отсоедините оба разъема USB и питания).

В противном случае эта ошибка обычно является результатом неправильного подключения выводов UART или неправильной конфигурации Klipper для настроек выводов UART.

### Я продолжаю получать ошибки "Unable to write tmc spi 'stepper_x' register ..."?

Это происходит, когда Klipper не может установить связь с драйвером tmc2130 или tmc5160.

Убедитесь, что питание двигателя включено, так как драйверу шагового двигателя обычно требуется питание двигателя, прежде чем он сможет взаимодействовать с микроконтроллером.

В противном случае эта ошибка обычно является результатом неправильного подключения SPI, неправильной конфигурации настроек SPI в Klipper или неполной конфигурации устройств на шине SPI.

Обратите внимание, что если драйвер находится на общей SPI-шине с несколькими устройствами, то обязательно полностью сконфигурируйте в Klipper каждое устройство на этой общей SPI-шине. Если устройство на общей шине SPI не сконфигурировано, оно может некорректно реагировать на команды, не предназначенные для него, и нарушить связь с предназначенным для него устройством. Если на общей шине SPI есть устройство, которое не может быть сконфигурировано в Klipper, используйте секцию конфигурации [static_digital_output](Config_Reference.md#static_digital_output) для установки высокого уровня на пин CS неиспользуемого устройства (чтобы оно не пыталось использовать шину SPI). Схема платы часто является полезным справочным материалом для поиска устройств на шине SPI и их соответствующих выводов.

### Почему я получил ошибку "TMC сообщает об ошибке: ..."?

Этот тип ошибки указывает на то, что драйвер TMC обнаружил проблему и отключился. То есть драйвер перестал удерживать позицию и игнорирует команды перемещения. Если Klipper обнаружит, что активный драйвер отключился, он переведет принтер в состояние "выключения".

Также возможно, что отключение **TMC сообщает об ошибке** происходит из-за ошибок SPI, которые не позволяют установить связь с драйвером (на tmc2130, tmc5160 или tmc2660). В этом случае в сообщении о состоянии драйвера обычно отображается `00000000` или `ffffff` - например: `TMC сообщает об ошибке: DRV_STATUS: ffffffff ...` ИЛИ `TMC сообщает об ошибке: READRSP@RDSEL2: 00000000 ...`. Такой сбой может быть связан с проблемой подключения SPI, а также с самосбросом или сбоем драйвера TMC.

Некоторые распространенные ошибки и советы по их диагностике:

#### TMC сообщает об ошибке: `... ot=1(OvertempError!)`

Это означает, что драйвер двигателя отключился из-за перегрева. Типичными решениями являются уменьшение тока шагового двигателя, увеличение охлаждения драйвера шагового двигателя и/или увеличение охлаждения шагового двигателя.

#### TMC сообщает об ошибке: `... ShortToGND` ИЛИ `ShortToSupply`

Это означает, что драйвер отключился, поскольку обнаружил очень высокий ток, проходящий через драйвер. Это может указывать на ослабление или замыкание провода к шаговому двигателю или внутри самого шагового двигателя.

Эта ошибка также может возникнуть, если используется режим stealthChop и драйвер TMC не в состоянии точно предсказать механическую нагрузку на двигатель. (Если драйвер делает плохой прогноз, то он может послать слишком большой ток через двигатель и спровоцировать собственное обнаружение перегрузки по току). Чтобы проверить это, отключите режим stealthChop и проверьте, продолжаются ли ошибки.

#### TMC сообщает об ошибке: `... сброс=1(Сброс)` ИЛИ `CS_ACTUAL=0(Сброс?)` ИЛИ `SE=0(Сброс?)`

Это означает, что драйвер сбросился в середине печати. Это может быть вызвано проблемами с напряжением или проводкой.

#### TMC сообщает об ошибке: `... uv_cp=1( Пониженное напряжение!)`

Это означает, что драйвер обнаружил событие низкого напряжения и отключился. Это может быть вызвано проблемами с проводкой или питанием.

### Как настроить режим spreadCycle/coolStep/etc. на моих драйверах?

На сайте [Trinamic](https://www.trinamic.com/) есть руководства по настройке драйверов. Эти руководства часто являются техническими, низкоуровневыми и могут требовать специализированного оборудования. Тем не менее, они являются лучшим источником информации.
