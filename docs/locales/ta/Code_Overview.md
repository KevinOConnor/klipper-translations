# குறியீடு கண்ணோட்டம்

இந்த ஆவணம் ஒட்டுமொத்த குறியீடு தளவமைப்பு மற்றும் கிளிப்பரின் முக்கிய குறியீடு ஓட்டத்தை விவரிக்கிறது.

## அடைவு தளவமைப்பு

** SRC/** கோப்பகத்தில் மைக்ரோ-கன்ட்ரோலர் குறியீட்டிற்கான சி மூலத்தைக் கொண்டுள்ளது. ** src/atsam/**, ** src/atsamd/**, ** src/avr/**, ** src/linux/**, ** src/lpc176x/**, ** src/ PRU/**, மற்றும் ** SRC/STM32/** கோப்பகங்கள் கட்டிடக்கலை குறிப்பிட்ட மைக்ரோ-கண்ட்ரோலர் குறியீட்டைக் கொண்டுள்ளன. ** எச்.ஆர்.சி/சிமுலேட்டர்/** குறியீடு ச்டப்களைக் கொண்டுள்ளது, இது மைக்ரோ-கன்ட்ரோலரை மற்ற கட்டமைப்புகளில் சோதிக்க அனுமதிக்கிறது. ** SRC/generic/** கோப்பகத்தில் வெவ்வேறு கட்டமைப்புகளில் பயனுள்ளதாக இருக்கும் உதவி குறியீடு உள்ளது. தற்போதைய கட்டிடக்கலை கோப்பகத்தில் (எ.கா., எச்.ஆர்.சி/ஏ.வி.ஆர்/சில ஃபைல்.எச்) மற்றும் பின்னர் பொதுவான கோப்பகத்தில் (எ.கா., எச்.ஆர்.சி/செனரிக்/சில ஃபைல்.எச்) பார்க்க "பலகை/சில ஃபைல்.எச்" அடங்கும்.

** கிளிப்பி/** கோப்பகத்தில் புரவலன் மென்பொருள் உள்ளது. புரவலன் மென்பொருளில் பெரும்பாலானவை பைதானில் எழுதப்பட்டுள்ளன, இருப்பினும் ** கிளிப்பி/செல்பர்/** கோப்பகத்தில் சில சி குறியீடு உதவியாளர்கள் உள்ளனர். ** கிளிப்பி/இயக்கவியல்/** கோப்பகத்தில் ரோபோ இயக்கவியல் குறியீடு உள்ளது. ** கிளிப்பி/எக்ச்ட்ராச்/** கோப்பகத்தில் புரவலன் குறியீடு விரிவாக்கக்கூடிய "தொகுதிகள்" உள்ளன.

** lib/** கோப்பகத்தில் வெளிப்புற 3-தரப்பு நூலகக் குறியீடு உள்ளது, இது சில இலக்குகளை உருவாக்க தேவை.

** கட்டமைப்பு/** கோப்பகத்தில் எடுத்துக்காட்டு அச்சுப்பொறி உள்ளமைவு கோப்புகள் உள்ளன.

** ச்கிரிப்ட்கள்/** கோப்பகத்தில் மைக்ரோ-கன்ட்ரோலர் குறியீட்டை தொகுக்க பயனுள்ள கட்டட நேர ச்கிரிப்ட்கள் உள்ளன.

** சோதனை/** கோப்பகத்தில் தானியங்கு சோதனை வழக்குகள் உள்ளன.

தொகுப்பின் போது, உருவாக்கம் ஒரு ** அவுட்/** கோப்பகத்தை உருவாக்கக்கூடும். இதில் தற்காலிக உருவாக்க நேர பொருள்கள் உள்ளன. கட்டப்பட்ட இறுதி மைக்ரோ-கன்ட்ரோலர் பொருள் ஏ.வி.ஆர் மற்றும் ** அவுட்/கிளிப்பர்.பின் ** கையில் ** அவுட்/கிளிப்பர்.எக்ச் ** ஆகும்.

## மைக்ரோ-கண்ட்ரோலர் குறியீடு ஓட்டம்

மைக்ரோ-கன்ட்ரோலர் குறியீட்டின் செயல்பாடு கட்டமைப்பு குறிப்பிட்ட குறியீட்டில் (எ.கா., ** SRC/AVR/MAIN.C **) தொடங்குகிறது, இது இறுதியில் ** SRC/Sall.C ** இல் அமைந்துள்ள Sape_Main () ஐ அழைக்கிறது. Seplow_Init () மேக்ரோவுடன் குறிக்கப்பட்ட அனைத்து செயல்பாடுகளையும் இயக்குவதன் மூலம் Sapel_main () குறியீடு தொடங்குகிறது. இது டெக்_ டாச்க் () மேக்ரோவுடன் குறிக்கப்பட்ட அனைத்து செயல்பாடுகளையும் மீண்டும் மீண்டும் இயக்குகிறது.

** src/command.c ** இல் அமைந்துள்ள கட்டளை_டிச்பாட்ச் () முக்கிய பணி செயல்பாடுகளில் ஒன்று. இந்த செயல்பாடு போர்டு குறிப்பிட்ட உள்ளீடு/வெளியீட்டுக் குறியீட்டிலிருந்து அழைக்கப்படுகிறது (எ.கா. உள்ளீட்டு ச்ட்ரீமில். கட்டளை செயல்பாடுகள் pect_command () மேக்ரோவைப் பயன்படுத்தி அறிவிக்கப்படுகின்றன (மேலும் தகவலுக்கு [நெறிமுறை] (நெறிமுறை. Md) ஆவணத்தைப் பார்க்கவும்).

பணி, init மற்றும் கட்டளை செயல்பாடுகள் எப்போதும் இயக்கப்பட்ட குறுக்கீடுகளுடன் இயங்குகின்றன (இருப்பினும், தேவைப்பட்டால் அவை தற்காலிகமாக குறுக்கீடுகளை முடக்கலாம்). இந்த செயல்பாடுகள் நீண்ட இடைநிறுத்தங்கள், தாமதங்கள் அல்லது குறிப்பிடத்தக்க நேரம் நீடிக்கும் வேலைகளைத் தவிர்க்க வேண்டும். . டைமர்களை திட்டமிடுவதன் மூலம் குறிப்பிட்ட நேரங்கள்.

TIMER செயல்பாடுகள் Sell_add_timer () ஐ அழைப்பதன் மூலம் திட்டமிடப்பட்டுள்ளன (** src/seld.c ** இல் அமைந்துள்ளது). கோரப்பட்ட கடிகார நேரத்தில் கொடுக்கப்பட்ட செயல்பாடு அழைக்கப்படுவதற்கு திட்டமிடல் குறியீடு ஏற்பாடு செய்யும். நேரங்குறிகருவி குறுக்கீடுகள் ஆரம்பத்தில் ஒரு கட்டிடக்கலை குறிப்பிட்ட குறுக்கீடு கையாளுபவரில் கையாளப்படுகின்றன (எ.கா. நேரங்குறிகருவி குறுக்கீடு அட்டவணை நேரங்குறிகருவி செயல்பாடுகளை செயல்படுத்த வழிவகுக்கிறது. நேரங்குறிகருவி செயல்பாடுகள் எப்போதும் குறுக்கீடுகளுடன் முடக்கப்பட்டுள்ளன. நேரங்குறிகருவி செயல்பாடுகள் எப்போதும் ஒரு சில மைக்ரோ விநாடிகளுக்குள் முடிக்க வேண்டும். நேரங்குறிகருவி நிகழ்வு முடிந்ததும், செயல்பாடு தன்னை மறுபரிசீலனை செய்ய தேர்வு செய்யலாம்.

ஒரு பிழை கண்டறியப்பட்டால், குறியீடு பணிநிறுத்தம் () (** src/seld.c ** இல் அமைந்துள்ள Sape_Shutdown () என்று அழைக்கும் மேக்ரோ. பணிநிறுத்தம் () ஐத் தூண்டுவது டெக்_சட் பேரூர் () மேக்ரோவுடன் குறியிடப்பட்ட அனைத்து செயல்பாடுகளையும் இயக்குகிறது. பணிநிறுத்தம் செயல்பாடுகள் எப்போதும் குறுக்கீடுகளுடன் இயங்கும்.

மைக்ரோ-கன்ட்ரோலரின் செயல்பாட்டின் பெரும்பகுதி பொது நோக்கத்திற்கான உள்ளீடு/வெளியீட்டு ஊசிகளுடன் (சிபிஐஓ) பணியாற்றுவதை உள்ளடக்குகிறது. உயர் மட்ட பணிக் குறியீட்டிலிருந்து குறைந்த-நிலை கட்டமைப்பு குறிப்பிட்ட குறியீட்டை சுருக்கிக் கொள்வதற்காக, அனைத்து GPIO நிகழ்வுகளும் கட்டிடக்கலை குறிப்பிட்ட ரேப்பர்களில் செயல்படுத்தப்படுகின்றன (எ.கா., ** SRC/AVR/GPIO.C **). குறியீடு சி.சி.சியின் "-flto -fwhole-program" தேர்வுமுறையுடன் தொகுக்கப்பட்டுள்ளது, இது தொகுப்புக் அலகுகளில் செயல்பாடுகளைத் தூண்டுவதற்கான ஒரு சிறந்த வேலையைச் செய்கிறது, எனவே இந்த சிறிய GPIO செயல்பாடுகளில் பெரும்பாலானவை அவற்றின் அழைப்பாளர்களிடையே வைக்கப்படுகின்றன, மேலும் பயன்படுத்துவதற்கு ரன்-டைம் செலவு இல்லை அவர்கள்.

## கிளிப்பி குறியீடு கண்ணோட்டம்

புரவலன் குறியீடு (கிளிப்பி) மைக்ரோ-கன்ட்ரோலருடன் சோடியாக குறைந்த விலை கணினியில் (ராச்பெர்ரி பை போன்றவை) இயக்கும் நோக்கம் கொண்டது. குறியீடு முதன்மையாக பைத்தானில் எழுதப்பட்டுள்ளது, இருப்பினும் இது சி குறியீட்டில் சில செயல்பாடுகளை செயல்படுத்த CFFI ஐப் பயன்படுத்துகிறது.

ஆரம்ப சாவுஒறுப்பு ** klippy/klippy.py ** இல் தொடங்குகிறது. இது கட்டளை-வரி வாதங்களைப் படிக்கிறது, அச்சுப்பொறி கட்டமைப்பு கோப்பைத் திறக்கிறது, முதன்மையான அச்சுப்பொறி பொருள்களை நிறுவுகிறது, மேலும் தொடர் இணைப்பைத் தொடங்குகிறது. சி-கோட் கட்டளைகளின் முக்கிய செயல்பாடு ** klippy/gcode.py ** இல் செயல்முறை_காமண்ட்ச் () முறையில் உள்ளது. இந்த குறியீடு சி-குறியீடு கட்டளைகளை அச்சுப்பொறி பொருள் அழைப்புகளாக மொழிபெயர்க்கிறது, இது மைக்ரோ-கன்ட்ரோலரில் செயல்படுத்தப்பட வேண்டிய கட்டளைகளுக்கு அடிக்கடி மொழிபெயர்க்கப்பட்டுள்ளது (மைக்ரோ-கன்ட்ரோலர் குறியீட்டில் டெக்_காம்மண்ட் மேக்ரோ வழியாக அறிவிக்கப்பட்டபடி).

கிளிப்பி புரவலன் குறியீட்டில் நான்கு நூல்கள் உள்ளன. முதன்மையான நூல் உள்வரும் GCODE கட்டளைகளை கையாளுகிறது. இரண்டாவது நூல் (இது முற்றிலும் ** கிளிப்பி/செல்பர்/சீரியால்கியூ. பைதான் குறியீட்டில் உள்ள மைக்ரோ-கன்ட்ரோலரிலிருந்து மறுமொழி செய்திகளை செயலாக்க மூன்றாவது நூல் பயன்படுத்தப்படுகிறது (பார்க்க ** கிளிப்பி/சீரியல்எச்.டி.எல்.ஒய் **). நான்காவது நூல் பிழைத்திருத்த செய்திகளை பதிவுக்கு எழுதுகிறது (** கிளிப்பி/queuealogger.py ** ஐப் பார்க்கவும்) இதனால் மற்ற நூல்கள் ஒருபோதும் பதிவு எழுதுகின்றன.

## நகரும் கட்டளையின் குறியீடு ஓட்டம்

கிளிப்பி ஓச்டுக்கு "சி 1" கட்டளை அனுப்பப்படும்போது ஒரு பொதுவான அச்சுப்பொறி இயக்கம் தொடங்குகிறது, மேலும் மைக்ரோ-கன்ட்ரோலரில் தொடர்புடைய படி பருப்பு வகைகள் தயாரிக்கப்படும் போது அது நிறைவு செய்கிறது. இந்த பிரிவு ஒரு பொதுவான நகர்வு கட்டளையின் குறியீடு ஓட்டத்தை கோடிட்டுக் காட்டுகிறது. [இயக்கவியல்] (இயக்கவியல். எம்.டி) ஆவணம் நகர்வுகளின் இயக்கவியல் பற்றிய கூடுதல் தகவல்களை வழங்குகிறது.

* நகரும் கட்டளைக்கான செயலாக்கம் GCODE.PY இல் தொடங்குகிறது. Gcode.py இன் குறிக்கோள் சி-குறியீட்டை உள் அழைப்புகளாக மொழிபெயர்ப்பதாகும். ஒரு ஐயா 1 கட்டளை கிளிப்பி/எக்ச்ட்ராக்கள்/gcode_move.py இல் cmd_g1 () ஐ அழைக்கும். Gcode_move.py குறியீடு தோற்றத்தில் மாற்றங்களை கையாளுகிறது (எ.கா., G92), உறவினர் Vs முழுமையான நிலைகளில் (எ.கா., G90) மாற்றங்கள் மற்றும் அலகு மாற்றங்கள் (எ.கா., F6000 = 100 மிமீ/வி). ஒரு நகர்வுக்கான குறியீடு பாதை: `_PROCESS_DATA () -> _PROCESS_COMMANDS () -> CMD_G1 ()`. இறுதியில் கருவிஎட் வகுப்பு உண்மையான கோரிக்கையை செயல்படுத்த பயன்படுத்தப்படுகிறது: `cmd_g1 () -> கருவிஎட்.மோவ் ()`
* கருவிஎச் வகுப்பு (கருவியில்) "தோற்றத்தை" கையாளுகிறது மற்றும் அச்சிடும் செயல்களின் நேரத்தைக் கண்காணிக்கிறது. ஒரு நகர்வுக்கான முக்கிய குறியீட்டு முறை: `கருவிஎட்.

   * கருவியின் அளவுருக்கள் (கார்ட்டீசியன் இடத்திலும், விநாடிகள் மற்றும் மில்லிமீட்டர்களின் அலகுகளிலும்) ஒரு நகர்வு () பொருளை உருவாக்குகிறது.
   * ஒவ்வொரு நகர்வையும் (`கருவிஎட் () -> கின்.செக்_மோவ் ()`) தணிக்கை செய்ய இயக்கவியல் வகுப்பிற்கு வாய்ப்பு வழங்கப்படுகிறது. இயக்கவியல் வகுப்புகள் கிளிப்பி/ இயக்கவியல்/ கோப்பகத்தில் அமைந்துள்ளன. நகர்வு செல்லுபடியாகாவிட்டால் Check_move () குறியீடு பிழையை எழுப்பக்கூடும். செக்_மோவ் () வெற்றிகரமாக முடிந்தால், அடிப்படை இயக்கவியல் நகர்வைக் கையாள முடியும்.
   * Lookaheadqueue.add_move () நகரும் பொருளை "தோற்றமளிக்கும்" வரிசையில் வைக்கிறது.
   * Lookaheadqueue.flush () ஒவ்வொரு நகர்வின் தொடக்க மற்றும் இறுதி வேகங்களை தீர்மானிக்கிறது.
   * Move.set_junction () ஒரு நகர்வில் "ட்ரெப்சாய்டு செனரேட்டரை" செயல்படுத்துகிறது. "ட்ரெப்சாய்டு செனரேட்டர்" ஒவ்வொரு அசைவையும் மூன்று பகுதிகளாக உடைக்கிறது: ஒரு நிலையான முடுக்கம் கட்டம், அதைத் தொடர்ந்து ஒரு நிலையான விரைவு கட்டம், அதைத் தொடர்ந்து ஒரு நிலையான வீழ்ச்சி கட்டம். ஒவ்வொரு நகர்விலும் இந்த வரிசையில் இந்த மூன்று கட்டங்கள் உள்ளன, ஆனால் சில கட்டங்கள் சுழிய காலமாக இருக்கலாம்.
   * கருவிஎட். அனைத்து தகவல்களும் நகர்வு () வகுப்பில் சேமிக்கப்பட்டு, கார்ட்டீசியன் இடத்தில் மில்லிமீட்டர் மற்றும் விநாடிகளின் அலகுகளில் உள்ளன.
* ஒவ்வொரு ச்டெப்பருக்கும் படி நேரங்களை உருவாக்க கிளிப்பர் ஒரு [மறுசீரமைப்பு தீர்வி] (https://en.wikipedia.org/wiki/root-finding_algorithm) ஐப் பயன்படுத்துகிறார். செயல்திறன் காரணங்களுக்காக, ச்டெப்பர் துடிப்பு நேரங்கள் சி குறியீட்டில் உருவாக்கப்படுகின்றன. நகர்வுகள் முதலில் "ட்ரெப்சாய்டு மோசன் வரிசையில்" வைக்கப்பட்டுள்ளன: `கருவித்தொகுப்பு. படி நேரங்கள் பின்னர் உருவாக்கப்படுகின்றன: `கருவிஎட். /itersolve.c). ஒரு காலத்திலிருந்து ஒரு ச்டெப்பர் நிலையை கணக்கிடும் ஒரு செயல்பாட்டைக் கொடுக்கப்பட்ட படி நேரங்களைக் கண்டுபிடிப்பதே மறு செய்கை தீர்வின் குறிக்கோள். ச்டெப்பர் நிலை தேற்றம் ச்டெப்பரில் அடுத்த கட்டத்தின் விரும்பிய நிலையை திரும்பும் வரை பல்வேறு முறை மீண்டும் மீண்டும் "யூகிப்பதன்" மூலம் இது செய்யப்படுகிறது. ஒவ்வொரு யூகத்திலிருந்தும் தயாரிக்கப்படும் பின்னூட்டங்கள் எதிர்கால யூகங்களை மேம்படுத்த பயன்படுகின்றன, இதனால் செயல்முறை விரைவாக விரும்பிய நேரத்திற்கு மாறுகிறது. கினெமாடிக் ச்டெப்பர் நிலை சூத்திரங்கள் கிளிப்பி/ செல்பர்/ கோப்பகத்தில் அமைந்துள்ளன (எ.கா.
* எக்ச்ட்ரூடர் அதன் சொந்த இயக்கவியல் வகுப்பில் கையாளப்படுகிறது என்பதை நினைவில் கொள்க: `கருவிஎட். நகர்வு () வகுப்பு சரியான இயக்க நேரத்தைக் குறிப்பிடுவதால், குறிப்பிட்ட நேரத்துடன் படி பருப்பு வகைகள் மைக்ரோ-கன்ட்ரோலருக்கு அனுப்பப்படுவதால், எக்ச்ட்ரூடர் வகுப்பால் தயாரிக்கப்படும் ச்டெப்பர் இயக்கங்கள் குறியீடு தனித்தனியாக வைக்கப்பட்டிருந்தாலும் தலை இயக்கத்துடன் ஒத்திசைக்கப்படும்.
* மறுசீரமைப்பு தீர்வி அவர்கள் ஒரு வரிசையில் சேர்க்கப்படும் படி நேரங்களைக் கணக்கிட்ட பிறகு: `itersolve_gen_steps_range () -> stepampress_append ()` (கிளிப்பி/செல்பர்/ச்டெபோகிரிபிரச்.சியில்). வரிசை (struct stretcompress.queue) ஒவ்வொரு அடியிலும் தொடர்புடைய மைக்ரோ-கன்ட்ரோலர் கடிகார எதிர் நேரங்களை சேமிக்கிறது. இங்கே "மைக்ரோ-கன்ட்ரோலர் கடிகார கவுண்டர்" மதிப்பு மைக்ரோ-கன்ட்ரோலரின் வன்பொருள் கவுண்டருக்கு நேரடியாக ஒத்திருக்கிறது-இது மைக்ரோ-கன்ட்ரோலர் கடைசியாக இயங்கும் போது தொடர்புடையது.
* அடுத்த முக்கிய படி படிகளை சுருக்க வேண்டும்: `StepCompress_flush () -> சுருக்க_பிசெக்ட்_ஏடி ()` (கிளிப்பி/செல்ஃபர்/ச்டெப்அக்ரேச்.சியில்). இந்த குறியீடு முந்தைய கட்டத்தில் கட்டப்பட்ட ச்டெப்பர் படி நேரங்களின் பட்டியலுக்கு ஒத்த மைக்ரோ-கன்ட்ரோலர் "Queue_step" கட்டளைகளின் வரிசையை உருவாக்கி குறியீடாக்குகிறது. இந்த "queue_step" கட்டளைகள் பின்னர் வரிசையில் வரிசையில் நிற்கின்றன, முன்னுரிமை அளிக்கப்படுகின்றன, மேலும் மைக்ரோ-கன்ட்ரோலருக்கு அனுப்பப்படுகின்றன (StepCompress.c
* மைக்ரோ-கன்ட்ரோலரில் Queue_step கட்டளைகளை செயலாக்குவது SRC/command.c இல் தொடங்குகிறது, இது கட்டளையை பாகுபடுத்தி `கட்டளை_க்யூ_ச்டெப் ()` என்று அழைக்கிறது. கட்டளை_QUEUE_STEP () குறியீடு (Src/stepper.c இல்) ஒவ்வொரு வரிசை_ச்டெப் கட்டளையின் அளவுருக்களை ஒரு ச்டெப்பர் வரிசையில் சேர்க்கிறது. இயல்பான செயல்பாட்டின் கீழ், வரிசை_ச்டெப் கட்டளை அதன் முதல் படியின் நேரத்திற்கு முன்பே குறைந்தது 100 மீட்டர் தொலைவில் பாகுபடுத்தப்பட்டு வரிசையில் நிற்கிறது. இறுதியாக, ச்டெப்பர் நிகழ்வுகளின் தலைமுறை `ச்டெபர்_வென்ட் ()` இல் செய்யப்படுகிறது. இது முதல் படியின் திட்டமிடப்பட்ட நேரத்தில் வன்பொருள் நேரங்குறிகருவி குறுக்கீட்டிலிருந்து அழைக்கப்படுகிறது. Stepeper_event () குறியீடு ஒரு படி துடிப்பை உருவாக்குகிறது, பின்னர் கொடுக்கப்பட்ட Queue_step அளவுருக்களுக்கான அடுத்த படி துடிப்பின் நேரத்தில் இயங்க தன்னை மாற்றியமைக்கவும். ஒவ்வொரு Queue_step கட்டளைக்கும் அளவுருக்கள் "இடைவெளி", "எண்ணிக்கை" மற்றும் "சேர்". ஒரு உயர் மட்டத்தில், ச்டெப்பர்_வென்ட் () பின்வருவனவற்றை இயக்குகிறது, 'எண்ணிக்கை' நேரங்கள்: `do_step (); அடுத்த_வேக்_ நேரம் = last_wake_time + இடைவெளி; இடைவெளி += சேர்; `

மேற்கூறியவை ஒரு இயக்கத்தை செயல்படுத்த நிறைய சிக்கலானதாகத் தோன்றலாம். இருப்பினும், மிகவும் சுவையான பகுதிகள் கருவியின் தலை மற்றும் இயக்கவியல் வகுப்புகளில் உள்ளன. இது குறியீட்டின் இந்த பகுதியாகும், இது இயக்கங்கள் மற்றும் அவற்றின் நேரங்களைக் குறிப்பிடுகிறது. செயலாக்கத்தின் மீதமுள்ள பகுதிகள் பெரும்பாலும் தொடர்பு மற்றும் பிளம்பிங் ஆகும்.

## புரவலன் தொகுதியைச் சேர்ப்பது

கிளிப்பி புரவலன் குறியீடு ஒரு மாறும் தொகுதி ஏற்றுதல் திறனைக் கொண்டுள்ளது. அச்சுப்பொறி கட்டமைப்பு கோப்பில் "[My_Module]" என்ற பெயரிடப்பட்ட ஒரு கட்டமைப்பு பிரிவு காணப்பட்டால், மென்பொருள் தானாகவே பைதான் தொகுதி கிளிப்பி/எக்ச்ட்ராக்கள்/my_module.py ஐ ஏற்ற முயற்சிக்கும். இந்த தொகுதி அமைப்பு கிளிப்பருக்கு புதிய செயல்பாட்டைச் சேர்ப்பதற்கான விருப்பமான முறையாகும்.

புதிய தொகுதியைச் சேர்ப்பதற்கான எளிதான வழி, ஏற்கனவே உள்ள தொகுதியை ஒரு குறிப்பாகப் பயன்படுத்துவது - ** கிளிப்பி/எக்ச்ட்ராச்/சர்வோ.பை ** ஐப் பார்க்கவும்.

பின்வருவனையும் பயனுள்ளதாக இருக்கும்:

* தொகுதியின் செயல்பாடு `load_config ()` செயல்பாடு (வடிவத்தின் கட்டமைப்பு பிரிவுகளுக்கு [my_module]) அல்லது `load_config_prefix ()` (வடிவத்தின் கட்டமைப்பு பிரிவுகளுக்கு [my_module my_name]) தொடங்குகிறது. இந்த செயல்பாடு ஒரு "கட்டமைப்பு" பொருளை அனுப்பியுள்ளது, மேலும் இது கொடுக்கப்பட்ட கட்டமைப்பு பிரிவுடன் தொடர்புடைய புதிய "அச்சுப்பொறி பொருளை" திருப்பித் தர வேண்டும்.
* புதிய அச்சுப்பொறி பொருளை நிறுவும் செயல்பாட்டின் போது, கொடுக்கப்பட்ட கட்டமைப்பு பிரிவில் இருந்து அளவுருக்களைப் படிக்க கட்டமைப்பு பொருள் பயன்படுத்தப்படலாம். இது `config.get ()`, `config.getfloat ()`, `config.getint ()`, முதலியன முறைகளைப் பயன்படுத்தி செய்யப்படுகிறது. அச்சுப்பொறி பொருளின் கட்டுமானத்தின் போது உள்ளமைவிலிருந்து அனைத்து மதிப்புகளையும் படிக்க மறக்காதீர்கள் - இந்த கட்டத்தில் படிக்காத ஒரு கட்டமைப்பு அளவுருவை பயனர் குறிப்பிடினால், அது கட்டமைப்பில் ஒரு எழுத்துப்பிழை என்று கருதப்படும், மேலும் பிழை உயர்த்தப்படும்.
* முதன்மையான "அச்சுப்பொறி" வகுப்பைப் பெற `config.get_printer ()` முறையைப் பயன்படுத்தவும். இந்த "அச்சுப்பொறி" வகுப்பு உடனடிப்படுத்தப்பட்ட அனைத்து "அச்சுப்பொறி பொருள்களையும்" குறிப்புகளை சேமிக்கிறது. பிற அச்சுப்பொறி பொருள்களுக்கான குறிப்புகளைக் கண்டறிய `printor.lookup_object ()` முறையைப் பயன்படுத்தவும். ஏறக்குறைய அனைத்து செயல்பாடுகளும் (முக்கிய இயக்கவியல் தொகுதிகள் கூட) இந்த அச்சுப்பொறி பொருள்களில் ஒன்றில் இணைக்கப்பட்டுள்ளன. இருப்பினும், ஒரு புதிய தொகுதி உடனடிப்படுத்தப்படும்போது, மற்ற எல்லா அச்சுப்பொறி பொருள்களும் உடனடிப்படுத்தப்படாது என்பதை நினைவில் கொள்க. "GCODE" மற்றும் "ஊசிகள்" தொகுதிகள் எப்போதும் கிடைக்கும், ஆனால் மற்ற தொகுதிகளுக்கு இது தேடலை ஒத்திவைப்பது நல்லது.
* `அச்சுப்பொறி. ஒவ்வொரு நிகழ்வு பெயரும் ஒரு சரம், மற்றும் மாநாட்டின் மூலம் இது முக்கிய மூல தொகுதியின் பெயர், இது நிகழ்வை எழுப்பும் செயலுக்கு ஒரு குறுகிய பெயருடன் எழுப்புகிறது (எ.கா., "கிளிப்பி: இணைப்பு"). ஒவ்வொரு நிகழ்வு கையாளுபவருக்கும் அனுப்பப்பட்ட அளவுருக்கள் கொடுக்கப்பட்ட நிகழ்வுக்கு குறிப்பிட்டவை (விதிவிலக்கு கையாளுதல் மற்றும் செயல்படுத்தல் சூழல் போன்றவை). இரண்டு பொதுவான தொடக்க நிகழ்வுகள்:
   * கிளிப்பி: இணைப்பு - அனைத்து அச்சுப்பொறி பொருள்களும் உடனடிப்படுத்தப்பட்ட பிறகு இந்த நிகழ்வு உருவாக்கப்படுகிறது. இது பொதுவாக மற்ற அச்சுப்பொறி பொருள்களைத் தேடுவதற்கும், கட்டமைப்பு அமைப்புகளை சரிபார்க்கவும், அச்சுப்பொறி வன்பொருளுடன் ஆரம்ப "ஏண்ட்சேக்" செய்யவும் பயன்படுத்தப்படுகிறது.
   * கிளிப்பி: ஆயத்தம் - அனைத்து இணைப்பு கையாளுபவர்களும் வெற்றிகரமாக முடிந்தபின் இந்த நிகழ்வு உருவாக்கப்படுகிறது. அச்சுப்பொறி சாதாரண செயல்பாடுகளைக் கையாளத் தயாராக இருக்கும் மாநிலத்திற்கு மாறுவதைக் குறிக்கிறது. இந்த அழைப்பில் பிழையை எழுப்ப வேண்டாம்.
* பயனரின் உள்ளமைவில் பிழை இருந்தால், `load_config ()` அல்லது "நிகழ்வு நிகழ்வு" கட்டங்களின் போது அதை உயர்த்த மறக்காதீர்கள். பிழையைப் புகாரளிக்க `config.error (" எனது பிழை ")` அல்லது `printur.config_error (" எனது பிழை ") ஐ உயர்த்தவும்.
* மைக்ரோ-கன்ட்ரோலரில் ஒரு முள் கட்டமைக்க "பின்ச்" தொகுதியைப் பயன்படுத்தவும். இது பொதுவாக `அச்சுப்பொறி.லூக்அப்_ஆப்செக்ட் (" ஊசிகள் ") போன்றவற்றுடன் செய்யப்படுகிறது. Setup_pin (" PWM ", config.get (" my_pin "))`. திரும்பிய பொருளை பின்னர் ரன்-டைமில் கட்டளையிடலாம்.
* அச்சுப்பொறி பொருள் `get_status ()` முறையை வரையறுத்தால், தொகுதி [மேக்ரோச்] (கட்டளை_டெம்ப்ளேட்ச்.எம்டி) மற்றும் [API சேவையகம்] (API_SERVER.MD) வழியாக [நிலை தகவல்] (நிலை_ரொசெரன்ச்.எம்டி) ஏற்றுமதி செய்யலாம். `Get_status ()` முறை எண்கள், மிதவைகள், சரங்கள், பட்டியல்கள், அகராதிகள், உண்மை, பொய் அல்லது எதுவுமில்லை என்று சரங்கள் மற்றும் மதிப்புகள் கொண்ட விசைகள் கொண்ட பைதான் அகராதியை திருப்பித் தர வேண்டும். டூப்பிள்ச் (மற்றும் பெயரிடப்பட்ட டூப்பிள்ச்) பயன்படுத்தப்படலாம் (ஏபிஐ சேவையகம் வழியாக அணுகும்போது இவை பட்டியல்களாகத் தோன்றும்). ஏற்றுமதி செய்யப்படும் பட்டியல்கள் மற்றும் அகராதிகள் "மாறாதவை" என்று கருதப்பட வேண்டும் - அவற்றின் உள்ளடக்கங்கள் மாறினால், ஒரு புதிய பொருள் `Get_status ()` இலிருந்து திருப்பித் தரப்பட வேண்டும், இல்லையெனில் பநிஇ சேவையகம் அந்த மாற்றங்களைக் கண்டறியாது.
* தொகுதிக்கு கணினி நேரம் அல்லது வெளிப்புற கோப்பு விளக்கங்களுக்கான அணுகல் தேவைப்பட்டால், உலகளாவிய "நிகழ்வு உலை" வகுப்பிற்கான அணுகலைப் பெற `அச்சுப்பொறி. இந்த உலை வகுப்பு ஒருவர் டைமர்களை திட்டமிடவும், கோப்பு விளக்கங்களில் உள்ளீட்டிற்காக காத்திருக்கவும், புரவலன் குறியீட்டை "தூங்கவும்" அனுமதிக்கிறது.
* உலகளாவிய மாறிகள் பயன்படுத்த வேண்டாம். அனைத்து மாநிலங்களும் `load_config ()` செயல்பாட்டிலிருந்து திரும்பிய அச்சுப்பொறி பொருளில் சேமிக்கப்பட வேண்டும். மறுதொடக்கம் கட்டளை எதிர்பார்த்தபடி செயல்படாது என்பதால் இது முக்கியமானது. மேலும், இதே போன்ற காரணங்களுக்காக, ஏதேனும் வெளிப்புற கோப்புகள் (அல்லது சாக்கெட்டுகள்) திறக்கப்பட்டால், "கிளிப்பி: துண்டிக்கவும்" நிகழ்வு கையாளுதலை பதிவுசெய்து அவற்றை அந்த அழைப்பிலிருந்து மூடு.
* பிற அச்சுப்பொறி பொருள்களின் உள் உறுப்பினர் மாறிகள் (அல்லது அடிக்கோடிட்டுக் கொண்டு தொடங்கும் அழைப்பு முறைகள்) அணுகுவதைத் தவிர்க்கவும். இந்த மாநாட்டைக் கவனிப்பது எதிர்கால மாற்றங்களை நிர்வகிப்பதை எளிதாக்குகிறது.
* பைதான் வகுப்புகளின் பைதான் கட்டமைப்பாளரில் உள்ள அனைத்து உறுப்பினர் மாறிகளுக்கும் ஒரு மதிப்பை ஒதுக்க பரிந்துரைக்கப்படுகிறது. (எனவே புதிய உறுப்பினர் மாறிகள் மாறும் வகையில் பைத்தானின் திறனைப் பயன்படுத்துவதைத் தவிர்க்கவும்.)
* ஒரு பைதான் மாறி ஒரு மிதக்கும் புள்ளி மதிப்பை சேமிக்க வேண்டும் என்றால், அந்த மாறியை மிதக்கும் புள்ளி மாறிலிகளுடன் எப்போதும் ஒதுக்கவும் கையாளவும் பரிந்துரைக்கப்படுகிறது (மற்றும் ஒருபோதும் முழு எண் மாறிலிகளைப் பயன்படுத்த வேண்டாம்). எடுத்துக்காட்டாக, `self.speed = 1.` ஐ விட` self.speed = 1` ஐ விரும்புங்கள், மேலும் `self.speed = 2 ஐ விரும்புங்கள். * X` over` self.speed = 2 * x`. மிதக்கும் புள்ளி மதிப்புகளின் நிலையான பயன்பாடு பைதான் வகை மாற்றங்களில் க்யூர்க்சை பிழைத்திருத்துவது கடினம்.
* முதன்மையான கிளிப்பர் குறியீட்டில் சேர்ப்பதற்கான தொகுதியை சமர்ப்பித்தால், பதிப்புரிமை அறிவிப்பை தொகுதியின் மேலே வைக்க மறக்காதீர்கள். விருப்பமான வடிவமைப்பிற்கு இருக்கும் தொகுதிக்கூறுகளைப் பார்க்கவும்.

## புதிய இயக்கவியலைச் சேர்ப்பது

கூடுதல் வகை அச்சுப்பொறி இயக்கவியலுக்கு கிளிப்பருக்கு ஆதரவைச் சேர்ப்பதற்கான சில உதவிக்குறிப்புகளை இந்த பிரிவு வழங்குகிறது. இந்த வகை செயல்பாட்டிற்கு இலக்கு இயக்கவியலுக்கான கணித சூத்திரங்களைப் பற்றிய சிறந்த புரிதல் தேவைப்படுகிறது. இதற்கு மென்பொருள் மேம்பாட்டு திறன்களும் தேவைப்படுகின்றன - இருப்பினும் ஒருவர் புரவலன் மென்பொருளை மட்டுமே புதுப்பிக்க வேண்டும்.

பயனுள்ள படிகள்:

1. "[ஒரு நகர்வின் குறியீடு ஓட்டம்] (#குறியீடு-ஃப்ளோ-ஆஃப்-ஏ-மூவ்-கமாண்ட்)" பிரிவு மற்றும் [இயக்கவியல் ஆவணம்] (Kinematics.md) ஆகியவற்றைப் படிப்பதன் மூலம் தொடங்கவும்.
1. கிளிப்பி/ இயக்கவியல்/ கோப்பகத்தில் இருக்கும் இயக்கவியல் வகுப்புகளை மதிப்பாய்வு செய்யவும். கார்ட்டீசியன் ஆயத்தொலைவுகளில் ஒரு நகர்வை ஒவ்வொரு ச்டெப்பரிலும் இயக்கத்திற்கு மாற்றும் பணியில் ஈடுபடுகிறது. இந்த கோப்புகளில் ஒன்றை ஒரு தொடக்க புள்ளியாக ஒருவர் நகலெடுக்க முடியும்.
1. ஒவ்வொரு ச்டெப்பருக்கும் ஏற்கனவே கிடைக்கவில்லை என்றால் சி ச்டெப்பர் கினெமாடிக் நிலை செயல்பாடுகளை செயல்படுத்தவும் (KIN_CART.C, KIN_COREXY.C, மற்றும் KIN_DELTA.C ஐப் பார்க்கவும் கிளிப்பி/செல்/). கொடுக்கப்பட்ட நகர்வு நேரத்தை (நொடிகளில்) ஒரு கார்ட்டீசியன் ஒருங்கிணைப்புக்கு (மில்லிமீட்டரில்) மாற்ற `MOVE_GET_COORD ()` ஐ அழைக்க வேண்டும், பின்னர் அந்த கார்ட்டீசியன் ஒருங்கிணைப்பிலிருந்து விரும்பிய ச்டெப்பர் நிலையை (மில்லிமீட்டரில்) கணக்கிட வேண்டும்.
1. புதிய இயக்கவியல் வகுப்பில் `calc_position ()` முறையை செயல்படுத்தவும். இந்த முறை ஒவ்வொரு ச்டெப்பரின் நிலையிலிருந்தும் கார்ட்டீசியன் ஆயத்தொகுதிகளில் கருவித்தடத்தின் நிலையை கணக்கிடுகிறது. இது பொதுவாக ஓமிங் மற்றும் ஆய்வு நடவடிக்கைகளின் போது மட்டுமே அழைக்கப்படுவதால் இது திறமையாக இருக்க தேவையில்லை.
1. பிற முறைகள். `Check_move ()`, `get_status ()`, `get_steppers ()`, `வீடு ()`, மற்றும் `set_position ()` முறைகளை செயல்படுத்தவும். இந்த செயல்பாடுகள் பொதுவாக இயக்கவியல் குறிப்பிட்ட காசோலைகளை வழங்க பயன்படுத்தப்படுகின்றன. இருப்பினும், வளர்ச்சியின் தொடக்கத்தில் ஒருவர் இங்கே கொதிகலன்-தட்டு குறியீட்டைப் பயன்படுத்தலாம்.
1. சோதனை வழக்குகளை செயல்படுத்தவும். கொடுக்கப்பட்ட இயக்கவியலுக்கான முக்கியமான நிகழ்வுகளை சோதிக்கக்கூடிய தொடர் நகர்வுகளுடன் சி-குறியீடு கோப்பை உருவாக்கவும். இந்த சி-குறியீட்டு கோப்பை மைக்ரோ-கன்ட்ரோலர் கட்டளைகளாக மாற்ற [பிழைத்திருத்த ஆவணங்கள்] (பிழைத்திருத்தம். எம்.டி) ஐப் பின்தொடரவும். மூலையில் வழக்குகளை உடற்பயிற்சி செய்வதற்கும் பின்னடைவுகளை சரிபார்க்கவும் இது பயனுள்ளதாக இருக்கும்.

## புதிய மைக்ரோ-கன்ட்ரோலருக்கு போர்ட்டிங்

இந்த பிரிவு கிளிப்பரின் மைக்ரோ-கன்ட்ரோலர் குறியீட்டை ஒரு புதிய கட்டமைப்பிற்கு போர்ட்டிங் செய்வதற்கான சில உதவிக்குறிப்புகளை வழங்குகிறது. இந்த வகை செயல்பாட்டிற்கு உட்பொதிக்கப்பட்ட வளர்ச்சி மற்றும் இலக்கு மைக்ரோ-கன்ட்ரோலருக்கு அணுகல் பற்றிய நல்ல அறிவு தேவைப்படுகிறது.

பயனுள்ள படிகள்:

1. துறைமுகத்தின் போது பயன்படுத்தப்படும் 3 வது தரப்பு நூலகங்களை அடையாளம் காண்பதன் மூலம் தொடங்கவும். பொதுவான எடுத்துக்காட்டுகளில் "CMSIS" ரேப்பர்கள் மற்றும் உற்பத்தியாளர் "HAL" நூலகங்கள் அடங்கும். அனைத்து 3 வது தரப்பு குறியீடுகளும் குனு சி.பி.எல்.வி 3 இணக்கமாக இருக்க வேண்டும். 3 வது தரப்பு குறியீடு கிளிப்பர் லிப்/ கோப்பகத்திற்கு உறுதியளிக்க வேண்டும். நூலகம் எங்கு, எப்போது பெறப்பட்டது என்பது பற்றிய தகவலுடன் LIB/README கோப்பைப் புதுப்பிக்கவும். குறியீட்டை கிளிப்பர் களஞ்சியத்தில் மாற்றாமல் நகலெடுப்பது விரும்பத்தக்கது, ஆனால் ஏதேனும் மாற்றங்கள் தேவைப்பட்டால், அந்த மாற்றங்கள் LIB/README கோப்பில் வெளிப்படையாக பட்டியலிடப்பட வேண்டும்.
1. எச்.ஆர்.சி/ கோப்பகத்தில் ஒரு புதிய கட்டமைப்பு துணை அடைப்பை உருவாக்கி, ஆரம்ப KCONFIG மற்றும் மேக்ஃபைல் ஆதரவைச் சேர்க்கவும். ஏற்கனவே உள்ள கட்டமைப்புகளை வழிகாட்டியாகப் பயன்படுத்தவும். எச்.ஆர்.சி/சிமுலேட்டர் குறைந்தபட்ச தொடக்க புள்ளியின் அடிப்படை உதாரணத்தை வழங்குகிறது.
1. முதல் முக்கிய குறியீட்டு பணி இலக்கு வாரியத்திற்கு தகவல்தொடர்பு ஆதரவை கொண்டு வருவதாகும். புதிய துறைமுகத்தில் இது மிகவும் கடினமான படியாகும். அடிப்படை தொடர்பு செயல்பட்டவுடன், மீதமுள்ள படிகள் மிகவும் எளிதாக இருக்கும். ஆரம்ப வளர்ச்சியின் போது UART வகை தொடர் சாதனத்தைப் பயன்படுத்துவது பொதுவானது, ஏனெனில் இந்த வகையான வன்பொருள் சாதனங்கள் பொதுவாக செயல்படுத்தவும் கட்டுப்படுத்தவும் எளிதானவை. இந்த கட்டத்தின் போது, எச்.ஆர்.சி/பொதுவான/கோப்பகத்திலிருந்து உதவி குறியீட்டை தாராளமாகப் பயன்படுத்துங்கள் (எச்.ஆர்.சி/சிமுலேட்டர்/மேக்ஃபைல் எவ்வாறு பொதுவான சி குறியீட்டை உருவாக்குகிறது என்பதைச் சரிபார்க்கவும்). இந்த கட்டத்தில் Timer_read_time () (இது தற்போதைய கணினி கடிகாரத்தை வழங்குகிறது) வரையறுப்பதும் தேவை, ஆனால் நேரங்குறிகருவி IRQ கையாளுதலை முழுமையாக ஆதரிக்க வேண்டிய அவசியமில்லை.
1. Console.py கருவியுடன் ([பிழைத்திருத்த ஆவணம்] (பிழைத்திருத்த ஆவணத்தில்) விவரிக்கப்பட்டுள்ளபடி) நன்கு அறிந்து கொள்ளுங்கள், மேலும் அதனுடன் மைக்ரோ-கன்ட்ரோலருக்கான இணைப்பை சரிபார்க்கவும். இந்த கருவி குறைந்த அளவிலான மைக்ரோ-கன்ட்ரோலர் கம்யூனிகேசன் நெறிமுறையை மனித படிக்கக்கூடிய வடிவத்திற்கு மொழிபெயர்க்கிறது.
1. வன்பொருள் குறுக்கீடுகளிலிருந்து நேரங்குறிகருவி அனுப்புவதற்கு ஆதரவைச் சேர்க்கவும். கிளிப்பர் [970831EE] (https://github.com/klipper3d/klipper/commit/970831e0d3b91896e92270d98b2a3067427f) ஐக் காண்க 1-5 ஆர்கிடர் 1-5 க்கான எடுத்துக்காட்டு.
1. அடிப்படை GPIO உள்ளீடு மற்றும் வெளியீட்டு ஆதரவைக் கொண்டு வாருங்கள். இதற்கு ஒரு எடுத்துக்காட்டு என்று கிளிப்பர் [commance c78b9076] (https://github.com/klipper3d/klipper/commit/c78b90767f19e8510c315fb7ad64ca54 ஐக் காண்க).
1. கூடுதல் சாதனங்களைக் கொண்டு வாருங்கள் - எடுத்துக்காட்டாக கிளிப்பர் கமிட் [65613AED] (https://github.com/klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e9a02ef3c27) PER/COMM/C812A40A3782415E454B04BF7BD2158A6F0EC8B5 .
1. கட்டமைப்பு/ கோப்பகத்தில் மாதிரி கிளிப்பர் கட்டமைப்பு கோப்பை உருவாக்கவும். மைக்ரோ-கன்ட்ரோலரை முதன்மையான klippy.py திட்டத்துடன் சோதிக்கவும்.
1. சோதனை/ கோப்பகத்தில் உருவாக்க சோதனை நிகழ்வுகளைச் சேர்ப்பதைக் கவனியுங்கள்.

கூடுதல் குறியீட்டு உதவிக்குறிப்புகள்:

1. IO பதிவேடுகளை அணுக "சி பிட்ஃபீல்ட்ச்" பயன்படுத்துவதைத் தவிர்க்கவும்; 32 பிட், 16 பிட் அல்லது 8 பிட் எண்களின் நேரடி வாசிப்பு மற்றும் எழுத செயல்பாடுகளை விரும்புங்கள். சி பிட்ஃபீல்ட்களை (எ.கா., எண்டியன்னச் மற்றும் பிட் தளவமைப்பு) எவ்வாறு செயல்படுத்த வேண்டும் என்பதை சி மொழி விவரக்குறிப்புகள் தெளிவாகக் குறிப்பிடவில்லை, மேலும் சி பிட்ஃபீல்ட் வாசிப்பு அல்லது எழுதுவதில் ஐ.ஓ செயல்பாடுகள் என்ன நிகழும் என்பதை தீர்மானிப்பது கடினம்.
1. வாசிப்பு-மாடிஃபை-ரைட் செயல்பாடுகளைப் பயன்படுத்துவதற்குப் பதிலாக IO பதிவேடுகளுக்கு வெளிப்படையான மதிப்புகளை எழுத விரும்புங்கள். அதாவது, மற்ற புலங்கள் அறிந்த மதிப்புகளைக் கொண்ட ஒரு IO பதிவேட்டில் ஒரு புலத்தைப் புதுப்பித்தால், பதிவின் முழு உள்ளடக்கங்களையும் வெளிப்படையாக எழுதுவது விரும்பத்தக்கது. சிறிய, வேகமான மற்றும் பிழைத்திருத்தத்திற்கு எளிதான குறியீட்டை வெளிப்படையான எழுதுகிறது.

## ஒருங்கிணைப்பு அமைப்புகள்

உள்நாட்டில், கிளிப்பர் முதன்மையாக கார்ட்டீசியன் ஆயத்தொகுதிகளில் கருவித்தடத்தின் நிலையை கண்காணிக்கிறது, அவை கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடையவை. அதாவது, கிளிப்பர் குறியீட்டில் பெரும்பாலானவை ஒருபோதும் ஒருங்கிணைப்பு அமைப்புகளில் மாற்றத்தை அனுபவிக்காது. தோற்றத்தை மாற்ற பயனர் ஒரு கோரிக்கையைச் செய்தால் (எ.கா., ஒரு `சி 92` கட்டளை) பின்னர் எதிர்கால கட்டளைகளை முதன்மை ஒருங்கிணைப்பு அமைப்புக்கு மொழிபெயர்ப்பதன் மூலம் அந்த விளைவு பெறப்படுகிறது.

இருப்பினும், சில சந்தர்ப்பங்களில், வேறு சில ஒருங்கிணைப்பு அமைப்பில் கருவித் தலை நிலையைப் பெறுவது பயனுள்ளதாக இருக்கும், மேலும் அதை எளிதாக்க கிளிப்பருக்கு பல கருவிகள் உள்ளன. Get_position கட்டளையை இயக்குவதன் மூலம் இதைக் காணலாம். உதாரணமாக:

```
அனுப்பு: get_position
 Recv: // mcu: stepper_a: -2060 STEPPER_B: -1169 STEPPER_C: -1613
 Recv: // ச்டெப்பர்: ச்டெப்பர்_ஏ: 457.254159 ச்டெபர்_பி: 466.085669 ச்டெப்பர்_சி: 465.382132
 Recv: // ginematic: x: 8.339144 y: -3.131558 z: 233.347121
 Recv: // கருவிஎட்: x: 8.338078 y: -3.123175 Z: 233.347878 E: 0.000000
 Recv: // gcode: x: 8.338078 y: -3.123175 Z: 233.347878 E: 0.000000
 Recv: // gcode அடிப்படை: x: 0.000000 y: 0.000000 z: 0.000000 e: 0.000000
 Recv: // gcode homing: x: 0.000000 y: 0.000000 z: 0.000000
```

"MCU" நிலை (`stepper.get_mcu_position ()` குறியீட்டில்) என்பது மைக்ரோ-கன்ட்ரோலர் நேர்மறையான திசையில் வெளியிட்டுள்ள மொத்த படிகளின் எண்ணிக்கையாகும் மீட்டமை. வினவல் வழங்கப்படும்போது ரோபோ இயக்கத்தில் இருந்தால், அறிக்கையிடப்பட்ட மதிப்பில் மைக்ரோ-கன்ட்ரோலரில் இடையகப்படுத்தப்பட்ட நகர்வுகள் அடங்கும், ஆனால் தோற்றமளிக்கும் வரிசையில் நகர்வுகள் இல்லை.

"ச்டெப்பர்" நிலை (`stepper.get_commanded_position ()`) என்பது இயக்கவியல் குறியீட்டால் கண்காணிக்கப்பட்டபடி கொடுக்கப்பட்ட ச்டெப்பரின் நிலை. இது பொதுவாக அதன் ரயிலில் உள்ள வண்டியின் நிலைக்கு (மிமீ) ஒத்திருக்கிறது, இது கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள நிலை_எண்ட்ச்டாப்புடன் ஒப்பிடும்போது. . ஒருவர் `கருவிஎட்.

"கினெமாடிக்" நிலை (`KIN.Calc_Position ()`) என்பது "ச்டெப்பர்" நிலைகளிலிருந்து பெறப்பட்ட கருவியின் கார்ட்டீசியன் நிலையாகும், மேலும் இது கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடையது. ச்டெப்பர் மோட்டார்சின் கிரானுலாரிட்டி காரணமாக இது கோரப்பட்ட கார்ட்டீசியன் நிலையில் இருந்து வேறுபடலாம். "ச்டெப்பர்" நிலைகள் எடுக்கப்படும்போது ரோபோ இயக்கத்தில் இருந்தால், அறிக்கையிடப்பட்ட மதிப்பில் மைக்ரோ-கன்ட்ரோலரில் இடையகப்படுத்தப்பட்ட நகர்வுகள் அடங்கும், ஆனால் தோற்றமளிக்கும் வரிசையில் நகர்வுகள் இல்லை. ஒருவர் `கருவிஎட்.

"கருவிஎட்" நிலை (`கருவிஎட். வினவல் வழங்கப்படும் போது ரோபோ இயக்கத்தில் இருந்தால், அறிக்கையிடப்பட்ட மதிப்பில் கோரப்பட்ட அனைத்து நகர்வுகளும் அடங்கும் (ச்டெப்பர் மின்னோடி டிரைவர்களுக்கு வழங்க காத்திருக்கும் இடையகங்களில் உள்ளவர்கள் கூட).

கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கார்ட்டீசியன் ஆயத்தொகுதிகளில் `சி 1` (அல்லது` ஐயா 0`) கட்டளையிலிருந்து கடைசியாகக் கோரப்பட்ட நிலை "சி.சி.ஓ.டி" நிலை. சி-குறியீடு மாற்றம் (எ.கா., படுக்கை_மெச், படுக்கை_பில்ட், ச்கீ_க்யூரெக்சன்) நடைமுறையில் இருந்தால் இது "கருவிஎட்" நிலையிலிருந்து வேறுபடலாம். சி-குறியீட்டு தோற்றம் மாற்றப்பட்டிருந்தால் (எ.கா., `சி 92`,` செட்_சி கோட்_ஓஃப்செட்`, `எம் 221`) கடந்த` ஐயா 1 கட்டளையில் குறிப்பிடப்பட்டுள்ள உண்மையான ஆயங்களிலிருந்து இது வேறுபடலாம். `M114` கட்டளை (` gcode_move.get_status () ['gcode_position'] `)`) தற்போதைய சி-குறியீடு ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கடைசி சி-குறியீடு நிலையைப் புகாரளிக்கும்.

"GCODE BASE" என்பது கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கார்ட்டீசியன் ஆயத்தொகுதிகளில் சி-கோட் தோற்றத்தின் இருப்பிடமாகும். `G92`,` set_gcode_offset`, மற்றும் `M221` போன்ற கட்டளைகள் இந்த மதிப்பை மாற்றுகின்றன.

`சி 28` முகப்பு கட்டளைக்குப் பிறகு சி-கோட் தோற்றத்திற்கு (கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கார்ட்டீசியன் ஆயத்தொகுதிகளில்) பயன்படுத்த வேண்டிய இடம்" GCODE HOMING "ஆகும். `Set_gcode_offset` கட்டளை இந்த மதிப்பை மாற்றும்.

## நேரம்

கிளிப்பரின் செயல்பாட்டிற்கு அடிப்படையானது கடிகாரங்கள், நேரங்கள் மற்றும் நேர முத்திரைகளை கையாள்வதாகும். எதிர்காலத்தில் நிகழும் நிகழ்வுகளை திட்டமிடுவதன் மூலம் கிளிப்பர் அச்சுப்பொறியில் செயல்களைச் செயல்படுத்துகிறார். எடுத்துக்காட்டாக, விசிறியை இயக்க, குறியீடு 100 மீட்டரில் ஒரு GPIO முள் மாற்றத்தை திட்டமிடலாம். குறியீடு உடனடி நடவடிக்கை எடுக்க முயற்சிப்பது அரிது. எனவே, கிளிப்பருக்குள் நேரத்தைக் கையாள்வது செயல்பாட்டை சரிசெய்ய முக்கியமானது.

கிளிப்பர் புரவலன் மென்பொருளில் உள்நாட்டில் மூன்று வகையான நேரங்கள் கண்காணிக்கப்படுகின்றன:

* கணினி நேரம். கணினி நேரம் கணினியின் மோனோடோனிக் கடிகாரத்தைப் பயன்படுத்துகிறது - இது ஒரு மிதக்கும் புள்ளி எண் விநாடிகளாக சேமிக்கப்படுகிறது, மேலும் இது புரவலன் கணினி கடைசியாக தொடங்கப்பட்டபோது (பொதுவாக) தொடர்புடையது. கணினி நேரங்கள் மென்பொருளில் மட்டுப்படுத்தப்பட்ட பயன்பாட்டைக் கொண்டுள்ளன - அவை இயக்க முறைமையுடன் தொடர்பு கொள்ளும்போது முதன்மையாகப் பயன்படுத்தப்படுகின்றன. புரவலன் குறியீட்டிற்குள், கணினி நேரங்கள் அடிக்கடி *நிகழ்வு நேரம் *அல்லது *CURIME *என்ற பெயரிடப்பட்ட மாறிகளில் சேமிக்கப்படுகின்றன.
* நேரம் அச்சிடுக. அச்சு நேரம் முதன்மையான மைக்ரோ-கன்ட்ரோலர் கடிகாரத்துடன் ஒத்திசைக்கப்படுகிறது ("[MCU]" கட்டமைப்பு பிரிவில் வரையறுக்கப்பட்ட மைக்ரோ-கட்டுப்பாட்டு). இது ஒரு மிதக்கும் புள்ளி எண் விநாடிகளாக சேமிக்கப்படுகிறது மற்றும் முதன்மையான எம்.சி.யு கடைசியாக மறுதொடக்கம் செய்யப்பட்டபோது தொடர்புடையது. MCU இன் நிலையான கட்டமைக்கப்பட்ட அதிர்வெண் வீதத்தால் அச்சு நேரத்தை பெருக்கி "அச்சு நேரத்திலிருந்து" முதன்மையான மைக்ரோ-கன்ட்ரோலரின் வன்பொருள் கடிகாரத்திற்கு மாற்ற முடியும். உயர் மட்ட புரவலன் குறியீடு கிட்டத்தட்ட எல்லா உடல் செயல்களையும் (எ.கா., தலை இயக்கம், ஈட்டர் மாற்றங்கள் போன்றவை) கணக்கிட அச்சு நேரங்களைப் பயன்படுத்துகிறது. புரவலன் குறியீட்டிற்குள், அச்சு நேரங்கள் பொதுவாக *print_time *அல்லது *move_time *என்ற பெயரில் உள்ள மாறிகளில் சேமிக்கப்படுகின்றன.
* MCU கடிகாரம். இது ஒவ்வொரு மைக்ரோ-கன்ட்ரோலரின் வன்பொருள் கடிகார கவுண்டராகும். இது ஒரு முழு எண்ணாக சேமிக்கப்படுகிறது மற்றும் அதன் புதுப்பிப்பு வீதம் கொடுக்கப்பட்ட மைக்ரோ-கன்ட்ரோலரின் அதிர்வெண்ணுடன் தொடர்புடையது. புரவலன் மென்பொருள் அதன் உள் நேரங்களை MCU க்கு அனுப்புவதற்கு முன் கடிகாரங்களுக்கு மொழிபெயர்க்கிறது. எம்.சி.யு குறியீடு கடிகார உண்ணியில் மட்டுமே நேரத்தைக் கண்காணிக்கிறது. புரவலன் குறியீட்டிற்குள், கடிகார மதிப்புகள் 64 பிட் முழு எண்களாக கண்காணிக்கப்படுகின்றன, அதே நேரத்தில் MCU குறியீடு 32 பிட் முழு எண்களைப் பயன்படுத்துகிறது. புரவலன் குறியீட்டிற்குள், கடிகாரங்கள் பொதுவாக *கடிகாரம் *அல்லது *உண்ணி *கொண்ட பெயர்களுடன் மாறிகளில் சேமிக்கப்படுகின்றன.

வெவ்வேறு நேர வடிவங்களுக்கிடையேயான மாற்றம் முதன்மையாக ** கிளிப்பி/கடிகார்சின்க் ** குறியீட்டில் செயல்படுத்தப்படுகிறது.

குறியீட்டை மதிப்பாய்வு செய்யும் போது விழிப்புடன் இருக்க வேண்டிய சில விசயங்கள்:

* 32 பிட் மற்றும் 64 பிட் கடிகாரங்கள்: அலைவரிசையைக் குறைப்பதற்கும் மைக்ரோ-கன்ட்ரோலர் செயல்திறனை மேம்படுத்துவதற்கும், மைக்ரோ-கன்ட்ரோலரில் உள்ள கடிகாரங்கள் 32 பிட் முழு எண்களாகக் கண்காணிக்கப்படுகின்றன. MCU குறியீட்டில் இரண்டு கடிகாரங்களை ஒப்பிடும்போது, `Timer_is_before ()` செயல்பாடு எப்போதும் முழு எண் ரோல்ஓவர்கள் சரியாக கையாளப்படுவதை உறுதிப்படுத்த பயன்படுத்தப்பட வேண்டும். புரவலன் மென்பொருள் 32 பிட் கடிகாரங்களை 64 பிட் கடிகாரங்களாக மாற்றுகிறது, இது பெற்ற கடைசி MCU நேர முத்திரையிலிருந்து உயர் -வரிசை பிட்களைச் சேர்ப்பதன் மூலம் - MCU இலிருந்து எந்த செய்தியும் எதிர்காலத்தில் அல்லது கடந்த காலங்களில் 2^31 கடிகார உண்ணிக்கு மேல் இல்லை, எனவே இந்த மாற்றம் ஒருபோதும் தெளிவற்றதல்ல . புரவலன் 64 பிட் கடிகாரங்களிலிருந்து 32 பிட் கடிகாரங்களாக மாற்றுகிறது. இந்த மாற்றத்தில் தெளிவற்ற தன்மை இல்லை என்பதை உறுதிப்படுத்த, ** கிளிப்பி/செல்பர்/சீரியால்கியூ.
* பல மைக்ரோ-கன்ட்ரோலர்கள்: ஒற்றை அச்சுப்பொறியில் பல மைக்ரோ-கன்ட்ரோலர்களைப் பயன்படுத்தி புரவலன் மென்பொருள் ஆதரிக்கிறது. இந்த வழக்கில், ஒவ்வொரு மைக்ரோ-கன்ட்ரோலரின் "MCU கடிகாரமும்" தனித்தனியாக கண்காணிக்கப்படுகிறது. CrockSync.py குறியீடு மைக்ரோ-கன்ட்ரோலர்களிடையே கடிகார சறுக்கலை "அச்சு நேரத்திலிருந்து" முதல் "MCU கடிகாரம்" ஆக மாற்றும் முறையை மாற்றியமைப்பதன் மூலம் கையாளுகிறது. இரண்டாம் நிலை MCU களில், இந்த மாற்றத்தில் பயன்படுத்தப்படும் MCU அதிர்வெண் அளவிடப்பட்ட சறுக்கலுக்கான கணக்கில் தொடர்ந்து புதுப்பிக்கப்படுகிறது.
