# Languages add-on <noreply-addon-languages@weblate.org>, 2025.
# தமிழ்நேரம் <anishprabu.t@gmail.com>, 2025.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2025-01-08 00:03+0000\n"
"Last-Translator: தமிழ்நேரம் <anishprabu.t@gmail.com>\n"
"Language-Team: Tamil <https://hosted.weblate.org/projects/klipper/"
"code_overview/ta/>\n"
"Language: ta\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.10-dev\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr ""
"இந்த ஆவணம் ஒட்டுமொத்த குறியீடு தளவமைப்பு மற்றும் கிளிப்பரின் முக்கிய குறியீடு ஓட்டத்தை "
"விவரிக்கிறது."

msgid "Directory Layout"
msgstr "அடைவு தளவமைப்பு"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"** SRC/** கோப்பகத்தில் மைக்ரோ-கன்ட்ரோலர் குறியீட்டிற்கான சி மூலத்தைக் கொண்டுள்ளது. ** src/"
"atsam/**, ** src/atsamd/**, ** src/avr/**, ** src/linux/**, ** src/lpc176x/**"
", ** src/ PRU/**, மற்றும் ** SRC/STM32/** கோப்பகங்கள் கட்டிடக்கலை குறிப்பிட்ட "
"மைக்ரோ-கண்ட்ரோலர் குறியீட்டைக் கொண்டுள்ளன. ** எச்.ஆர்.சி/சிமுலேட்டர்/** குறியீடு ச்டப்களைக் "
"கொண்டுள்ளது, இது மைக்ரோ-கன்ட்ரோலரை மற்ற கட்டமைப்புகளில் சோதிக்க அனுமதிக்கிறது. ** SRC/"
"generic/** கோப்பகத்தில் வெவ்வேறு கட்டமைப்புகளில் பயனுள்ளதாக இருக்கும் உதவி குறியீடு "
"உள்ளது. தற்போதைய கட்டிடக்கலை கோப்பகத்தில் (எ.கா., எச்.ஆர்.சி/ஏ.வி.ஆர்/சில ஃபைல்.எச்) "
"மற்றும் பின்னர் பொதுவான கோப்பகத்தில் (எ.கா., எச்.ஆர்.சி/செனரிக்/சில ஃபைல்.எச்) பார்க்க "
"\"பலகை/சில ஃபைல்.எச்\" அடங்கும்."

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"** கிளிப்பி/** கோப்பகத்தில் புரவலன் மென்பொருள் உள்ளது. புரவலன் மென்பொருளில் பெரும்பாலானவை"
" பைதானில் எழுதப்பட்டுள்ளன, இருப்பினும் ** கிளிப்பி/செல்பர்/** கோப்பகத்தில் சில சி குறியீடு"
" உதவியாளர்கள் உள்ளனர். ** கிளிப்பி/இயக்கவியல்/** கோப்பகத்தில் ரோபோ இயக்கவியல் குறியீடு "
"உள்ளது. ** கிளிப்பி/எக்ச்ட்ராச்/** கோப்பகத்தில் புரவலன் குறியீடு விரிவாக்கக்கூடிய "
"\"தொகுதிகள்\" உள்ளன."

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr ""
"** lib/** கோப்பகத்தில் வெளிப்புற 3-தரப்பு நூலகக் குறியீடு உள்ளது, இது சில இலக்குகளை "
"உருவாக்க தேவை."

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr ""
"** கட்டமைப்பு/** கோப்பகத்தில் எடுத்துக்காட்டு அச்சுப்பொறி உள்ளமைவு கோப்புகள் உள்ளன."

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr ""
"** ச்கிரிப்ட்கள்/** கோப்பகத்தில் மைக்ரோ-கன்ட்ரோலர் குறியீட்டை தொகுக்க பயனுள்ள கட்டட நேர "
"ச்கிரிப்ட்கள் உள்ளன."

msgid "The **test/** directory contains automated test cases."
msgstr "** சோதனை/** கோப்பகத்தில் தானியங்கு சோதனை வழக்குகள் உள்ளன."

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"தொகுப்பின் போது, உருவாக்கம் ஒரு ** அவுட்/** கோப்பகத்தை உருவாக்கக்கூடும். இதில் தற்காலிக "
"உருவாக்க நேர பொருள்கள் உள்ளன. கட்டப்பட்ட இறுதி மைக்ரோ-கன்ட்ரோலர் பொருள் ஏ.வி.ஆர் மற்றும் ** "
"அவுட்/கிளிப்பர்.பின் ** கையில் ** அவுட்/கிளிப்பர்.எக்ச் ** ஆகும்."

msgid "Micro-controller code flow"
msgstr "மைக்ரோ-கண்ட்ரோலர் குறியீடு ஓட்டம்"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"மைக்ரோ-கன்ட்ரோலர் குறியீட்டின் செயல்பாடு கட்டமைப்பு குறிப்பிட்ட குறியீட்டில் (எ.கா., ** SRC/"
"AVR/MAIN.C **) தொடங்குகிறது, இது இறுதியில் ** SRC/Sall.C ** இல் அமைந்துள்ள "
"Sape_Main () ஐ அழைக்கிறது. Seplow_Init () மேக்ரோவுடன் குறிக்கப்பட்ட அனைத்து "
"செயல்பாடுகளையும் இயக்குவதன் மூலம் Sapel_main () குறியீடு தொடங்குகிறது. இது டெக்_ டாச்க்"
" () மேக்ரோவுடன் குறிக்கப்பட்ட அனைத்து செயல்பாடுகளையும் மீண்டும் மீண்டும் இயக்குகிறது."

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"** src/command.c ** இல் அமைந்துள்ள கட்டளை_டிச்பாட்ச் () முக்கிய பணி செயல்பாடுகளில் ஒன்று"
". இந்த செயல்பாடு போர்டு குறிப்பிட்ட உள்ளீடு/வெளியீட்டுக் குறியீட்டிலிருந்து அழைக்கப்படுகிறது"
" (எ.கா. உள்ளீட்டு ச்ட்ரீமில். கட்டளை செயல்பாடுகள் pect_command () மேக்ரோவைப் பயன்படுத்தி "
"அறிவிக்கப்படுகின்றன (மேலும் தகவலுக்கு [நெறிமுறை] (நெறிமுறை. Md) ஆவணத்தைப் பார்க்கவும்)."

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"TIMER செயல்பாடுகள் Sell_add_timer () ஐ அழைப்பதன் மூலம் திட்டமிடப்பட்டுள்ளன (** src/"
"seld.c ** இல் அமைந்துள்ளது). கோரப்பட்ட கடிகார நேரத்தில் கொடுக்கப்பட்ட செயல்பாடு "
"அழைக்கப்படுவதற்கு திட்டமிடல் குறியீடு ஏற்பாடு செய்யும். நேரங்குறிகருவி குறுக்கீடுகள் "
"ஆரம்பத்தில் ஒரு கட்டிடக்கலை குறிப்பிட்ட குறுக்கீடு கையாளுபவரில் கையாளப்படுகின்றன (எ.கா. "
"நேரங்குறிகருவி குறுக்கீடு அட்டவணை நேரங்குறிகருவி செயல்பாடுகளை செயல்படுத்த "
"வழிவகுக்கிறது. நேரங்குறிகருவி செயல்பாடுகள் எப்போதும் குறுக்கீடுகளுடன் முடக்கப்பட்டுள்ளன. "
"நேரங்குறிகருவி செயல்பாடுகள் எப்போதும் ஒரு சில மைக்ரோ விநாடிகளுக்குள் முடிக்க வேண்டும். "
"நேரங்குறிகருவி நிகழ்வு முடிந்ததும், செயல்பாடு தன்னை மறுபரிசீலனை செய்ய தேர்வு செய்யலாம்."

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"ஒரு பிழை கண்டறியப்பட்டால், குறியீடு பணிநிறுத்தம் () (** src/seld.c ** இல் அமைந்துள்ள "
"Sape_Shutdown () என்று அழைக்கும் மேக்ரோ. பணிநிறுத்தம் () ஐத் தூண்டுவது டெக்_சட் பேரூர் "
"() மேக்ரோவுடன் குறியிடப்பட்ட அனைத்து செயல்பாடுகளையும் இயக்குகிறது. பணிநிறுத்தம் "
"செயல்பாடுகள் எப்போதும் குறுக்கீடுகளுடன் இயங்கும்."

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"மைக்ரோ-கன்ட்ரோலரின் செயல்பாட்டின் பெரும்பகுதி பொது நோக்கத்திற்கான உள்ளீடு/வெளியீட்டு "
"ஊசிகளுடன் (சிபிஐஓ) பணியாற்றுவதை உள்ளடக்குகிறது. உயர் மட்ட பணிக் குறியீட்டிலிருந்து "
"குறைந்த-நிலை கட்டமைப்பு குறிப்பிட்ட குறியீட்டை சுருக்கிக் கொள்வதற்காக, அனைத்து GPIO "
"நிகழ்வுகளும் கட்டிடக்கலை குறிப்பிட்ட ரேப்பர்களில் செயல்படுத்தப்படுகின்றன (எ.கா., ** SRC/"
"AVR/GPIO.C **). குறியீடு சி.சி.சியின் \"-flto -fwhole-program\" தேர்வுமுறையுடன் "
"தொகுக்கப்பட்டுள்ளது, இது தொகுப்புக் அலகுகளில் செயல்பாடுகளைத் தூண்டுவதற்கான ஒரு சிறந்த "
"வேலையைச் செய்கிறது, எனவே இந்த சிறிய GPIO செயல்பாடுகளில் பெரும்பாலானவை அவற்றின் "
"அழைப்பாளர்களிடையே வைக்கப்படுகின்றன, மேலும் பயன்படுத்துவதற்கு ரன்-டைம் செலவு இல்லை அவர்கள்."

msgid "Klippy code overview"
msgstr "கிளிப்பி குறியீடு கண்ணோட்டம்"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"புரவலன் குறியீடு (கிளிப்பி) மைக்ரோ-கன்ட்ரோலருடன் சோடியாக குறைந்த விலை கணினியில் "
"(ராச்பெர்ரி பை போன்றவை) இயக்கும் நோக்கம் கொண்டது. குறியீடு முதன்மையாக பைத்தானில் "
"எழுதப்பட்டுள்ளது, இருப்பினும் இது சி குறியீட்டில் சில செயல்பாடுகளை செயல்படுத்த CFFI ஐப் "
"பயன்படுத்துகிறது."

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"ஆரம்ப சாவுஒறுப்பு ** klippy/klippy.py ** இல் தொடங்குகிறது. இது கட்டளை-வரி வாதங்களைப்"
" படிக்கிறது, அச்சுப்பொறி கட்டமைப்பு கோப்பைத் திறக்கிறது, முதன்மையான அச்சுப்பொறி பொருள்களை"
" நிறுவுகிறது, மேலும் தொடர் இணைப்பைத் தொடங்குகிறது. சி-கோட் கட்டளைகளின் முக்கிய "
"செயல்பாடு ** klippy/gcode.py ** இல் செயல்முறை_காமண்ட்ச் () முறையில் உள்ளது. இந்த "
"குறியீடு சி-குறியீடு கட்டளைகளை அச்சுப்பொறி பொருள் அழைப்புகளாக மொழிபெயர்க்கிறது, இது "
"மைக்ரோ-கன்ட்ரோலரில் செயல்படுத்தப்பட வேண்டிய கட்டளைகளுக்கு அடிக்கடி மொழிபெயர்க்கப்பட்டுள்ளது "
"(மைக்ரோ-கன்ட்ரோலர் குறியீட்டில் டெக்_காம்மண்ட் மேக்ரோ வழியாக அறிவிக்கப்பட்டபடி)."

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"கிளிப்பி புரவலன் குறியீட்டில் நான்கு நூல்கள் உள்ளன. முதன்மையான நூல் உள்வரும் GCODE "
"கட்டளைகளை கையாளுகிறது. இரண்டாவது நூல் (இது முற்றிலும் ** கிளிப்பி/செல்பர்/சீரியால்கியூ"
". பைதான் குறியீட்டில் உள்ள மைக்ரோ-கன்ட்ரோலரிலிருந்து மறுமொழி செய்திகளை செயலாக்க மூன்றாவது"
" நூல் பயன்படுத்தப்படுகிறது (பார்க்க ** கிளிப்பி/சீரியல்எச்.டி.எல்.ஒய் **). நான்காவது நூல் "
"பிழைத்திருத்த செய்திகளை பதிவுக்கு எழுதுகிறது (** கிளிப்பி/queuealogger.py ** ஐப் "
"பார்க்கவும்) இதனால் மற்ற நூல்கள் ஒருபோதும் பதிவு எழுதுகின்றன."

msgid "Code flow of a move command"
msgstr "நகரும் கட்டளையின் குறியீடு ஓட்டம்"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"கிளிப்பி ஓச்டுக்கு \"சி 1\" கட்டளை அனுப்பப்படும்போது ஒரு பொதுவான அச்சுப்பொறி இயக்கம் "
"தொடங்குகிறது, மேலும் மைக்ரோ-கன்ட்ரோலரில் தொடர்புடைய படி பருப்பு வகைகள் தயாரிக்கப்படும் "
"போது அது நிறைவு செய்கிறது. இந்த பிரிவு ஒரு பொதுவான நகர்வு கட்டளையின் குறியீடு "
"ஓட்டத்தை கோடிட்டுக் காட்டுகிறது. [இயக்கவியல்] (இயக்கவியல். எம்.டி) ஆவணம் நகர்வுகளின் "
"இயக்கவியல் பற்றிய கூடுதல் தகவல்களை வழங்குகிறது."

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"நகரும் கட்டளைக்கான செயலாக்கம் GCODE.PY இல் தொடங்குகிறது. Gcode.py இன் குறிக்கோள் "
"சி-குறியீட்டை உள் அழைப்புகளாக மொழிபெயர்ப்பதாகும். ஒரு ஐயா 1 கட்டளை கிளிப்பி/எக்ச்ட்ராக்கள்/"
"gcode_move.py இல் cmd_g1 () ஐ அழைக்கும். Gcode_move.py குறியீடு தோற்றத்தில் மாற்றங்களை"
" கையாளுகிறது (எ.கா., G92), உறவினர் Vs முழுமையான நிலைகளில் (எ.கா., G90) மாற்றங்கள் "
"மற்றும் அலகு மாற்றங்கள் (எ.கா., F6000 = 100 மிமீ/வி). ஒரு நகர்வுக்கான குறியீடு பாதை: `"
"_PROCESS_DATA () -> _PROCESS_COMMANDS () -> CMD_G1 ()`. இறுதியில் கருவிஎட் "
"வகுப்பு உண்மையான கோரிக்கையை செயல்படுத்த பயன்படுத்தப்படுகிறது: `cmd_g1 () -> "
"கருவிஎட்.மோவ் ()`"

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr ""
"கருவியின் அளவுருக்கள் (கார்ட்டீசியன் இடத்திலும், விநாடிகள் மற்றும் மில்லிமீட்டர்களின் "
"அலகுகளிலும்) ஒரு நகர்வு () பொருளை உருவாக்குகிறது."

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"ஒவ்வொரு நகர்வையும் (`கருவிஎட் () -> கின்.செக்_மோவ் ()`) தணிக்கை செய்ய இயக்கவியல் "
"வகுப்பிற்கு வாய்ப்பு வழங்கப்படுகிறது. இயக்கவியல் வகுப்புகள் கிளிப்பி/ இயக்கவியல்/ "
"கோப்பகத்தில் அமைந்துள்ளன. நகர்வு செல்லுபடியாகாவிட்டால் Check_move () குறியீடு பிழையை "
"எழுப்பக்கூடும். செக்_மோவ் () வெற்றிகரமாக முடிந்தால், அடிப்படை இயக்கவியல் நகர்வைக் கையாள "
"முடியும்."

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction () ஒரு நகர்வில் \"ட்ரெப்சாய்டு செனரேட்டரை\" செயல்படுத்துகிறது. "
"\"ட்ரெப்சாய்டு செனரேட்டர்\" ஒவ்வொரு அசைவையும் மூன்று பகுதிகளாக உடைக்கிறது: ஒரு நிலையா"
"ன முடுக்கம் கட்டம், அதைத் தொடர்ந்து ஒரு நிலையான விரைவு கட்டம், அதைத் தொடர்ந்து ஒரு நிலையா"
"ன வீழ்ச்சி கட்டம். ஒவ்வொரு நகர்விலும் இந்த வரிசையில் இந்த மூன்று கட்டங்கள் உள்ளன, ஆனால் சில "
"கட்டங்கள் சுழிய காலமாக இருக்கலாம்."

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"கருவிஎட். அனைத்து தகவல்களும் நகர்வு () வகுப்பில் சேமிக்கப்பட்டு, கார்ட்டீசியன் இடத்தில் "
"மில்லிமீட்டர் மற்றும் விநாடிகளின் அலகுகளில் உள்ளன."

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"எக்ச்ட்ரூடர் அதன் சொந்த இயக்கவியல் வகுப்பில் கையாளப்படுகிறது என்பதை நினைவில் கொள்க: "
"`கருவிஎட். நகர்வு () வகுப்பு சரியான இயக்க நேரத்தைக் குறிப்பிடுவதால், குறிப்பிட்ட "
"நேரத்துடன் படி பருப்பு வகைகள் மைக்ரோ-கன்ட்ரோலருக்கு அனுப்பப்படுவதால், எக்ச்ட்ரூடர் வகுப்பால் "
"தயாரிக்கப்படும் ச்டெப்பர் இயக்கங்கள் குறியீடு தனித்தனியாக வைக்கப்பட்டிருந்தாலும் தலை "
"இயக்கத்துடன் ஒத்திசைக்கப்படும்."

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"மறுசீரமைப்பு தீர்வி அவர்கள் ஒரு வரிசையில் சேர்க்கப்படும் படி நேரங்களைக் கணக்கிட்ட பிறகு: `"
"itersolve_gen_steps_range () -> stepampress_append ()` "
"(கிளிப்பி/செல்பர்/ச்டெபோகிரிபிரச்.சியில்). வரிசை (struct stretcompress.queue) "
"ஒவ்வொரு அடியிலும் தொடர்புடைய மைக்ரோ-கன்ட்ரோலர் கடிகார எதிர் நேரங்களை சேமிக்கிறது. இங்கே "
"\"மைக்ரோ-கன்ட்ரோலர் கடிகார கவுண்டர்\" மதிப்பு மைக்ரோ-கன்ட்ரோலரின் வன்பொருள் கவுண்டருக்கு "
"நேரடியாக ஒத்திருக்கிறது-இது மைக்ரோ-கன்ட்ரோலர் கடைசியாக இயங்கும் போது தொடர்புடையது."

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"அடுத்த முக்கிய படி படிகளை சுருக்க வேண்டும்: `StepCompress_flush () -> "
"சுருக்க_பிசெக்ட்_ஏடி ()` (கிளிப்பி/செல்ஃபர்/ச்டெப்அக்ரேச்.சியில்). இந்த குறியீடு முந்தைய "
"கட்டத்தில் கட்டப்பட்ட ச்டெப்பர் படி நேரங்களின் பட்டியலுக்கு ஒத்த மைக்ரோ-கன்ட்ரோலர் "
"\"Queue_step\" கட்டளைகளின் வரிசையை உருவாக்கி குறியீடாக்குகிறது. இந்த \"queue_step\""
" கட்டளைகள் பின்னர் வரிசையில் வரிசையில் நிற்கின்றன, முன்னுரிமை அளிக்கப்படுகின்றன, மேலும் "
"மைக்ரோ-கன்ட்ரோலருக்கு அனுப்பப்படுகின்றன (StepCompress.c"

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"மைக்ரோ-கன்ட்ரோலரில் Queue_step கட்டளைகளை செயலாக்குவது SRC/command.c இல் தொடங்குகிறது"
", இது கட்டளையை பாகுபடுத்தி `கட்டளை_க்யூ_ச்டெப் ()` என்று அழைக்கிறது. கட்டளை"
"_QUEUE_STEP () குறியீடு (Src/stepper.c இல்) ஒவ்வொரு வரிசை_ச்டெப் கட்டளையின் "
"அளவுருக்களை ஒரு ச்டெப்பர் வரிசையில் சேர்க்கிறது. இயல்பான செயல்பாட்டின் கீழ், வரிசை_ச்டெப் "
"கட்டளை அதன் முதல் படியின் நேரத்திற்கு முன்பே குறைந்தது 100 மீட்டர் தொலைவில் "
"பாகுபடுத்தப்பட்டு வரிசையில் நிற்கிறது. இறுதியாக, ச்டெப்பர் நிகழ்வுகளின் தலைமுறை "
"`ச்டெபர்_வென்ட் ()` இல் செய்யப்படுகிறது. இது முதல் படியின் திட்டமிடப்பட்ட நேரத்தில் வன்பொருள்"
" நேரங்குறிகருவி குறுக்கீட்டிலிருந்து அழைக்கப்படுகிறது. Stepeper_event () குறியீடு ஒரு"
" படி துடிப்பை உருவாக்குகிறது, பின்னர் கொடுக்கப்பட்ட Queue_step அளவுருக்களுக்கான அடுத்த "
"படி துடிப்பின் நேரத்தில் இயங்க தன்னை மாற்றியமைக்கவும். ஒவ்வொரு Queue_step கட்டளைக்கும் "
"அளவுருக்கள் \"இடைவெளி\", \"எண்ணிக்கை\" மற்றும் \"சேர்\". ஒரு உயர் மட்டத்தில், "
"ச்டெப்பர்_வென்ட் () பின்வருவனவற்றை இயக்குகிறது, 'எண்ணிக்கை' நேரங்கள்: `do_step (); "
"அடுத்த_வேக்_ நேரம் = last_wake_time + இடைவெளி; இடைவெளி += சேர்; `"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"மேற்கூறியவை ஒரு இயக்கத்தை செயல்படுத்த நிறைய சிக்கலானதாகத் தோன்றலாம். இருப்பினும், மிகவும்"
" சுவையான பகுதிகள் கருவியின் தலை மற்றும் இயக்கவியல் வகுப்புகளில் உள்ளன. இது குறியீட்டின் "
"இந்த பகுதியாகும், இது இயக்கங்கள் மற்றும் அவற்றின் நேரங்களைக் குறிப்பிடுகிறது. செயலாக்கத்தின்"
" மீதமுள்ள பகுதிகள் பெரும்பாலும் தொடர்பு மற்றும் பிளம்பிங் ஆகும்."

msgid "Adding a host module"
msgstr "புரவலன் தொகுதியைச் சேர்ப்பது"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"கிளிப்பி புரவலன் குறியீடு ஒரு மாறும் தொகுதி ஏற்றுதல் திறனைக் கொண்டுள்ளது. அச்சுப்பொறி "
"கட்டமைப்பு கோப்பில் \"[My_Module]\" என்ற பெயரிடப்பட்ட ஒரு கட்டமைப்பு பிரிவு காணப்பட்டால்"
", மென்பொருள் தானாகவே பைதான் தொகுதி கிளிப்பி/எக்ச்ட்ராக்கள்/my_module.py ஐ ஏற்ற "
"முயற்சிக்கும். இந்த தொகுதி அமைப்பு கிளிப்பருக்கு புதிய செயல்பாட்டைச் சேர்ப்பதற்கான "
"விருப்பமான முறையாகும்."

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr ""
"புதிய தொகுதியைச் சேர்ப்பதற்கான எளிதான வழி, ஏற்கனவே உள்ள தொகுதியை ஒரு குறிப்பாகப் "
"பயன்படுத்துவது - ** கிளிப்பி/எக்ச்ட்ராச்/சர்வோ.பை ** ஐப் பார்க்கவும்."

msgid "The following may also be useful:"
msgstr "பின்வருவனையும் பயனுள்ளதாக இருக்கும்:"

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"தொகுதியின் செயல்பாடு `load_config ()` செயல்பாடு (வடிவத்தின் கட்டமைப்பு பிரிவுகளுக்கு "
"[my_module]) அல்லது `load_config_prefix ()` (வடிவத்தின் கட்டமைப்பு பிரிவுகளுக்கு "
"[my_module my_name]) தொடங்குகிறது. இந்த செயல்பாடு ஒரு \"கட்டமைப்பு\" பொருளை "
"அனுப்பியுள்ளது, மேலும் இது கொடுக்கப்பட்ட கட்டமைப்பு பிரிவுடன் தொடர்புடைய புதிய "
"\"அச்சுப்பொறி பொருளை\" திருப்பித் தர வேண்டும்."

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"புதிய அச்சுப்பொறி பொருளை நிறுவும் செயல்பாட்டின் போது, கொடுக்கப்பட்ட கட்டமைப்பு பிரிவில் "
"இருந்து அளவுருக்களைப் படிக்க கட்டமைப்பு பொருள் பயன்படுத்தப்படலாம். இது `config.get ()`, "
"`config.getfloat ()`, `config.getint ()`, முதலியன முறைகளைப் பயன்படுத்தி "
"செய்யப்படுகிறது. அச்சுப்பொறி பொருளின் கட்டுமானத்தின் போது உள்ளமைவிலிருந்து அனைத்து "
"மதிப்புகளையும் படிக்க மறக்காதீர்கள் - இந்த கட்டத்தில் படிக்காத ஒரு கட்டமைப்பு அளவுருவை பயனர்"
" குறிப்பிடினால், அது கட்டமைப்பில் ஒரு எழுத்துப்பிழை என்று கருதப்படும், மேலும் பிழை "
"உயர்த்தப்படும்."

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"முதன்மையான \"அச்சுப்பொறி\" வகுப்பைப் பெற `config.get_printer ()` முறையைப் "
"பயன்படுத்தவும். இந்த \"அச்சுப்பொறி\" வகுப்பு உடனடிப்படுத்தப்பட்ட அனைத்து "
"\"அச்சுப்பொறி பொருள்களையும்\" குறிப்புகளை சேமிக்கிறது. பிற அச்சுப்பொறி பொருள்களுக்கான "
"குறிப்புகளைக் கண்டறிய `printor.lookup_object ()` முறையைப் பயன்படுத்தவும். ஏறக்குறைய "
"அனைத்து செயல்பாடுகளும் (முக்கிய இயக்கவியல் தொகுதிகள் கூட) இந்த அச்சுப்பொறி பொருள்களில் "
"ஒன்றில் இணைக்கப்பட்டுள்ளன. இருப்பினும், ஒரு புதிய தொகுதி உடனடிப்படுத்தப்படும்போது, மற்ற "
"எல்லா அச்சுப்பொறி பொருள்களும் உடனடிப்படுத்தப்படாது என்பதை நினைவில் கொள்க. \"GCODE\" "
"மற்றும் \"ஊசிகள்\" தொகுதிகள் எப்போதும் கிடைக்கும், ஆனால் மற்ற தொகுதிகளுக்கு இது தேடலை "
"ஒத்திவைப்பது நல்லது."

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"`அச்சுப்பொறி. ஒவ்வொரு நிகழ்வு பெயரும் ஒரு சரம், மற்றும் மாநாட்டின் மூலம் இது முக்கிய மூல "
"தொகுதியின் பெயர், இது நிகழ்வை எழுப்பும் செயலுக்கு ஒரு குறுகிய பெயருடன் எழுப்புகிறது "
"(எ.கா., \"கிளிப்பி: இணைப்பு\"). ஒவ்வொரு நிகழ்வு கையாளுபவருக்கும் அனுப்பப்பட்ட "
"அளவுருக்கள் கொடுக்கப்பட்ட நிகழ்வுக்கு குறிப்பிட்டவை (விதிவிலக்கு கையாளுதல் மற்றும் "
"செயல்படுத்தல் சூழல் போன்றவை). இரண்டு பொதுவான தொடக்க நிகழ்வுகள்:"

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"கிளிப்பி: இணைப்பு - அனைத்து அச்சுப்பொறி பொருள்களும் உடனடிப்படுத்தப்பட்ட பிறகு இந்த நிகழ்வு"
" உருவாக்கப்படுகிறது. இது பொதுவாக மற்ற அச்சுப்பொறி பொருள்களைத் தேடுவதற்கும், கட்டமைப்பு "
"அமைப்புகளை சரிபார்க்கவும், அச்சுப்பொறி வன்பொருளுடன் ஆரம்ப \"ஏண்ட்சேக்\" செய்யவும் "
"பயன்படுத்தப்படுகிறது."

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"கிளிப்பி: ஆயத்தம் - அனைத்து இணைப்பு கையாளுபவர்களும் வெற்றிகரமாக முடிந்தபின் இந்த நிகழ்வு "
"உருவாக்கப்படுகிறது. அச்சுப்பொறி சாதாரண செயல்பாடுகளைக் கையாளத் தயாராக இருக்கும் "
"மாநிலத்திற்கு மாறுவதைக் குறிக்கிறது. இந்த அழைப்பில் பிழையை எழுப்ப வேண்டாம்."

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"பயனரின் உள்ளமைவில் பிழை இருந்தால், `load_config ()` அல்லது \"நிகழ்வு நிகழ்வு\" "
"கட்டங்களின் போது அதை உயர்த்த மறக்காதீர்கள். பிழையைப் புகாரளிக்க `config.error ("
"\" எனது பிழை \")` அல்லது `printur.config_error (\" எனது பிழை \") ஐ உயர்த்தவும்."

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"மைக்ரோ-கன்ட்ரோலரில் ஒரு முள் கட்டமைக்க \"பின்ச்\" தொகுதியைப் பயன்படுத்தவும். இது பொதுவாக "
"`அச்சுப்பொறி.லூக்அப்_ஆப்செக்ட் (\" ஊசிகள் \") போன்றவற்றுடன் செய்யப்படுகிறது. Setup_pin ("
"\" PWM \", config.get (\" my_pin \"))`. திரும்பிய பொருளை பின்னர் ரன்-டைமில் "
"கட்டளையிடலாம்."

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"தொகுதிக்கு கணினி நேரம் அல்லது வெளிப்புற கோப்பு விளக்கங்களுக்கான அணுகல் தேவைப்பட்டால், "
"உலகளாவிய \"நிகழ்வு உலை\" வகுப்பிற்கான அணுகலைப் பெற `அச்சுப்பொறி. இந்த உலை வகுப்பு "
"ஒருவர் டைமர்களை திட்டமிடவும், கோப்பு விளக்கங்களில் உள்ளீட்டிற்காக காத்திருக்கவும், புரவலன் "
"குறியீட்டை \"தூங்கவும்\" அனுமதிக்கிறது."

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"உலகளாவிய மாறிகள் பயன்படுத்த வேண்டாம். அனைத்து மாநிலங்களும் `load_config ()` "
"செயல்பாட்டிலிருந்து திரும்பிய அச்சுப்பொறி பொருளில் சேமிக்கப்பட வேண்டும். மறுதொடக்கம் கட்டளை"
" எதிர்பார்த்தபடி செயல்படாது என்பதால் இது முக்கியமானது. மேலும், இதே போன்ற காரணங்களுக்கா"
"க, ஏதேனும் வெளிப்புற கோப்புகள் (அல்லது சாக்கெட்டுகள்) திறக்கப்பட்டால், "
"\"கிளிப்பி: துண்டிக்கவும்\" நிகழ்வு கையாளுதலை பதிவுசெய்து அவற்றை அந்த அழைப்பிலிருந்து "
"மூடு."

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr ""
"பிற அச்சுப்பொறி பொருள்களின் உள் உறுப்பினர் மாறிகள் (அல்லது அடிக்கோடிட்டுக் கொண்டு தொடங்கும் "
"அழைப்பு முறைகள்) அணுகுவதைத் தவிர்க்கவும். இந்த மாநாட்டைக் கவனிப்பது எதிர்கால மாற்றங்களை "
"நிர்வகிப்பதை எளிதாக்குகிறது."

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr ""
"முதன்மையான கிளிப்பர் குறியீட்டில் சேர்ப்பதற்கான தொகுதியை சமர்ப்பித்தால், பதிப்புரிமை "
"அறிவிப்பை தொகுதியின் மேலே வைக்க மறக்காதீர்கள். விருப்பமான வடிவமைப்பிற்கு இருக்கும் "
"தொகுதிக்கூறுகளைப் பார்க்கவும்."

msgid "Adding new kinematics"
msgstr "புதிய இயக்கவியலைச் சேர்ப்பது"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"கூடுதல் வகை அச்சுப்பொறி இயக்கவியலுக்கு கிளிப்பருக்கு ஆதரவைச் சேர்ப்பதற்கான சில "
"உதவிக்குறிப்புகளை இந்த பிரிவு வழங்குகிறது. இந்த வகை செயல்பாட்டிற்கு இலக்கு "
"இயக்கவியலுக்கான கணித சூத்திரங்களைப் பற்றிய சிறந்த புரிதல் தேவைப்படுகிறது. இதற்கு "
"மென்பொருள் மேம்பாட்டு திறன்களும் தேவைப்படுகின்றன - இருப்பினும் ஒருவர் புரவலன் மென்பொருளை "
"மட்டுமே புதுப்பிக்க வேண்டும்."

msgid "Useful steps:"
msgstr "பயனுள்ள படிகள்:"

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"\"[ஒரு நகர்வின் குறியீடு ஓட்டம்] (#குறியீடு-ஃப்ளோ-ஆஃப்-ஏ-மூவ்-கமாண்ட்)\" பிரிவு மற்றும் "
"[இயக்கவியல் ஆவணம்] (Kinematics.md) ஆகியவற்றைப் படிப்பதன் மூலம் தொடங்கவும்."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"கிளிப்பி/ இயக்கவியல்/ கோப்பகத்தில் இருக்கும் இயக்கவியல் வகுப்புகளை மதிப்பாய்வு செய்யவும். "
"கார்ட்டீசியன் ஆயத்தொலைவுகளில் ஒரு நகர்வை ஒவ்வொரு ச்டெப்பரிலும் இயக்கத்திற்கு மாற்றும் பணியில் "
"ஈடுபடுகிறது. இந்த கோப்புகளில் ஒன்றை ஒரு தொடக்க புள்ளியாக ஒருவர் நகலெடுக்க முடியும்."

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"ஒவ்வொரு ச்டெப்பருக்கும் ஏற்கனவே கிடைக்கவில்லை என்றால் சி ச்டெப்பர் கினெமாடிக் நிலை "
"செயல்பாடுகளை செயல்படுத்தவும் (KIN_CART.C, KIN_COREXY.C, மற்றும் KIN_DELTA.C ஐப் "
"பார்க்கவும் கிளிப்பி/செல்/). கொடுக்கப்பட்ட நகர்வு நேரத்தை (நொடிகளில்) ஒரு கார்ட்டீசியன் "
"ஒருங்கிணைப்புக்கு (மில்லிமீட்டரில்) மாற்ற `MOVE_GET_COORD ()` ஐ அழைக்க வேண்டும், பின்னர் "
"அந்த கார்ட்டீசியன் ஒருங்கிணைப்பிலிருந்து விரும்பிய ச்டெப்பர் நிலையை (மில்லிமீட்டரில்) கணக்கிட "
"வேண்டும்."

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"புதிய இயக்கவியல் வகுப்பில் `calc_position ()` முறையை செயல்படுத்தவும். இந்த முறை "
"ஒவ்வொரு ச்டெப்பரின் நிலையிலிருந்தும் கார்ட்டீசியன் ஆயத்தொகுதிகளில் கருவித்தடத்தின் நிலையை "
"கணக்கிடுகிறது. இது பொதுவாக ஓமிங் மற்றும் ஆய்வு நடவடிக்கைகளின் போது மட்டுமே "
"அழைக்கப்படுவதால் இது திறமையாக இருக்க தேவையில்லை."

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"பிற முறைகள். `Check_move ()`, `get_status ()`, `get_steppers ()`, `வீடு ()`, "
"மற்றும் `set_position ()` முறைகளை செயல்படுத்தவும். இந்த செயல்பாடுகள் பொதுவாக இயக்கவியல்"
" குறிப்பிட்ட காசோலைகளை வழங்க பயன்படுத்தப்படுகின்றன. இருப்பினும், வளர்ச்சியின் தொடக்கத்தில் "
"ஒருவர் இங்கே கொதிகலன்-தட்டு குறியீட்டைப் பயன்படுத்தலாம்."

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"சோதனை வழக்குகளை செயல்படுத்தவும். கொடுக்கப்பட்ட இயக்கவியலுக்கான முக்கியமான நிகழ்வுகளை "
"சோதிக்கக்கூடிய தொடர் நகர்வுகளுடன் சி-குறியீடு கோப்பை உருவாக்கவும். இந்த சி-குறியீட்டு "
"கோப்பை மைக்ரோ-கன்ட்ரோலர் கட்டளைகளாக மாற்ற [பிழைத்திருத்த ஆவணங்கள்] (பிழைத்திருத்தம். எம்.டி)"
" ஐப் பின்தொடரவும். மூலையில் வழக்குகளை உடற்பயிற்சி செய்வதற்கும் பின்னடைவுகளை சரிபார்க்கவும் "
"இது பயனுள்ளதாக இருக்கும்."

msgid "Porting to a new micro-controller"
msgstr "புதிய மைக்ரோ-கன்ட்ரோலருக்கு போர்ட்டிங்"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr ""
"இந்த பிரிவு கிளிப்பரின் மைக்ரோ-கன்ட்ரோலர் குறியீட்டை ஒரு புதிய கட்டமைப்பிற்கு போர்ட்டிங் "
"செய்வதற்கான சில உதவிக்குறிப்புகளை வழங்குகிறது. இந்த வகை செயல்பாட்டிற்கு உட்பொதிக்கப்பட்ட "
"வளர்ச்சி மற்றும் இலக்கு மைக்ரோ-கன்ட்ரோலருக்கு அணுகல் பற்றிய நல்ல அறிவு தேவைப்படுகிறது."

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"துறைமுகத்தின் போது பயன்படுத்தப்படும் 3 வது தரப்பு நூலகங்களை அடையாளம் காண்பதன் மூலம் "
"தொடங்கவும். பொதுவான எடுத்துக்காட்டுகளில் \"CMSIS\" ரேப்பர்கள் மற்றும் உற்பத்தியாளர் \"HAL\""
" நூலகங்கள் அடங்கும். அனைத்து 3 வது தரப்பு குறியீடுகளும் குனு சி.பி.எல்.வி 3 இணக்கமாக "
"இருக்க வேண்டும். 3 வது தரப்பு குறியீடு கிளிப்பர் லிப்/ கோப்பகத்திற்கு உறுதியளிக்க வேண்டும்"
". நூலகம் எங்கு, எப்போது பெறப்பட்டது என்பது பற்றிய தகவலுடன் LIB/README கோப்பைப் "
"புதுப்பிக்கவும். குறியீட்டை கிளிப்பர் களஞ்சியத்தில் மாற்றாமல் நகலெடுப்பது விரும்பத்தக்கது, "
"ஆனால் ஏதேனும் மாற்றங்கள் தேவைப்பட்டால், அந்த மாற்றங்கள் LIB/README கோப்பில் வெளிப்படையாக "
"பட்டியலிடப்பட வேண்டும்."

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"எச்.ஆர்.சி/ கோப்பகத்தில் ஒரு புதிய கட்டமைப்பு துணை அடைப்பை உருவாக்கி, ஆரம்ப KCONFIG "
"மற்றும் மேக்ஃபைல் ஆதரவைச் சேர்க்கவும். ஏற்கனவே உள்ள கட்டமைப்புகளை வழிகாட்டியாகப் "
"பயன்படுத்தவும். எச்.ஆர்.சி/சிமுலேட்டர் குறைந்தபட்ச தொடக்க புள்ளியின் அடிப்படை உதாரணத்தை "
"வழங்குகிறது."

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"Console.py கருவியுடன் ([பிழைத்திருத்த ஆவணம்] (பிழைத்திருத்த ஆவணத்தில்) "
"விவரிக்கப்பட்டுள்ளபடி) நன்கு அறிந்து கொள்ளுங்கள், மேலும் அதனுடன் மைக்ரோ-கன்ட்ரோலருக்கான "
"இணைப்பை சரிபார்க்கவும். இந்த கருவி குறைந்த அளவிலான மைக்ரோ-கன்ட்ரோலர் கம்யூனிகேசன் "
"நெறிமுறையை மனித படிக்கக்கூடிய வடிவத்திற்கு மொழிபெயர்க்கிறது."

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr ""
"கட்டமைப்பு/ கோப்பகத்தில் மாதிரி கிளிப்பர் கட்டமைப்பு கோப்பை உருவாக்கவும். மைக்ரோ-கன்ட்ரோலரை "
"முதன்மையான klippy.py திட்டத்துடன் சோதிக்கவும்."

msgid "Consider adding build test cases in the test/ directory."
msgstr ""
"சோதனை/ கோப்பகத்தில் உருவாக்க சோதனை நிகழ்வுகளைச் சேர்ப்பதைக் கவனியுங்கள்."

msgid "Coordinate Systems"
msgstr "ஒருங்கிணைப்பு அமைப்புகள்"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"உள்நாட்டில், கிளிப்பர் முதன்மையாக கார்ட்டீசியன் ஆயத்தொகுதிகளில் கருவித்தடத்தின் நிலையை "
"கண்காணிக்கிறது, அவை கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் "
"தொடர்புடையவை. அதாவது, கிளிப்பர் குறியீட்டில் பெரும்பாலானவை ஒருபோதும் ஒருங்கிணைப்பு "
"அமைப்புகளில் மாற்றத்தை அனுபவிக்காது. தோற்றத்தை மாற்ற பயனர் ஒரு கோரிக்கையைச் செய்தால் (எ.கா"
"., ஒரு `சி 92` கட்டளை) பின்னர் எதிர்கால கட்டளைகளை முதன்மை ஒருங்கிணைப்பு அமைப்புக்கு "
"மொழிபெயர்ப்பதன் மூலம் அந்த விளைவு பெறப்படுகிறது."

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"இருப்பினும், சில சந்தர்ப்பங்களில், வேறு சில ஒருங்கிணைப்பு அமைப்பில் கருவித் தலை நிலையைப் "
"பெறுவது பயனுள்ளதாக இருக்கும், மேலும் அதை எளிதாக்க கிளிப்பருக்கு பல கருவிகள் உள்ளன. "
"Get_position கட்டளையை இயக்குவதன் மூலம் இதைக் காணலாம். உதாரணமாக:"

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"\"ச்டெப்பர்\" நிலை (`stepper.get_commanded_position ()`) என்பது இயக்கவியல் "
"குறியீட்டால் கண்காணிக்கப்பட்டபடி கொடுக்கப்பட்ட ச்டெப்பரின் நிலை. இது பொதுவாக அதன் ரயிலில் உள்"
"ள வண்டியின் நிலைக்கு (மிமீ) ஒத்திருக்கிறது, இது கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள "
"நிலை_எண்ட்ச்டாப்புடன் ஒப்பிடும்போது. . ஒருவர் `கருவிஎட்."

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"\"கினெமாடிக்\" நிலை (`KIN.Calc_Position ()`) என்பது \"ச்டெப்பர்\" நிலைகளிலிருந்து "
"பெறப்பட்ட கருவியின் கார்ட்டீசியன் நிலையாகும், மேலும் இது கட்டமைப்பு கோப்பில் "
"குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடையது. ச்டெப்பர் மோட்டார்சின் "
"கிரானுலாரிட்டி காரணமாக இது கோரப்பட்ட கார்ட்டீசியன் நிலையில் இருந்து வேறுபடலாம். "
"\"ச்டெப்பர்\" நிலைகள் எடுக்கப்படும்போது ரோபோ இயக்கத்தில் இருந்தால், அறிக்கையிடப்பட்ட மதிப்பில்"
" மைக்ரோ-கன்ட்ரோலரில் இடையகப்படுத்தப்பட்ட நகர்வுகள் அடங்கும், ஆனால் தோற்றமளிக்கும் வரிசையில் "
"நகர்வுகள் இல்லை. ஒருவர் `கருவிஎட்."

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"\"கருவிஎட்\" நிலை (`கருவிஎட். வினவல் வழங்கப்படும் போது ரோபோ இயக்கத்தில் இருந்தால், "
"அறிக்கையிடப்பட்ட மதிப்பில் கோரப்பட்ட அனைத்து நகர்வுகளும் அடங்கும் (ச்டெப்பர் மின்னோடி "
"டிரைவர்களுக்கு வழங்க காத்திருக்கும் இடையகங்களில் உள்ளவர்கள் கூட)."

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கார்ட்டீசியன் "
"ஆயத்தொகுதிகளில் `சி 1` (அல்லது` ஐயா 0`) கட்டளையிலிருந்து கடைசியாகக் கோரப்பட்ட நிலை "
"\"சி.சி.ஓ.டி\" நிலை. சி-குறியீடு மாற்றம் (எ.கா., படுக்கை_மெச், படுக்கை_பில்ட், "
"ச்கீ_க்யூரெக்சன்) நடைமுறையில் இருந்தால் இது \"கருவிஎட்\" நிலையிலிருந்து வேறுபடலாம். "
"சி-குறியீட்டு தோற்றம் மாற்றப்பட்டிருந்தால் (எ.கா., `சி 92`,` செட்_சி கோட்_ஓஃப்செட்`, `எம் "
"221`) கடந்த` ஐயா 1 கட்டளையில் குறிப்பிடப்பட்டுள்ள உண்மையான ஆயங்களிலிருந்து இது "
"வேறுபடலாம். `M114` கட்டளை (` gcode_move.get_status () ['gcode_position'] `)`) "
"தற்போதைய சி-குறியீடு ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கடைசி சி-குறியீடு நிலையைப் "
"புகாரளிக்கும்."

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"\"GCODE BASE\" என்பது கட்டமைப்பு கோப்பில் குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் "
"தொடர்புடைய கார்ட்டீசியன் ஆயத்தொகுதிகளில் சி-கோட் தோற்றத்தின் இருப்பிடமாகும். `G92`,` "
"set_gcode_offset`, மற்றும் `M221` போன்ற கட்டளைகள் இந்த மதிப்பை மாற்றுகின்றன."

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"`சி 28` முகப்பு கட்டளைக்குப் பிறகு சி-கோட் தோற்றத்திற்கு (கட்டமைப்பு கோப்பில் "
"குறிப்பிடப்பட்டுள்ள ஒருங்கிணைப்பு அமைப்புடன் தொடர்புடைய கார்ட்டீசியன் ஆயத்தொகுதிகளில்) "
"பயன்படுத்த வேண்டிய இடம்\" GCODE HOMING \"ஆகும். `Set_gcode_offset` கட்டளை இந்த "
"மதிப்பை மாற்றும்."

msgid "Time"
msgstr "நேரம்"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"கிளிப்பரின் செயல்பாட்டிற்கு அடிப்படையானது கடிகாரங்கள், நேரங்கள் மற்றும் நேர முத்திரைகளை "
"கையாள்வதாகும். எதிர்காலத்தில் நிகழும் நிகழ்வுகளை திட்டமிடுவதன் மூலம் கிளிப்பர் "
"அச்சுப்பொறியில் செயல்களைச் செயல்படுத்துகிறார். எடுத்துக்காட்டாக, விசிறியை இயக்க, குறியீடு "
"100 மீட்டரில் ஒரு GPIO முள் மாற்றத்தை திட்டமிடலாம். குறியீடு உடனடி நடவடிக்கை எடுக்க "
"முயற்சிப்பது அரிது. எனவே, கிளிப்பருக்குள் நேரத்தைக் கையாள்வது செயல்பாட்டை சரிசெய்ய "
"முக்கியமானது."

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr ""
"கிளிப்பர் புரவலன் மென்பொருளில் உள்நாட்டில் மூன்று வகையான நேரங்கள் கண்காணிக்கப்படுகின்றன:"

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"கணினி நேரம். கணினி நேரம் கணினியின் மோனோடோனிக் கடிகாரத்தைப் பயன்படுத்துகிறது - இது ஒரு"
" மிதக்கும் புள்ளி எண் விநாடிகளாக சேமிக்கப்படுகிறது, மேலும் இது புரவலன் கணினி கடைசியா"
"க தொடங்கப்பட்டபோது (பொதுவாக) தொடர்புடையது. கணினி நேரங்கள் மென்பொருளில் மட்டுப்படுத்தப்பட்"
"ட பயன்பாட்டைக் கொண்டுள்ளன - அவை இயக்க முறைமையுடன் தொடர்பு கொள்ளும்போது முதன்மையாகப் "
"பயன்படுத்தப்படுகின்றன. புரவலன் குறியீட்டிற்குள், கணினி நேரங்கள் அடிக்கடி *நிகழ்வு நேரம் "
"*அல்லது *CURIME *என்ற பெயரிடப்பட்ட மாறிகளில் சேமிக்கப்படுகின்றன."

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"நேரம் அச்சிடுக. அச்சு நேரம் முதன்மையான மைக்ரோ-கன்ட்ரோலர் கடிகாரத்துடன் ஒத்திசைக்கப்படுகிறது"
" (\"[MCU]\" கட்டமைப்பு பிரிவில் வரையறுக்கப்பட்ட மைக்ரோ-கட்டுப்பாட்டு). இது ஒரு மிதக்கும் "
"புள்ளி எண் விநாடிகளாக சேமிக்கப்படுகிறது மற்றும் முதன்மையான எம்.சி.யு கடைசியாக "
"மறுதொடக்கம் செய்யப்பட்டபோது தொடர்புடையது. MCU இன் நிலையான கட்டமைக்கப்பட்ட அதிர்வெண் வீதத்தால்"
" அச்சு நேரத்தை பெருக்கி \"அச்சு நேரத்திலிருந்து\" முதன்மையான மைக்ரோ-கன்ட்ரோலரின் வன்பொருள்"
" கடிகாரத்திற்கு மாற்ற முடியும். உயர் மட்ட புரவலன் குறியீடு கிட்டத்தட்ட எல்லா உடல் "
"செயல்களையும் (எ.கா., தலை இயக்கம், ஈட்டர் மாற்றங்கள் போன்றவை) கணக்கிட அச்சு நேரங்களைப் "
"பயன்படுத்துகிறது. புரவலன் குறியீட்டிற்குள், அச்சு நேரங்கள் பொதுவாக *print_time *அல்லது *"
"move_time *என்ற பெயரில் உள்ள மாறிகளில் சேமிக்கப்படுகின்றன."

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"MCU கடிகாரம். இது ஒவ்வொரு மைக்ரோ-கன்ட்ரோலரின் வன்பொருள் கடிகார கவுண்டராகும். இது ஒரு "
"முழு எண்ணாக சேமிக்கப்படுகிறது மற்றும் அதன் புதுப்பிப்பு வீதம் கொடுக்கப்பட்ட "
"மைக்ரோ-கன்ட்ரோலரின் அதிர்வெண்ணுடன் தொடர்புடையது. புரவலன் மென்பொருள் அதன் உள் நேரங்களை MCU "
"க்கு அனுப்புவதற்கு முன் கடிகாரங்களுக்கு மொழிபெயர்க்கிறது. எம்.சி.யு குறியீடு கடிகார "
"உண்ணியில் மட்டுமே நேரத்தைக் கண்காணிக்கிறது. புரவலன் குறியீட்டிற்குள், கடிகார மதிப்புகள் 64 "
"பிட் முழு எண்களாக கண்காணிக்கப்படுகின்றன, அதே நேரத்தில் MCU குறியீடு 32 பிட் முழு எண்களைப்"
" பயன்படுத்துகிறது. புரவலன் குறியீட்டிற்குள், கடிகாரங்கள் பொதுவாக *கடிகாரம் *அல்லது *உண்ணி"
" *கொண்ட பெயர்களுடன் மாறிகளில் சேமிக்கப்படுகின்றன."

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr ""
"வெவ்வேறு நேர வடிவங்களுக்கிடையேயான மாற்றம் முதன்மையாக ** கிளிப்பி/கடிகார்சின்க் ** "
"குறியீட்டில் செயல்படுத்தப்படுகிறது."

msgid "Some things to be aware of when reviewing the code:"
msgstr ""
"குறியீட்டை மதிப்பாய்வு செய்யும் போது விழிப்புடன் இருக்க வேண்டிய சில விசயங்கள்:"

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"32 பிட் மற்றும் 64 பிட் கடிகாரங்கள்: அலைவரிசையைக் குறைப்பதற்கும் மைக்ரோ-கன்ட்ரோலர் "
"செயல்திறனை மேம்படுத்துவதற்கும், மைக்ரோ-கன்ட்ரோலரில் உள்ள கடிகாரங்கள் 32 பிட் முழு எண்களாகக் "
"கண்காணிக்கப்படுகின்றன. MCU குறியீட்டில் இரண்டு கடிகாரங்களை ஒப்பிடும்போது, `"
"Timer_is_before ()` செயல்பாடு எப்போதும் முழு எண் ரோல்ஓவர்கள் சரியாக கையாளப்படுவதை "
"உறுதிப்படுத்த பயன்படுத்தப்பட வேண்டும். புரவலன் மென்பொருள் 32 பிட் கடிகாரங்களை 64 பிட் "
"கடிகாரங்களாக மாற்றுகிறது, இது பெற்ற கடைசி MCU நேர முத்திரையிலிருந்து உயர் -வரிசை "
"பிட்களைச் சேர்ப்பதன் மூலம் - MCU இலிருந்து எந்த செய்தியும் எதிர்காலத்தில் அல்லது கடந்த "
"காலங்களில் 2^31 கடிகார உண்ணிக்கு மேல் இல்லை, எனவே இந்த மாற்றம் ஒருபோதும் தெளிவற்றதல்ல . "
"புரவலன் 64 பிட் கடிகாரங்களிலிருந்து 32 பிட் கடிகாரங்களாக மாற்றுகிறது. இந்த மாற்றத்தில் "
"தெளிவற்ற தன்மை இல்லை என்பதை உறுதிப்படுத்த, ** கிளிப்பி/செல்பர்/சீரியால்கியூ."

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"பல மைக்ரோ-கன்ட்ரோலர்கள்: ஒற்றை அச்சுப்பொறியில் பல மைக்ரோ-கன்ட்ரோலர்களைப் பயன்படுத்தி புரவலன் "
"மென்பொருள் ஆதரிக்கிறது. இந்த வழக்கில், ஒவ்வொரு மைக்ரோ-கன்ட்ரோலரின் \"MCU கடிகாரமும்\" "
"தனித்தனியாக கண்காணிக்கப்படுகிறது. CrockSync.py குறியீடு மைக்ரோ-கன்ட்ரோலர்களிடையே கடிகா"
"ர சறுக்கலை \"அச்சு நேரத்திலிருந்து\" முதல் \"MCU கடிகாரம்\" ஆக மாற்றும் முறையை "
"மாற்றியமைப்பதன் மூலம் கையாளுகிறது. இரண்டாம் நிலை MCU களில், இந்த மாற்றத்தில் "
"பயன்படுத்தப்படும் MCU அதிர்வெண் அளவிடப்பட்ட சறுக்கலுக்கான கணக்கில் தொடர்ந்து "
"புதுப்பிக்கப்படுகிறது."

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"அனுப்பு: get_position\n"
" Recv: // mcu: stepper_a: -2060 STEPPER_B: -1169 STEPPER_C: -1613\n"
" Recv: // ச்டெப்பர்: ச்டெப்பர்_ஏ: 457.254159 ச்டெபர்_பி: 466.085669 ச்டெப்பர்_சி: 465."
"382132\n"
" Recv: // ginematic: x: 8.339144 y: -3.131558 z: 233.347121\n"
" Recv: // கருவிஎட்: x: 8.338078 y: -3.123175 Z: 233.347878 E: 0.000000\n"
" Recv: // gcode: x: 8.338078 y: -3.123175 Z: 233.347878 E: 0.000000\n"
" Recv: // gcode அடிப்படை: x: 0.000000 y: 0.000000 z: 0.000000 e: 0.000000\n"
" Recv: // gcode homing: x: 0.000000 y: 0.000000 z: 0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "குறியீடு கண்ணோட்டம்"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"\"MCU\" நிலை (`stepper.get_mcu_position ()` குறியீட்டில்) என்பது மைக்ரோ-கன்ட்ரோலர் "
"நேர்மறையான திசையில் வெளியிட்டுள்ள மொத்த படிகளின் எண்ணிக்கையாகும் மீட்டமை. வினவல் "
"வழங்கப்படும்போது ரோபோ இயக்கத்தில் இருந்தால், அறிக்கையிடப்பட்ட மதிப்பில் மைக்ரோ-கன்ட்ரோலரில் "
"இடையகப்படுத்தப்பட்ட நகர்வுகள் அடங்கும், ஆனால் தோற்றமளிக்கும் வரிசையில் நகர்வுகள் இல்லை."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"வன்பொருள் குறுக்கீடுகளிலிருந்து நேரங்குறிகருவி அனுப்புவதற்கு ஆதரவைச் சேர்க்கவும். கிளிப்பர்"
" [970831EE] (https://github.com/klipper3d/klipper/commit/"
"970831e0d3b91896e92270d98b2a3067427f) ஐக் காண்க 1-5 ஆர்கிடர் 1-5 க்கான "
"எடுத்துக்காட்டு."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"அடிப்படை GPIO உள்ளீடு மற்றும் வெளியீட்டு ஆதரவைக் கொண்டு வாருங்கள். இதற்கு ஒரு "
"எடுத்துக்காட்டு என்று கிளிப்பர் [commance c78b9076] (https://github.com/klipper3d/"
"klipper/commit/c78b90767f19e8510c315fb7ad64ca54 ஐக் காண்க)."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"கூடுதல் சாதனங்களைக் கொண்டு வாருங்கள் - எடுத்துக்காட்டாக கிளிப்பர் கமிட் [65613AED] "
"(https://github.com/klipper3d/klipper/commit/"
"65613aeddfb9ef86905cb1dade9e9a02ef3c27) PER/COMM/"
"C812A40A3782415E454B04BF7BD2158A6F0EC8B5 ."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"அச்சுப்பொறி பொருள் `get_status ()` முறையை வரையறுத்தால், தொகுதி [மேக்ரோச்] "
"(கட்டளை_டெம்ப்ளேட்ச்.எம்டி) மற்றும் [API சேவையகம்] (API_SERVER.MD) வழியாக [நிலை தகவல்] "
"(நிலை_ரொசெரன்ச்.எம்டி) ஏற்றுமதி செய்யலாம். `Get_status ()` முறை எண்கள், மிதவைகள், "
"சரங்கள், பட்டியல்கள், அகராதிகள், உண்மை, பொய் அல்லது எதுவுமில்லை என்று சரங்கள் மற்றும் "
"மதிப்புகள் கொண்ட விசைகள் கொண்ட பைதான் அகராதியை திருப்பித் தர வேண்டும். டூப்பிள்ச் (மற்றும் "
"பெயரிடப்பட்ட டூப்பிள்ச்) பயன்படுத்தப்படலாம் (ஏபிஐ சேவையகம் வழியாக அணுகும்போது இவை "
"பட்டியல்களாகத் தோன்றும்). ஏற்றுமதி செய்யப்படும் பட்டியல்கள் மற்றும் அகராதிகள் \"மாறாதவை\" "
"என்று கருதப்பட வேண்டும் - அவற்றின் உள்ளடக்கங்கள் மாறினால், ஒரு புதிய பொருள் `Get_status "
"()` இலிருந்து திருப்பித் தரப்பட வேண்டும், இல்லையெனில் பநிஇ சேவையகம் அந்த மாற்றங்களைக் "
"கண்டறியாது."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr ""
"பைதான் வகுப்புகளின் பைதான் கட்டமைப்பாளரில் உள்ள அனைத்து உறுப்பினர் மாறிகளுக்கும் ஒரு "
"மதிப்பை ஒதுக்க பரிந்துரைக்கப்படுகிறது. (எனவே புதிய உறுப்பினர் மாறிகள் மாறும் வகையில் "
"பைத்தானின் திறனைப் பயன்படுத்துவதைத் தவிர்க்கவும்.)"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"ஒரு பைதான் மாறி ஒரு மிதக்கும் புள்ளி மதிப்பை சேமிக்க வேண்டும் என்றால், அந்த மாறியை "
"மிதக்கும் புள்ளி மாறிலிகளுடன் எப்போதும் ஒதுக்கவும் கையாளவும் பரிந்துரைக்கப்படுகிறது "
"(மற்றும் ஒருபோதும் முழு எண் மாறிலிகளைப் பயன்படுத்த வேண்டாம்). எடுத்துக்காட்டாக, `"
"self.speed = 1.` ஐ விட` self.speed = 1` ஐ விரும்புங்கள், மேலும் `self.speed = 2 "
"ஐ விரும்புங்கள். * X` over` self.speed = 2 * x`. மிதக்கும் புள்ளி மதிப்புகளின் நிலையா"
"ன பயன்பாடு பைதான் வகை மாற்றங்களில் க்யூர்க்சை பிழைத்திருத்துவது கடினம்."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"முதல் முக்கிய குறியீட்டு பணி இலக்கு வாரியத்திற்கு தகவல்தொடர்பு ஆதரவை கொண்டு வருவதாகும். "
"புதிய துறைமுகத்தில் இது மிகவும் கடினமான படியாகும். அடிப்படை தொடர்பு செயல்பட்டவுடன், "
"மீதமுள்ள படிகள் மிகவும் எளிதாக இருக்கும். ஆரம்ப வளர்ச்சியின் போது UART வகை தொடர் "
"சாதனத்தைப் பயன்படுத்துவது பொதுவானது, ஏனெனில் இந்த வகையான வன்பொருள் சாதனங்கள் பொதுவாக "
"செயல்படுத்தவும் கட்டுப்படுத்தவும் எளிதானவை. இந்த கட்டத்தின் போது, "
"எச்.ஆர்.சி/பொதுவான/கோப்பகத்திலிருந்து உதவி குறியீட்டை தாராளமாகப் பயன்படுத்துங்கள் "
"(எச்.ஆர்.சி/சிமுலேட்டர்/மேக்ஃபைல் எவ்வாறு பொதுவான சி குறியீட்டை உருவாக்குகிறது என்பதைச் "
"சரிபார்க்கவும்). இந்த கட்டத்தில் Timer_read_time () (இது தற்போதைய கணினி கடிகாரத்தை "
"வழங்குகிறது) வரையறுப்பதும் தேவை, ஆனால் நேரங்குறிகருவி IRQ கையாளுதலை முழுமையாக "
"ஆதரிக்க வேண்டிய அவசியமில்லை."

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "கூடுதல் குறியீட்டு உதவிக்குறிப்புகள்:"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"IO பதிவேடுகளை அணுக \"சி பிட்ஃபீல்ட்ச்\" பயன்படுத்துவதைத் தவிர்க்கவும்; 32 பிட், 16 பிட் "
"அல்லது 8 பிட் எண்களின் நேரடி வாசிப்பு மற்றும் எழுத செயல்பாடுகளை விரும்புங்கள். சி "
"பிட்ஃபீல்ட்களை (எ.கா., எண்டியன்னச் மற்றும் பிட் தளவமைப்பு) எவ்வாறு செயல்படுத்த வேண்டும் என்பதை"
" சி மொழி விவரக்குறிப்புகள் தெளிவாகக் குறிப்பிடவில்லை, மேலும் சி பிட்ஃபீல்ட் வாசிப்பு "
"அல்லது எழுதுவதில் ஐ.ஓ செயல்பாடுகள் என்ன நிகழும் என்பதை தீர்மானிப்பது கடினம்."

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"வாசிப்பு-மாடிஃபை-ரைட் செயல்பாடுகளைப் பயன்படுத்துவதற்குப் பதிலாக IO பதிவேடுகளுக்கு "
"வெளிப்படையான மதிப்புகளை எழுத விரும்புங்கள். அதாவது, மற்ற புலங்கள் அறிந்த மதிப்புகளைக் "
"கொண்ட ஒரு IO பதிவேட்டில் ஒரு புலத்தைப் புதுப்பித்தால், பதிவின் முழு உள்ளடக்கங்களையும் "
"வெளிப்படையாக எழுதுவது விரும்பத்தக்கது. சிறிய, வேகமான மற்றும் பிழைத்திருத்தத்திற்கு "
"எளிதான குறியீட்டை வெளிப்படையான எழுதுகிறது."

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"பணி, init மற்றும் கட்டளை செயல்பாடுகள் எப்போதும் இயக்கப்பட்ட குறுக்கீடுகளுடன் இயங்குகின்றன "
"(இருப்பினும், தேவைப்பட்டால் அவை தற்காலிகமாக குறுக்கீடுகளை முடக்கலாம்). இந்த செயல்பாடுகள் "
"நீண்ட இடைநிறுத்தங்கள், தாமதங்கள் அல்லது குறிப்பிடத்தக்க நேரம் நீடிக்கும் வேலைகளைத் தவிர்க்க "
"வேண்டும். . டைமர்களை திட்டமிடுவதன் மூலம் குறிப்பிட்ட நேரங்கள்."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> LookAheadQueue.add_move() -> LookAheadQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"கருவிஎச் வகுப்பு (கருவியில்) \"தோற்றத்தை\" கையாளுகிறது மற்றும் அச்சிடும் செயல்களின் "
"நேரத்தைக் கண்காணிக்கிறது. ஒரு நகர்வுக்கான முக்கிய குறியீட்டு முறை: `கருவிஎட்."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"LookAheadQueue.add_move() places the move object on the \"look-ahead\" "
"queue."
msgstr ""
"Lookaheadqueue.add_move () நகரும் பொருளை \"தோற்றமளிக்கும்\" வரிசையில் வைக்கிறது."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"LookAheadQueue.flush() determines the start and end velocities of each move."
msgstr ""
"Lookaheadqueue.flush () ஒவ்வொரு நகர்வின் தொடக்க மற்றும் இறுதி வேகங்களை தீர்மானிக்கிறது."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._advance_move_time() -> ToolHead._advance_flush_time() -> "
"MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> "
"itersolve_gen_steps_range()` (in klippy/chelper/itersolve.c). The goal of "
"the iterative solver is to find step times given a function that calculates "
"a stepper position from a time. This is done by repeatedly \"guessing\" "
"various times until the stepper position formula returns the desired "
"position of the next step on the stepper. The feedback produced from each "
"guess is used to improve future guesses so that the process rapidly "
"converges to the desired time. The kinematic stepper position formulas are "
"located in the klippy/chelper/ directory (eg, kin_cart.c, kin_corexy.c, "
"kin_delta.c, kin_extruder.c)."
msgstr ""
"ஒவ்வொரு ச்டெப்பருக்கும் படி நேரங்களை உருவாக்க கிளிப்பர் ஒரு [மறுசீரமைப்பு தீர்வி] "
"(https://en.wikipedia.org/wiki/root-finding_algorithm) ஐப் பயன்படுத்துகிறார். "
"செயல்திறன் காரணங்களுக்காக, ச்டெப்பர் துடிப்பு நேரங்கள் சி குறியீட்டில் உருவாக்கப்படுகின்றன. "
"நகர்வுகள் முதலில் \"ட்ரெப்சாய்டு மோசன் வரிசையில்\" வைக்கப்பட்டுள்ளன: `கருவித்தொகுப்பு. படி "
"நேரங்கள் பின்னர் உருவாக்கப்படுகின்றன: `கருவிஎட். /itersolve.c). ஒரு காலத்திலிருந்து ஒரு"
" ச்டெப்பர் நிலையை கணக்கிடும் ஒரு செயல்பாட்டைக் கொடுக்கப்பட்ட படி நேரங்களைக் கண்டுபிடிப்பதே "
"மறு செய்கை தீர்வின் குறிக்கோள். ச்டெப்பர் நிலை தேற்றம் ச்டெப்பரில் அடுத்த கட்டத்தின் விரும்பிய "
"நிலையை திரும்பும் வரை பல்வேறு முறை மீண்டும் மீண்டும் \"யூகிப்பதன்\" மூலம் இது "
"செய்யப்படுகிறது. ஒவ்வொரு யூகத்திலிருந்தும் தயாரிக்கப்படும் பின்னூட்டங்கள் எதிர்கால யூகங்களை "
"மேம்படுத்த பயன்படுகின்றன, இதனால் செயல்முறை விரைவாக விரும்பிய நேரத்திற்கு மாறுகிறது. "
"கினெமாடிக் ச்டெப்பர் நிலை சூத்திரங்கள் கிளிப்பி/ செல்பர்/ கோப்பகத்தில் அமைந்துள்ளன (எ.கா."

#~ msgid ""
#~ "The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
#~ "timing of printing actions. The main codepath for a move is: "
#~ "`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
#~ "Move.set_junction() -> ToolHead._process_moves()`."
#~ msgstr ""

#~ msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
#~ msgstr ""

#~ msgid ""
#~ "MoveQueue.flush() determines the start and end velocities of each move."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
