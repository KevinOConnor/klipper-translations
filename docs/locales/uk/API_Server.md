# Сервер API

Цей документ описує Прикладний Програмний Інтерфейс Klipper (ППІ). Цей інтерфейс дає змогу зовнішнім застусункам опитувати та керувати хостове програмне забезпечення Klipper.

## Увімкнення розетки API

Для використання сервера API, klippy. py хост програмне забезпечення необхідно запустити з параметром `-a`. Наприклад:

```
~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~ /printer.cfg -a /tmp/klippy_uds -l /tmp/klippy.log
```

Це викликає програмне забезпечення для створення Unix Domain Socket. Клієнт може потім відкрити підключення на цьому розетці і відправити команди в Klipper.

Дивитися проект [Moonraker](https://github.com/Arksine/moonraker) для популярного інструменту, який може переадресувати HTTP-запити на API сервер Unix .

## Формат запиту

Повідомлення, надіслані та отримані на розетці, JSON закодовані рядки, припинені символом ASCII 0x03:

```
<json_object_1><0x03><json_object_2><0x03>...
```

Klipper містить `scripts/whconsole.py` інструмент, який може виконати надсилання повідомлення. Наприклад:

```
~/klipper/scripts/whconsole.py /tmp/klippy_uds
```

Цей інструмент може прочитати ряд команд JSON від stdin, відправити їх на Klipper, і звітувати результати. Інструмент очікує кожного командного рядка JSON, і він автоматично доповнить термінатор 0x03 при передачі запиту. (На сервері API Klipper не має вимог до новалінії.)

## Протокол API

Протокол команд, що використовується на розетці зв'язку, надихається [json-rpc](https://www.jsonrpc.org/).

Запит може виглядати:

`{"id": 123, "метод": "info", "params": `

і відповідь може виглядати так:

`{"id": 123, "result": {"state_message": "Принтер готовий", "klipper_path": "/home/pi/klipper", "config_file": "/home/pi/printer.cfg" , "software_version": "v0.8.0-823-g883b1cb6", "hostname": "octopi", "cpu_info": "4-ядерний процесор ARMv7 rev 4 (v7l)", "state": "ready", "python_path" : "/home/pi/klippy-env/bin/python", "log_file": "/tmp/klippy.log"}}`

Кожен запит повинен бути словником JSON. (Цей документ використовує код Python "дикий" для опису "об'єкт JSON" - картографування пар ключових/значення, що містяться в `{}`.)

Словник запиту повинен містити параметр "метод", який є іменем рядка доступних Кліппер "Додаткова точка".

Словник запиту може містити параметр "парам", який повинен бути словникового типу. Додаткова інформація параметра до Klipper "endpoint" за запитом. Його зміст є специфічним для "ендочка".

Словник запиту може містити параметр "id", який може бути будь-якого типу JSON. Якщо "ід" присутній, то Klipper буде реагувати на запит з повідомленням відповіді, що містить "ід". Якщо "ід" вдається (або встановити значення JSON "нуль"), то Klipper не забезпечить відповіді на запит. Відповідне повідомлення є словником JSON, що містить "id" і "result". "реулт" завжди є словником - його вміст специфічний для "ендочка" обробки запиту.

Якщо обробка результатів запиту в похибці, то повідомлення про відповідь буде містити поле "error" замість поля "результати". Наприклад, запит: `{"id": 123, "метод": "кодування/script", "params": {"script": "G1 X200"}}` може призвести до відповіді на помилки, такі як: `{"id": 123, "error": {"message": "Муста вісь будинку спочатку: 200.000 0.000 [0.000]", "error": "Веб-резахід"}}`

Для того, щоб вони отримали. Проте деякі запити не можуть бути заповнені відразу, що може призвести до того, що асоційований відповідь буде відправлено з порядку, що стосується відповіді з інших запитів. Запит JSON ніколи не призупинить обробку запитів JSON.

## Підписка

Деякі запити Klipper "endpoint" дають змогу "писати" майбутнім повідомленням про оновлення асинхронного оновлення.

Наприклад:

`{"id": 123, "метод": "Gcode/subscribe_вихід", "params": {"response_template":{"key": 345`

може спочатку відповісти:

`{"id": 123, "реулт": `

і викликати Klipper для відправки майбутніх повідомлень аналогічно:

`{"params": {"response": "ok B:22.8 /0.0 T0:22.4 /0.0"}, "під ключ": 345}`

Запит на підписку приймає словник "response_template" у полі "params" запиту. Цей словник "response_template" використовується як шаблон для майбутніх асинхронних повідомлень - він може містити довільні ключі / значення пар. Коли надсилання цих майбутніх асинхронних повідомлень, Klipper додасть поле "парам", що містить словник "endpoint" специфічний вміст до шаблону відповіді, а потім відправить цей шаблон. Якщо поле "response_template" не передбачено, то він за замовчуванням до порожній словник (`{}`).

## Доступні пункти

За конвенцією, Klipper "endpoints" є формою `<module_name>/<some_name>`. При виготовленні запиту на "пошук", повне ім'я необхідно встановити в параметрі "метод" словника запиту (наприклад, `{"method"="gcode/restart"}`).

### контакти

Кінцева точка "info" використовується для отримання інформації про систему та версію від Klipper. Також використовується для надання інформації про версію клієнта на Klipper. Наприклад: `{"id": 123, "метод": "info", "params": { "client_info": { "версія": "v1"upload`

Якщо присутній параметр "client_info" повинен бути словником, але цей словник може мати довільний вміст. Клієнти заохочуються надати ім'я клієнта та його версію програмного забезпечення при першому підключенні до сервера API Klipper.

### аварійне обслуговування

Кінцева точка "emergency_stop" використовується для переходу на стан "пошуку". До команди G-Code `M112`. Наприклад: `{"id": 123, "метод": "emergency_stop"}`

### register_remote_method

Цей кінцевий пункт дозволяє клієнтам реєструвати методи, які можна назвати від klipper. Повернути порожній об'єкт на успіх.

Наприклад: `{"id": 123, "метод": "register_remote_method", "params": {"response_template": {"action": "run_paneldue_beep"}, "remote_method": "paneldue_beep"}}` повернеться: `{"id": 123, "result": {}}`

Віддалений метод `paneldue_beep` тепер можна назвати від Klipper. Зверніть увагу, що якщо метод приймає параметри, які вони повинні бути надані як аргументи ключових фраз. Нижче наведено приклад того, як він може називатися з gcode_macro:

```
[gcode_macro PANELDUE_BEEP]
 gcode:
   {action_call_remote_method("paneldue_beep", frequency=300, duration=1.0)}
```

Коли виконується макрокод PANELDUE_BEEP, Klipper відправить щось схоже на наступне над розеткою: `{"action": "run_paneldue_beep", "params": {"частота": 300, "duration": 1.0}}`

### об'єкти/список

Ця кінцева точка запитує список доступних принтерів "об'єктів", які можуть запитати (через кінцеву точку "об'єктів / стека". Наприклад: `{"id": 123, "метод": "objects/list"}` може повернутися: `{"id": 123, "result": {"objects": ["webhooks", "configfile", "heaters", "gcode_move", "query_endstops", "idle_timeout", "toolhead", "extruder"]}}`

### об'єкти

Ця кінцева точка дозволяє отримувати інформацію від принтерів. Наприклад: `{"id": 123, "метод": "об'єкти/квір", "парам": {"objects": {"toolhead": ["Положення"], "webhooks": nullfactory` може повернути: `{"id": 123, "result": {"status": {"webhooks": {"state": "ready", "state_message": "Принтер готовий"}, "toolhead": {"позиція": [0.0, 0.0, 0.0, 0.0]}}, "eventtime": 3051.33679[X]

Параметри параметра "об'єкти" в запиті повинні бути словником, що містить об'єкти принтера, які повинні бути перевірені - ключ містить назву об'єкта принтера і значення є або "нуль" (для запиту всіх полів) або список назв поля.

Відповідне повідомлення містить поле "статус", що містить словник з перевіреною інформацією - ключ містить назву об'єкта принтера і значення є словником, що містить його поля. Відповідне повідомлення також буде містити поле "навчання", що містить часовий запас, коли було прийнято запит.

Доступні поля задокументовані у документі [Status Reference](Status_Reference.md).

### об'єктів/підп

Ця кінцева точка дозволяє переробити, а потім підписатися на інформацію з об'єктів принтера. Запит кінцевої точки та відповідь ідентична кінцевій точці "об'єктів / стежки". Наприклад: `{52"id": 123, "метод": "об'єкти/писати", "парам": {"об'єкти":{"toolhead": ["Положення"], "webhooks": ["держава"]}, "відповіді_template":{{` може повернутися: `{"id": 123, "регулятор": {"status": {"webhooks": {"state": "повідомлення"}, "toolhead": {"позиція": [0.0, 0.0, 0.0, 0.0]}}, "події: 3052153.382083195[165]

### gcode/help

Ця кінцева точка дозволяє одному запиту доступні команди G-Code, які мають рядок, визначений. Наприклад: `{"id": 123, "метод": "gcode/help"}` може повернутися: `{"id": 123, "реулт": {"RESTORE_GCODE_STATE": "Відновити раніше збережений стан G-Code", "PID_CALIBRATE": "Вихід калібрування PID", "QUERY_ADC": "Репортувати останнє значення аналогового штифта", ..._`

### gcode/script

Цей кінцевий пункт дозволяє запустити серію команд G-Code. Наприклад: `{"id": 123, "метод": "кодування/script", "парми": {"script": "G90"}}`

Якщо надана скрипт G-Code підвищує помилку, то створюється відповідь про помилку. Тим не менш, якщо команда G-Code виробляє вихід терміналу, що вихід терміналу не надається у відповідь. (Використовувати кінцеву точку кінцевого пункту "gcode/subscribe_виходу" G-Code.)

Якщо є команда G-Code, яка обробляється при отриманні цього запиту, то надана сцена буде черги. Ця затримка може бути значним (наприклад, якщо працює G-Code). Повідомлення про відповідь JSON направляється при обробці сценарію повністю завершено.

### gcode/restart

Ця кінцева точка дозволяє запитувати решту - вона схожа на запуск команди G-Code "RESTART". Наприклад: `{"id": 123, "метод": "gcode/restart"}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### gcode/firmware_restart

Це схоже на кінцеву точку "gcode/restart" - він реалізує команду G-Code "FIRMWARE_RESTART". Наприклад: `{"id": 123, "метод": "gcode/firmware_restart"}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### g code/subscribe_output

Цей кінцевий пункт використовується для підписки на G-Code термінал повідомлень, які генеруються Klipper. Наприклад: `{"id": 123, "метод": "gcode/subscribe_вихід", "params": {"response_template":{` може бути пізніше виготовляти асинхронні повідомлення, такі як: `{"params": {"response": "//Klipper State: Shutdown"}}`

Ця кінцева точка призначена для підтримки взаємодії людини за допомогою інтерфейсу «термінального вікна». Утилізація вмісту в терміналі G-Code Використовуйте кінцеву точку "objects/subscribe" для отримання оновлень на державі Кліппера.

### motion_report/dump_stepper

Ця кінцева точка використовується для підписки на внутрішню чергу командного рядка Klipper. Зберігаючи ці оновлення руху низького рівня можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод":"motion_report/dump_stepper", "params": {"name": "stepper_x", "response_template": {contact` і може повернутися: `{"id": 123, "result": {"9442"", "count", "add"]` і може пізніше випускати асинхронні повідомлення, такі як: `{"params": {"first_clock": 179601081 "first_978"first_97_88_88_88_88_88_88_88_88"

Поле "голова" в початковій відповіді запиту використовується для опису полів, знайдених в більш пізній "data".

### javascript licenses api веб-сайт

Ця кінцева точка використовується для підписки на внутрішню «трапецієподібну чергу руху». Зберігаючи ці оновлення руху низького рівня можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод": "motion_report/dump_trapq", "params": {"name": "toolhead", "response_template":{ 0.04` і може повернутися: `{"id": 1, "result": {"header": ["time", "тривалість", "start_velocity", " 0.030" 0.03" 0.030"

Поле "голова" в початковій відповіді запиту використовується для опису полів, знайдених в більш пізній "data".

### adxl345/ dump_adxl345

Ця кінцева точка використовується для підписки на дані акселерометра ADXL345. Зберігаючи ці оновлення руху низького рівня можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод":"adxl345/dump_adxl345", "params": {"sensor": "adxl345", "response_template": ` і може повернутися: `{"id": 123,"result":{"header":["time","x_acceleration", "_acceleration", "z_acceleration"]}}` і може пізніше випускати асинхронні повідомлення, такі як: `{"params":{"overflows":0,"data": [[3292.432935,-535.44309,-1529.8374,9561.4], [3292.433256,-382.45935,-1606.32927,95.484]

Поле "голова" в початковій відповіді запиту використовується для опису полів, знайдених в більш пізній "data".

### angle/ dump_angle

Ця кінцева точка використовується для підписки на дані датчика [кутник](Config_Reference.md#angle). Зберігаючи ці оновлення руху низького рівня можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод":"кутник/dump_кутник", "params": "my_angle_sensor", "response_template": {contact` і може повернутися: `{"id": 123,"result":{"header":["time","angle"]}}` і може пізніше випускати асинхронні повідомлення, такі як: `{"params":{"tion_offset":3.1512,"errors:012[12]

Поле "голова" в початковій відповіді запиту використовується для опису полів, знайдених в більш пізній "data".

### hx71x/dump_hx71x

Ця кінцева точка використовується для підписки на сирі дані HX711 та HX717 ADC. Отримуючи ці оновлення низького рівня ADC можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод":"hx71x/dump_hx71x", "params": {"sensor": "load_cell", "response_template": ` і може повернутися: `{"id": 123,"result":{"header":["time", "counts","value"]}}` і може пізніше виробляти асинхронні повідомлення, такі як: `{"params":{"data":[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}`

### ads1220/ dump_ads1220

Ця кінцева точка використовується для підписки на сирі дані ADS1220 ADC. Отримуючи ці оновлення низького рівня ADC можуть бути корисними для діагностичних і знеболюючих цілей. Використання цього кінцевого пункту може збільшити навантаження системи Klipper.

Запит може виглядати як: `{"id": 123, "метод":"ads1220/dump_ads1220", "params": "load_cell", "response_template": ` і може повернутися: `{"id": 123,"result":{"header":["time", "counts","value"]}}` і може пізніше виробляти асинхронні повідомлення, такі як: `{"params":{"data":[3292.432935, 562534, 0.067059278], [3292.4394937, 5625322, 0.670590639]]}}`

### пауза_resume/cancel

Ця кінцева точка схожа на запуск "PRINT_CANCEL" G-Code команди. Наприклад: `{"id": 123, "метод": "pause_resume/cancel"}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### pause_resume / пауза

Ця кінцева точка схожа на запуск команди G-Code. Наприклад: `{"id": 123, "метод": "pause_resume/pause"}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### pause_resume/ resume

Цей кінцевий пункт схожий на запуск "RESUME" G-Code команди. Наприклад: `{"id": 123, "метод": "pause_resume/resume"}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### query_endstops/ status

Цей кінцевий пункт буде запитувати активні кінцеві точки та повернути їх статус. Наприклад: `{"id": 123, "метод": "query_endstops/status"}` може повернутися: `{"id": 123, "result": {"y": "відкрито", "x": "відкрито", "z": "TRIGGERED"}}`

Як з кінцевою точкою "gcode/script" цей кінцевий пункт завершується тільки після завершення будь-яких команд G-Code.

### bed_mesh/ dump_mesh

Дамп конфігурації та стану для поточної сітки та всіх збережених профілів.

Наприклад: `{"id": 123, "метод": "bed_mesh/dump_mesh"}`

може повернутись:

```
{
     "current_mesh": {
         "name": "eddy-scan-test",
         "probed_matrix": [...],
         "mesh_matrix": [...],
         "mesh_params": {
             "x_count": 9,
             "y_count": 9,
             "mesh_x_pps": 2,
             "mesh_y_pps": 2,
             "algo": "бікубічний",
             "натяг": 0,5,
             "min_x": 20,
             "max_x": 330,
             "min_y": 30,
             "max_y": 320
         }
     },
     "профілі": {
         "за умовчанням": {
             "точки": [...],
             "mesh_params": {
                 "min_x": 20,
                 "max_x": 330,
                 "min_y": 30,
                 "max_y": 320,
                 "x_count": 9,
                 "y_count": 9,
                 "mesh_x_pps": 2,
                 "mesh_y_pps": 2,
                 "algo": "бікубічний",
                 «натяг»: 0,5
             }
         },
         "eddy-scan-test": {
             "точки": [...],
             "mesh_params": {
                 "x_count": 9,
                 "y_count": 9,
                 "mesh_x_pps": 2,
                 "mesh_y_pps": 2,
                 "algo": "бікубічний",
                 "натяг": 0,5,
                 "min_x": 20,
                 "max_x": 330,
                 "min_y": 30,
                 "max_y": 320
             }
         },
         "eddy-rapid-test": {
             "точки": [...],
             "mesh_params": {
                 "x_count": 9,
                 "y_count": 9,
                 "mesh_x_pps": 2,
                 "mesh_y_pps": 2,
                 "algo": "бікубічний",
                 "натяг": 0,5,
                 "min_x": 20,
                 "max_x": 330,
                 "min_y": 30,
                 "max_y": 320
             }
         }
     },
     "калібрування": {
         "точки": [...],
         "конфігурація": {
             "x_count": 9,
             "y_count": 9,
             "mesh_x_pps": 2,
             "mesh_y_pps": 2,
             "algo": "бікубічний",
             "натяг": 0,5,
             "mesh_min": [
                 20,
                 30
             ],
             "mesh_max": [
                 330,
                 320
             ],
             "походження": null,
             "радіус": нуль
         },
         "probe_path": [...],
         "швидкий_шлях": [...]
     },
     "probe_offsets": [
         0,
         25,
         0,5
     ],
     "axis_minimum": [
         0,
         0,
         -5,
         0
     ],
     "axis_maximum": [
         351,
         358,
         330,
         0
     ]
 }
```

Кінцева точка `dump_mesh` приймає один необов’язковий параметр, `mesh_args`. Цей параметр має бути об’єктом, де ключі та значення є параметрами, доступними для [BED_MESH_CALIBRATE](#bed_mesh_calibrate). Це оновить конфігурацію сітки та точки зонду за допомогою наданих параметрів перед поверненням результату. Рекомендується опускати параметри сітки, якщо не потрібно візуалізувати точки зонда та/або траєкторію перед виконанням `BED_MESH_CALIBRATE`.
