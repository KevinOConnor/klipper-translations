# Мапа поверхні

Модуль Bed Mesh можна використовувати для компенсації нерівностей поверхні ліжка для досягнення кращого першого шару по всьому ліжку. Слід зазначити, що програмна корекція не дасть ідеальних результатів, вона може лише наблизити форму ліжка. Bed Mesh також не може компенсувати механічні та електричні проблеми. Якщо вісь перекошена або датчик неточний, модуль bed_mesh не отримає точні результати процесу вимірювання.

Перед калібруванням сітки вам потрібно буде переконатися, що Z-зсув вашого зонда відкалібровано. Якщо використовується кінцевий упор для наведення по осі Z, його також потрібно буде відкалібрувати. Для отримання додаткової інформації див. [Probe Calibrate](Probe_Calibrate.md) і Z_ENDSTOP_CALIBRATE у [Manual Level](Manual_Level.md).

## Базова конфігурація

### Прямокутні ліжка

У цьому прикладі передбачається, що принтер має прямокутну платформу розміром 250 мм x 220 мм і датчик зі зміщенням по осі Х 24 мм і зміщенням по осі 5 мм.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
```

- `швидкість: 120` *Значення за замовчуванням: 50* Швидкість, з якою інструмент рухається між точками.
- `horizontal_move_z: 5` *Значення за замовчуванням: 5* Координата Z, до якої зонд піднімається перед подорожжю між точками.
- `mesh_min: 35, 6` *Обов’язковий* Перша досліджена координата, найближча до початку координат. Ця координата відноситься до місця розташування зонда.
- `mesh_max: 240, 198` *Обов’язковий* Найдальша від початку координат досліджувати координата. Це не обов’язково остання досліджувана точка, оскільки процес зондування відбувається зигзагоподібно. Як і у випадку з `mesh_min`, ця координата є відносною розташування зонда.
- `probe_count: 5, 3` *Значення за замовчуванням: 3, 3* Кількість точок для перевірки на кожній осі, указана як цілі числа X, Y. У цьому прикладі 5 точок буде досліджено вздовж осі X і 3 точки вздовж осі Y, тобто 15 точок. Зверніть увагу: якщо вам потрібна квадратна сітка, наприклад 3x3, це можна вказати як єдине ціле число, яке використовується для обох осей, тобто `probe_count: 3`. Зауважте, що сітка вимагає мінімум probe_count 3 уздовж кожної осі.

На ілюстрації нижче показано, як параметри `mesh_min`, `mesh_max` і `probe_count` використовуються для створення точок зондування. Стрілки вказують напрямок процедури зондування, починаючи з `mesh_min`. Для довідки, коли зонд знаходиться на `mesh_min`, сопло буде на (11, 1), а коли зонд на `mesh_max`, сопло буде на (206, 193).

![bed mesh_rect_basic](img/bedmesh_rect_basic.svg)

### Круглі ліжка

У цьому прикладі передбачається, що принтер оснащений круглою станиною радіусом 100 мм. Ми використовуватимемо ті самі зміщення зонда, що й у прямокутному прикладі, 24 мм на X і 5 мм на Y.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_radius: 75
 mesh_origin: 0, 0
 round_probe_count: 5
```

- `mesh_radius: 75` *Обов’язковий* Радіус досліджуваної сітки в мм відносно `mesh_origin`. Зауважте, що зміщення зонда обмежують розмір радіуса сітки. У цьому прикладі радіус, більший за 76, перемістить інструмент за межі діапазону принтера.
- `mesh_origin: 0, 0` *Значення за замовчуванням: 0, 0* Центральна точка сітки. Ця координата відноситься до місця розташування зонда. Хоча за замовчуванням встановлено значення 0, 0, може бути корисно налаштувати вихідну точку, щоб досліджувати більшу частину дна. Дивіться ілюстрацію нижче.
- `round_probe_count: 5` *Значення за замовчуванням: 5* Це ціле число, яке визначає максимальну кількість досліджуваних точок уздовж осей X і Y. Під «максимумом» ми маємо на увазі кількість точок, досліджених вздовж початку сітки. Це значення має бути непарним числом, оскільки необхідно, щоб центр сітки був досліджений.

На малюнку нижче показано, як генеруються досліджувані точки. Як бачите, встановлення `mesh_origin` на (-10, 0) дозволяє нам вказати більший радіус сітки 85.

![bed mesh_round_basic](img/bedmesh_round_basic.svg)

## Розширена конфігурація

Нижче детально описано більш розширені параметри конфігурації. Кожен приклад базується на базовій прямокутній конфігурації ліжка, показаній вище. Кожна з розширених опцій однаково застосовується до круглих ліжок.

### Інтерполяція сітки

У той час як можна відібрати зразки досліджуваної матриці безпосередньо за допомогою простої білінійної інтерполяції для визначення Z-значень між досліджуваними точками, часто корисно інтерполювати додаткові точки за допомогою більш просунутих алгоритмів інтерполяції для збільшення щільності сітки. Ці алгоритми додають сітці кривизну, намагаючись імітувати властивості матеріалу ліжка. Для цього Bed Mesh пропонує інтерполяцію Лагранжа та бікубічну інтерполяцію.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
 mesh_pps: 2, 3
 алгоритм: бікубічний
 бікубічний_натяг: 0,2
```

- `mesh_pps: 2, 3` *Значення за замовчуванням: 2, 2* Параметр `mesh_pps` є скороченням для точок сітки на сегмент. Цей параметр визначає, скільки точок інтерполювати для кожного сегмента вздовж осей X і Y. Вважайте «сегмент» простором між кожною досліджуваною точкою. Як і `probe_count`, `mesh_pps` вказується як пара цілих чисел X, Y, а також може бути вказано одне ціле число, яке застосовується до обох осей. У цьому прикладі є 4 сегменти вздовж осі X і 2 сегменти вздовж осі Y. Це означає 8 інтерпольованих точок уздовж X, 6 інтерпольованих точок уздовж Y, що призводить до сітки 13x8. Зауважте, що якщо mesh_pps встановлено на 0, то інтерполяція сітки вимкнена, а досліджувана матриця буде взята безпосередньо.
- `algorithm: lagrange` *Значення за замовчуванням: lagrange* Алгоритм, який використовується для інтерполяції сітки. Може бути «лагранжа» або «бікубічного». Інтерполяція Лагранжа обмежена 6 досліджуваними точками, оскільки коливання мають тенденцію відбуватися з більшою кількістю зразків. Бікубічна інтерполяція потребує мінімум 4 досліджуваних точок уздовж кожної осі, якщо вказано менше 4 точок, то вибірка Лагранжа виконується примусово. Якщо `mesh_pps` має значення 0, це значення ігнорується, оскільки інтерполяція сітки не виконується.
- `bicubic_tension: 0,2` *Значення за замовчуванням: 0,2* Якщо для параметра `algorithm` встановлено значення bicubic, можна вказати значення натягу. Чим вище натяг, тим більший нахил інтерполюється. Будьте обережні, регулюючи це, оскільки вищі значення також створюють більше перевищення, що призведе до того, що інтерпольовані значення будуть вищими або нижчими, ніж ваші вимірювані точки.

На ілюстрації нижче показано, як наведені вище параметри використовуються для створення інтерпольованої сітки.

![bed mesh_interpolated](img/bedmesh_interpolated.svg)

### Перемістити розділення

Bed Mesh працює, перехоплюючи команди переміщення gcode та застосовуючи трансформацію до їх координати Z. Довгі рухи необхідно розділити на менші, щоб правильно відповідати формі ліжка. Параметри нижче керують поведінкою розділення.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
 move_check_distance: 5
 split_delta_z: 0,025
```

- `move_check_distance: 5` *Значення за замовчуванням: 5* Мінімальна відстань для перевірки бажаної зміни Z перед виконанням поділу. У цьому прикладі алгоритм обійде переміщення довжиною понад 5 мм. Через кожні 5 мм буде відбуватися пошук Z сітки, порівнюючи його зі значенням Z попереднього ходу. Якщо дельта досягає порогового значення, встановленого `split_delta_z`, рух буде розділено, а обхід продовжиться. Цей процес повторюється до кінця ходу, де буде застосовано остаточне коригування. Ходи, менші за `move_check_distance`, мають правильне коригування Z, застосоване безпосередньо до ходу без обходу чи поділу.
- `split_delta_z: .025` *Значення за замовчуванням: .025* Як згадувалося вище, це мінімальне відхилення, необхідне для запуску розділення ходу. У цьому прикладі будь-яке значення Z із відхиленням +/- 0,025 мм ініціює розділення.

Зазвичай значень за замовчуванням для цих параметрів достатньо, насправді значення за замовчуванням 5 мм для `move_check_distance` може бути надмірним. Однак досвідчений користувач може захотіти поекспериментувати з цими параметрами, щоб вичавити оптимальний перший шар.

### Сітка Fade

Коли ввімкнено «згасання», коригування Z поступово припиняється на відстані, визначеній конфігурацією. Це досягається шляхом застосування невеликих коригувань висоти шару, або збільшення, або зменшення залежно від форми ліжка. Коли вицвітання завершено, регулювання Z більше не застосовується, дозволяючи верхній частині відбитка бути плоским, а не віддзеркалювати форму ложа. Вицвітання також може мати деякі небажані риси, якщо ви вицвітаєте занадто швидко, це може призвести до видимих артефактів на відбитку. Крім того, якщо ваше ліжко значно деформоване, вицвітання може зменшити або розтягнути висоту Z друку. Таким чином, зникнення вимкнено за замовчуванням.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
 fade_start: 1
 fade_end: 10
 fade_target: 0
```

- `fade_start: 1` *Значення за замовчуванням: 1* Висота Z, з якої починається поетапне припинення коригування. Рекомендується нанести кілька шарів перед початком процесу вицвітання.
- `fade_end: 10` *Значення за замовчуванням: 0* Висота Z, на якій має завершитися згасання. Якщо це значення менше, ніж `fade_start`, тоді згасання вимкнено. Це значення можна регулювати залежно від того, наскільки викривлена поверхня для друку. Значно деформована поверхня повинна зникати на більшій відстані. Майже плоска поверхня може зменшити це значення, щоб швидше припинити роботу. 10 мм — це розумне значення для початку, якщо використовувати значення за замовчуванням 1 для `fade_start`.
- `fade_target: 0` *Значення за замовчуванням: середнє значення Z сітки* `fade_target` можна розглядати як додаткове зміщення Z, застосоване до всього ліжка після завершення згасання. Загалом ми хотіли б, щоб це значення було 0, однак є обставини, коли воно не повинно бути. Наприклад, припустимо, що ваше початкове положення на станині є викидом, воно на 0,2 мм нижче, ніж середня досліджувана висота станини. Якщо `fade_target` дорівнює 0, зникнення зменшить відбиток у середньому на 0,2 мм по всій поверхні. Встановивши для параметра `fade_target` значення .2, ділянка фіксації розшириться на .2 мм, однак решта ліжка матиме точний розмір. Загалом доцільно залишити `fade_target` поза конфігурацією, щоб використовувати середню висоту сітки, однак може бути бажано вручну налаштувати ціль зникнення, якщо потрібно друкувати на певній частині ліжка.

### Налаштування нульової позиції відліку

Багато зондів сприйнятливі до «дрейфу», тобто до неточностей зондування, викликаних теплом або перешкодами. Це може ускладнити розрахунок зсуву зонда по z, особливо при різних температурах шару. Таким чином, деякі принтери використовують кінцевий упор для наведення осі Z і зонд для калібрування сітки. У цій конфігурації можна зміщувати сітку таким чином, щоб «еталонна позиція» (X, Y) застосовувала коригування нуля. «Еталонною позицією» має бути місце на платформі, де виконується тестування паперу [Z_ENDSTOP_CALIBRATE](./Manual_Level#calibrating-a-z-endstop). Модуль bed_mesh надає параметр `zero_reference_position` для визначення цієї координати:

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 zero_reference_position: 125, 110
 probe_count: 5, 3
```

- `zero_reference_position:` *Значення за замовчуванням: Немає (вимкнено)* `zero_reference_position` очікує, що координата (X, Y) відповідає координаті `еталонної позиції`, описаної вище. Якщо координата лежить у межах сітки, тоді сітка буде зміщена, тому опорна позиція застосовує коригування нуля. Якщо координата лежить за межами сітки, то координата буде досліджена після калібрування, а результуюче значення z використовуватиметься як зсув по z. Зауважте, що ця координата НЕ має бути в місці, зазначеному як `faulty_region`, якщо потрібен зонд.

#### Застарілий relative_reference_index

Існуючі конфігурації, що використовують параметр `relative_reference_index`, необхідно оновити, щоб використовувати `zero_reference_position`. Відповідь на команду gcode [BED_MESH_OUTPUT PGP=1](#output) включатиме координату (X, Y), пов’язану з індексом; цю позицію можна використовувати як значення для `zero_reference_position`. Результат виглядатиме приблизно так:

```
// bed_mesh: згенеровані точки
 // Індекс | Інструмент налаштований | Зонд
 // 0 | (1,0, 1,0) | (24,0, 6,0)
 // 1 | (36,7, 1,0) | (59,7, 6,0)
 // 2 | (72,3, 1,0) | (95,3, 6,0)
 // 3 | (108,0, 1,0) | (131,0, 6,0)
 ... (додаткові згенеровані бали)
 // bed_mesh: relative_reference_index 24 дорівнює (131,5, 108,0)
```

*Примітка. Наведені вище результати також друкуються в `klippy.log` під час ініціалізації.*

Використовуючи наведений вище приклад, ми бачимо, що `relative_reference_index` друкується разом із його координатою. Таким чином, `zero_reference_position` становить `131,5, 108`.

### Несправні регіони

Деякі ділянки ліжка можуть повідомляти про неточні результати під час зондування через «несправність» у певних місцях. Найкращим прикладом цього є ліжка з рядом інтегрованих магнітів, які використовуються для утримання знімних сталевих листів. Магнітне поле на цих магнітах і навколо них може призвести до спрацьовування індуктивного зонда на відстані, вищій або нижчій, ніж це було б у іншому випадку, що призведе до сітки, яка не точно представляє поверхню в цих місцях. **Примітка: це не слід плутати зі зміщенням розташування датчика, яке дає неточні результати по всьому ліжку.**

Параметри `faulty_region` можуть бути налаштовані для компенсації цього впливу. Якщо згенерована точка лежить у несправній області, сітка ліжка намагатиметься дослідити до 4 точок на межах цієї області. Ці досліджувані значення будуть усереднені та вставлені в сітку як значення Z у створеній (X, Y) координаті.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
 faulty_region_1_min: 130,0, 0,0
 faulty_region_1_max: 145,0, 40,0
 faulty_region_2_min: 225,0, 0,0
 faulty_region_2_max: 250,0, 25,0
 faulty_region_3_min: 165,0, 95,0
 faulty_region_3_max: 205,0, 110,0
 faulty_region_4_min: 30,0, 170,0
 faulty_region_4_max: 45,0, 210,0
```

- `faulty_region_{1...99}_min` `faulty_region_{1..99}_max` *Значення за замовчуванням: Немає (вимкнено)* Несправні області визначаються подібно до самої сітки, де мінімум і максимум (X , Y) необхідно вказати координати для кожного регіону. Дефектна область може виходити за межі сітки, однак згенеровані альтернативні точки завжди будуть у межах сітки. Жодні два регіони не можуть перетинатися.

На зображенні нижче показано, як генеруються точки заміни, коли згенерована точка лежить у дефектній області. Показані регіони збігаються з наведеними вище зразками конфігурації. Точки заміни та їх координати позначені зеленим кольором.

![bed mesh_interpolated](img/bedmesh_faulty_regions.svg)

### Адаптивні сітки

Адаптивна сітка ліжка — це спосіб прискорити генерацію сітки ліжка, досліджуючи лише область ліжка, яку використовують об’єкти, що друкуються. Під час використання метод автоматично регулює параметри сітки на основі площі, зайнятої визначеними об’єктами друку.

Адаптована площа сітки буде обчислена з області, визначеної межами всіх визначених об’єктів друку, щоб вона охоплювала кожен об’єкт, включаючи будь-які поля, визначені в конфігурації. Після обчислення площі кількість точок зондування буде зменшено на основі співвідношення площі сітки за замовчуванням і адаптованої площі сітки. Щоб проілюструвати це, розглянемо такий приклад:

Для ліжка розміром 150 мм x 150 мм із значенням `mesh_min`, установленим на `25,25` і `mesh_max`, встановленим на `125,125`, площа сітки за замовчуванням становить квадрат 100 мм x 100 мм. Адаптована площа сітки «50,50» означає співвідношення «0,5x0,5» між адаптованою площею та площею сітки за замовчуванням.

Якщо конфігурація `bed_mesh` вказала `probe_count` як `7x7`, адаптована сітка ліжка використовуватиме 4x4 точки зонда (7 * 0,5 округлено в більшу сторону).

![adaptive_bed mesh](img/adaptive_bed_mesh.svg)

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5, 3
 adaptive_margin: 5
```

- `adaptive_margin` *Значення за замовчуванням: 0* Поле (у мм), яке додається навколо площі ложа, що використовується визначеними об’єктами. На діаграмі нижче показано адаптовану площу сітки ліжка з `adaptive_margin` 5 мм. Адаптована площа сітки (область зеленого кольору) обчислюється як використана площа грядки (область синього кольору) плюс визначений запас.

   ![adaptive_bedmesh_margin](img/adaptive_bed_mesh_margin.svg)

За своєю природою адаптивні ліжкові сітки використовують об’єкти, визначені файлом Gcode, який друкується. Таким чином, очікується, що кожен файл Gcode генеруватиме сітку, яка досліджує іншу область друкарської поверхні. Тому адаптовані сітки для ліжок не можна використовувати повторно. Очікується, що нова сітка буде створена для кожного друку, якщо використовується адаптивна сітка.

Важливо також враховувати, що адаптивну сітку шару найкраще використовувати на машинах, які зазвичай можуть досліджувати весь шар і досягати максимальної дисперсії, меншої або рівної 1 висоті шару. Машини з механічними проблемами, які зазвичай компенсує повна сітка, можуть мати небажані результати під час спроб друку рухатися **поза** зони зондування. Якщо повна сітка має дисперсію, що перевищує 1 висоту шару, слід бути обережним, використовуючи адаптивні сітки та намагаючись друкувати за межами сітчастої області.

## Сканування поверхні

Деякі зонди, такі як [Вихровий зонд](./Eddy_Probe.md), здатні «сканувати» поверхню ліжка. Тобто ці зонди можуть відбирати сітку, не піднімаючи інструмент між пробами. Щоб увімкнути режим сканування, параметр зонду `METHOD=scan` або `METHOD=rapid_scan` слід передати в команду gcode `BED_MESH_CALIBRATE`.

### Висота сканування

Висота сканування встановлюється параметром `horizontal_move_z` в `[bed_mesh]`. Крім того, його можна надати команді gcode `BED_MESH_CALIBRATE` через параметр `HORIZONTAL_MOVE_Z`.

Висота сканування має бути достатньо низькою, щоб уникнути помилок сканування. Зазвичай висота 2 мм (тобто: `HORIZONTAL_MOVE_Z=2`) має працювати добре, припускаючи, що зонд встановлено правильно.

Слід зазначити, що якщо зонд знаходиться понад 4 мм над поверхнею, результати будуть недійсними. Таким чином, сканування неможливе на ліжках із сильним відхиленням поверхні або ліжках із екстремальним нахилом, який не було виправлено.

### Швидке (безперервне) сканування

Виконуючи `rapid_scan`, слід мати на увазі, що результати матимуть певну кількість похибок. Ця помилка має бути достатньо низькою, щоб бути корисною для великих областей друку з досить товстим шаром. Деякі зонди можуть бути більш схильними до помилок, ніж інші.

Не рекомендується використовувати швидкий режим для сканування «щільної» сітки. Деякі помилки, які виникають під час швидкого сканування, можуть бути гаусовим шумом від датчика, і щільна сітка відображатиме цей шум (тобто: будуть піки та спади).

Bed Mesh намагатиметься оптимізувати шлях руху, щоб забезпечити найкращий можливий результат залежно від конфігурації. Це включає уникнення дефектних областей під час збору зразків і «перевищення» сітки при зміні напрямку. Це перевищення покращує вибірку на краях сітки, однак воно вимагає, щоб сітка була налаштована таким чином, щоб інструмент міг рухатися за межі сітки.

```
[bed_mesh]
 швидкість: 120
 horizontal_move_z: 5
 mesh_min: 35, 6
 mesh_max: 240, 198
 probe_count: 5
 scan_overshoot: 8
```

- `scan_overshoot` *Значення за замовчуванням: 0 (вимкнено)* Максимальна величина ходу (у мм), доступна за межами сітки. Для прямокутних ліжок це стосується переміщення по осі X, а для круглих ліжок – по всьому радіусу. Інструмент повинен мати можливість рухатися за межами сітки на вказану величину. Це значення використовується для оптимізації шляху руху під час виконання «швидкого сканування». Мінімальне значення, яке можна вказати, дорівнює 1. За замовчуванням перевищення немає.

Якщо перевищення сканування не налаштовано, оптимізація шляху руху не застосовуватиметься до змін напрямку.

## G-коди сітки для ліжка

### Калібрування

`BED_MESH_CALIBRATE PROFILE=<name> METHOD=[посібник | автоматичний | скам | rapid_scan] \ [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=[0|1] \ [ADAPTIVE_MARGIN=<value>]` *Профіль за замовчуванням: за замовчуванням* *Методи за замовчуванням: автоматичний якщо виявлено зонд , інакше ручну*  *Адаптивний за замовчуванням: 0*  *Адаптивний поля за замовчуванням: 0*

Ініціює процедуру зондування для калібрування сітки ліжка.

Сітка буде збережена в профілі, визначеному параметром `PROFILE`, або `default`, якщо не вказано. Параметр `METHOD` приймає одне з таких значень:

- `METHOD=manual`: дозволяє ручне зондування за допомогою насадки та паперового тесту
- `METHOD=automatic`: Автоматичне (стандартне) зондування. Це значення за умовчанням.
- `METHOD=scan`: Вмикає сканування поверхні. Інструмент зупинятиметься над кожною позицією, щоб зібрати зразок.
- `METHOD=rapid_scan`: вмикає безперервне сканування поверхні.

Положення XY автоматично налаштовуються, щоб включити зміщення X і/або Y, коли вибрано метод зондування, відмінний від `«ручного»`.

Можна вказати параметри сітки для зміни досліджуваної області. Доступні такі параметри:

- Грядки прямокутні (декартові):
   - `MESH_MIN`
   - `MESH_MAX`
   - `PROBE_COUNT`
- Круглі грядки (дельта):
   - `MESH_RADIUS`
   - `MESH_ORIGIN`
   - `ROUND_PROBE_COUNT`
- Всі ліжка:
   - `MESH_PPS`
   - `ALGORITHM`
   - `ADAPTIVE`
   - `ADAPTIVE_MARGIN`

Перегляньте документацію щодо конфігурації вище, щоб дізнатися, як кожен параметр застосовується до сітки.

### Профілі

`BED_MESH_PROFILE SAVE=<name> LOAD=<name> REMOVE=<name>`

Після виконання BED_MESH_CALIBRATE можна зберегти поточний стан сітки в іменованому профілі. Це дає можливість завантажувати сітку без повторного зондування ложа. Після того як профіль було збережено за допомогою `BED_MESH_PROFILE SAVE=<name>`, можна виконати gcode `SAVE_CONFIG`, щоб записати профіль у printer.cfg.

Профілі можна завантажити, виконавши `BED_MESH_PROFILE LOAD=<name>`.

Слід зазначити, що кожного разу, коли відбувається BED_MESH_CALIBRATE, поточний стан автоматично зберігається в профілі *за замовчуванням*. Профіль *за замовчуванням* можна видалити таким чином:

`BED_MESH_PROFILE REMOVE=default`

Будь-який інший збережений профіль можна видалити таким же чином, замінивши *default* на названий профіль, який ви хочете видалити.

#### Завантаження профілю за замовчуванням

Попередні версії `bed_mesh` завжди завантажували профіль із назвою *default* під час запуску, якщо він був присутній. Цю поведінку було видалено, щоб користувач міг визначати, коли завантажується профіль. Якщо користувач бажає завантажити профіль `за замовчуванням`, рекомендується додати `BED_MESH_PROFILE LOAD=default` або до свого макросу `START_PRINT`, або до конфігурації «Почати G-код» слайсера, залежно від того, що застосовно.

Крім того, стару поведінку завантаження профілю під час запуску можна відновити за допомогою `[delayed_gcode]`:

```ini
[delayed_gcode bed_mesh_init]
 початкова_тривалість: .01
 gcode:
   BED_MESH_PROFILE LOAD=за умовчанням
```

### Вихід

`BED_MESH_OUTPUT PGP=[0 | 1]`

Виводить поточний стан сітки на термінал. Зверніть увагу, що виводиться сама сітка

Параметр PGP є скороченням для «Друк згенерованих точок». Якщо встановлено `PGP=1`, згенеровані перевірені точки будуть виведені на термінал:

```
// bed_mesh: згенеровані точки
 // Індекс | Інструмент налаштований | Зонд
 // 0 | (11,0, 1,0) | (35,0, 6,0)
 // 1 | (62,2, 1,0) | (86,2, 6,0)
 // 2 | (113,5, 1,0) | (137,5, 6,0)
 // 3 | (164,8, 1,0) | (188,8, 6,0)
 // 4 | (216,0, 1,0) | (240,0, 6,0)
 // 5 | (216,0, 97,0) | (240,0, 102,0)
 // 6 | (164,8, 97,0) | (188,8, 102,0)
 // 7 | (113,5, 97,0) | (137,5, 102,0)
 // 8 | (62,2, 97,0) | (86,2, 102,0)
 // 9 | (11,0, 97,0) | (35,0, 102,0)
 // 10 | (11,0, 193,0) | (35,0, 198,0)
 // 11 | (62,2, 193,0) | (86,2, 198,0)
 // 12 | (113,5, 193,0) | (137,5, 198,0)
 // 13 | (164,8, 193,0) | (188,8, 198,0)
 // 14 | (216,0, 193,0) | (240,0, 198,0)
```

Точки «Налаштований інструмент» стосуються розташування сопла для кожної точки, а точки «Зонд» стосуються розташування зонда. Зауважте, що під час вимірювання вручну точки «Зонд» стосуватимуться розташування як інструмента, так і насадки.

### Очистити стан сітки

`BED_MESH_CLEAR`

Цей gcode можна використовувати для очищення внутрішнього стану сітки.

### Застосувати зміщення X/Y

`BED_MESH_OFFSET [X=<value>] [Y=<value>] [ZFADE=<value>]`

Це корисно для принтерів із декількома незалежними екструдерами, оскільки зсув необхідний для правильного коригування Z після зміни інструменту. Зміщення слід вказати відносно первинного екструдера. Тобто, якщо вторинний екструдер встановлено праворуч від первинного екструдера, слід вказати позитивне зміщення по осі X, якщо вторинний екструдер встановлено «позаду» первинного екструдера, має бути вказано позитивне зміщення по осі Y, а позитивне зміщення по ZFADE має вказується, якщо сопло вторинного екструдера знаходиться над соплом первинного екструдера.

Зауважте, що зміщення ZFADE *НЕ* безпосередньо застосовує додаткові налаштування. Він призначений для компенсації `зсуву gcode`, коли ввімкнено [mesh fade](#mesh-fade). Наприклад, якщо вторинний екструдер вищий за основний і потребує від’ємного зсуву gcode, тобто: `SET_GCODE_OFFSET Z=-.2`, це можна врахувати в `bed_mesh` з `BED_MESH_OFFSET ZFADE=.2`.

## API Bed Mesh Webhooks

### Дамп даних сітки

`{"id": 123, "met hod": "bed_mesh/dump_mesh"}`

Дамп конфігурації та стану для поточної сітки та всіх збережених профілів.

Кінцева точка `dump_mesh` приймає один необов’язковий параметр, `mesh_args`. Цей параметр має бути об’єктом, де ключі та значення є параметрами, доступними для [BED_MESH_CALIBRATE](#bed_mesh_calibrate). Це оновить конфігурацію сітки та точки зонду за допомогою наданих параметрів перед поверненням результату. Рекомендується опускати параметри сітки, якщо не потрібно візуалізувати точки зонда та/або траєкторію перед виконанням `BED_MESH_CALIBRATE`.

## Візуалізація та аналіз

Більшість користувачів, ймовірно, виявить, що візуалізаторів, які входять до таких програм, як Mainsail, Fluidd і Octoprint, достатньо для базового аналізу. Проте папка `scripts` Klipper містить сценарій `graph_mesh.py`, який можна використовувати для виконання додаткової візуалізації та більш детального аналізу, особливо корисного для налагодження обладнання або результатів, створених ` bed_mesh`:

```
використання: графік_mesh.py [-h] {list,plot,analyze,dump} ...

Graph Bed Mesh Дані

позиціональні аргументи:
{list,plot,analyze,dump}
список доступних типів ділянок
доля Plot вказаний тип
аналіз Виконувати аналіз даних сітки
Dump API відповідь на файл json

варіанти:
-h, --help показати це повідомлення про допомогу і вихід
```

### Передумови

Як і більшість графічних інструментів, наданих Klipper, `graph_mesh.py` вимагає залежностей `matplotlib` і `numpy` python. Крім того, для підключення до Klipper через веб-сокет Moonraker потрібна залежність `websockets` python. Хоча всі візуалізації можна виводити у файл `svg`, більшість візуалізацій, які пропонує `graph_mesh.py`, краще переглядати в режимі попереднього перегляду на настільному ПК. Наприклад, тривимірні візуалізації можна обертати та масштабувати в режимі попереднього перегляду, а візуалізації шляху можна додатково анімувати в режимі попереднього перегляду.

### Побудова даних Mesh

Інструмент `graph_mesh.py` може створювати кілька типів візуалізацій. Доступні типи можна показати, запустивши `graph_mesh.py list`:

```
список графімеш.py
окуляри Plot оригінальні генеровані точки
Шлях Плот пробе подорожі шлях
порназоркі Plot швидкий сканування шляху
Пробед Plot probed Z значення
свінгери Plot сітки Z значення
накладка Плоти поточної прокладної сітки перекриття профілю
дельта Плоти дельти між поточною прокладкою сітки і профілю
```

Деякі варіанти доступні при візуалізації ділянки:

```
використання: графімеш.py plot [-h] [-a] [-s] [-p PROFILE_NAME] [-o OUTPUT] <plot type> <input>

позиціональні аргументи:
<plot тип> Тип даних до графіка
<input> Патент/url на Klipper Socket або шлях до json файл

варіанти:
-h, --help показати це повідомлення про допомогу і вихід
-a, --анімат Аніматові доріжки в живому попередньому перегляді
--s, - масштаб-plot Використовуйте діапазони осі, які повідомляються Klipper, щоб масштабувати ділянку X / Y
-р ПРОФІЛЕ_NAME, --профайл-ім'я ПРОФІЛЕ_NAME
Додаткове найменування профілю для 'probedz Р
-o OUTPUT, - вихід
Вихідний шлях файлу
```

Нижче опис кожного аргумента:

- `plot type`: Потрібні аргументи для створення типу візуалізації. Повинен бути одним з типів `graph_mesh.py list` команди.
- ` вхід`: Необхідний аргумент позиціонування, що містить шлях або виворіт на джерело введення. Це повинно бути одне з наступних:
   - Шлях до Unix Domain Socket Klipper
   - URL-адреса екземпляра Moonraker
   - Шлях до файлу json, створеного `graph_mesh.py dump<input>`
- `-a`: додаткова анімація для типів візуалізації `path` і `rapid`. Анімації застосовуються лише до попереднього перегляду в реальному часі.
- `-s`: необов’язково масштабує графік, використовуючи значення `axis_minimum` і `axis_maximum`, які повідомляються об'єктом `toolhead` Klipper під час створення файлу дампа.
- `-p`: ім'я профілю, яке можна вказати під час генерації візуалізації тривимірної сітки `probedz`. Під час генерації візуалізації `overlay` або `delta` візуалізації цей аргумент має бути надано.
- `-o`: додатковий шлях до файлу, який вказує, що сценарій має зберегти візуалізацію в цьому місці, а не запускатися в режимі попереднього перегляду. Зображення зберігаються у форматі `svg`.

Наприклад, щоб побудувати анімований швидкий шлях, підключившись через Unix-сокет Klipper:

```
графік graph_mesh.py - швидкий ~/printer_data/comms/klippy.sock
```

Або побудувати 3D візуалізацію сітки, підключившись через Moonraker:

```
graph_mesh.py побудувати мережу http://my-printer.local
```

### Аналіз сітки ліжка

Інструмент `graph_mesh.py` також можна використовувати для аналізу даних, наданих [bed_mesh/dump_mesh](#dumping-mesh-data) API:

```
аналіз graph_mesh.py
```

Як і у випадку з командою `plot`, `<input>` має бути шляхом до Unix-сокету Klipper, URL-адресою екземпляра Moonraker або шляхом до файлу json, створеного командою dump.

Для початку аналіз виконає різні перевірки точок і шляхів зонда, згенерованих `bed_mesh` під час створення дампа. Це включає наступне:

- Кількість згенерованих точок зондування без додавання
- Кількість згенерованих точок зондування, включно з будь-якими точками, згенерованими як результат несправних областей і/або налаштованої нульової опорної позиції.
- Кількість пробних точок, згенерованих під час виконання швидкого сканування.
- Загальна кількість ходів, згенерованих для швидкого сканування.
- Перевірка того, що точки зондування, створені для швидкого сканування, ідентичні точкам тестування, згенерованим для стандартної процедури зондування.
- Перевірка "зворотного відстеження" як для стандартного шляху зонда, так і для шляху швидкого сканування. Зворотне відстеження можна визначити як переміщення до однієї позиції більше одного разу під час процедури зондування. Зворотне відстеження ніколи не повинно відбуватися під час стандартного зонду. Несправні області *можуть* призвести до зворотного відстеження під час швидкого сканування в спробі уникнути входу в несправну область під час наближення або виходу з місця зонда, однак ніколи не повинно відбуватися в іншому випадку.

Далі буде проаналізовано кожну досліджувану сітку, наявну в дампі, починаючи з сітки, завантаженої під час дампа (якщо вона є), а потім будь-які збережені профілі. Витягуються такі дані:

- Форма сітки (мін. X, Y, макс. X, Y кількість зондів)
- Сітка Z діапазон, (мінімум Z, максимум Z)
- Середнє значення Z у сітці
- Стандартне відхилення значень Z у сітці

На додаток до вищезазначеного, дельта-аналіз виконується між сітками однакової форми, повідомляючи наступне:

- Діапазон дельти між сітками (мінімум і максимум)
- Середня дельта
- Стандартне відхилення дельти
- Абсолютна максимальна різниця
- Абсолютне середнє

### Збережіть дані сітки у файл

Команда `dump` може бути використана для збереження відповіді у файл, який можна надати для аналізу під час усунення несправностей:

```
graph_mesh.py дамп -o
```

`<input>` має бути шляхом до unix-сокету Klipper або URL-адресою екземпляра Moonraker. Параметр `-o` можна використовувати для вказівки шляху до вихідного файлу. Якщо пропущено, файл буде збережено в робочому каталозі з назвою файлу в такому форматі:

`kipper bed mesh-{year}{month}{day}{hour}{minute}{second}.json`
