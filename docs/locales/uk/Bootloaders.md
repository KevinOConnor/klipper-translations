# Завантажувачі

Цей документ надає інформацію про загальні завантажувачі, знайдені на мікроконтролерах, які підтримують Klipper.

Завантажувач - це 3-стороннє програмне забезпечення, яке працює на мікроконтролері, коли він спочатку працює. Зазвичай використовується для спалаху нової програми (наприклад, Klipper) до мікроконтролера без необхідності спеціалізованого обладнання. На жаль, не існує галузевого широкого стандарту для миття мікроконтролера, а не є стандартним завантажувачем, який працює по всій мікроконтролерах. Похиліть, це поширений для кожного завантажувача, щоб зажадати інший набір кроків, щоб флеш додаток.

Якщо один може спалахти завантажувача до мікроконтролера, то можна, як правило, використовувати цей механізм, щоб спалахувати додаток, але обережно слід приймати при виконанні цього, як один може неперевершено видалити завантажувач. На відміну від того, що завантажувач, як правило, дозволить користувачу зафіксувати додаток. Таким чином, рекомендується використовувати завантажувач для миття програми.

Цей документ намагається описати загальні завантажувачі, кроки, необхідні для спалаху завантажувача, і кроки, необхідні для спалаху програми. Цей документ не є авторським довідником; він призначений для збору корисної інформації, яку накопичили розробники Klipper.

## Мікроконтролери AVR

В цілому, проект Arduino є гарним довідником для завантажувачів і миготливих процедур на мікроконтролерах 8-bit Atmel Atmega. Зокрема, файл "boards.txt": <https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt> є корисним посиланням.

Для того, щоб спалахувати себе завантажувача, чіпси AVR вимагають зовнішнього обладнання, що блимає інструмент (який спілкується з чіпом за допомогою SPI). Цей інструмент може бути придбаний (наприклад, зробити веб-пошук для "avr isp", "arduino isp", або "usb tiny isp"). Також можна використовувати ще один Arduino або Малиновий Пі, щоб спалахувати AVR завантажувач (наприклад, зробити пошук для "програми avr за допомогою малинового пі"). Приклади нижче писуються, що припустимо пристрій типу "AVR ISP Mk2" у використанні.

Програма "avrdude" є найбільш поширеним інструментом, який використовується для флеш-пам'яті atmega.

### Атмега2560

Цей чіп, як правило, знаходиться в "Arduino Mega" і дуже поширений в 3d друкованих плат.

Для миття завантажувача використовуйте щось схоже:

```
wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/loadloadloaders/stk500v2/stk500boot_v2_mega2560.hex Р

Avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U замок:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m
avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U спалах:w:stk500boot_v2_mega2560.hex
avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U замок:w:0x0F:m
```

Для спалаху програми використовуйте щось схоже:

```
avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i
```

### Атмега1280

Цей чіп зазвичай зустрічається в попередніх версіях "Ардуіно Мега".

Для миття завантажувача використовуйте щось схоже:

```
catalàDeutschEnglishEspañolFrançaisItalianoLatviešuLietuviųNederlandsNorskPolskiPortuguêsRomânăSlovenčinaSvenskaالعربيةفارسیעבריתΕλληνικάБългарскиРусскийСрпски / srpskiУкраїнська中文(台灣) Р

avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U замок:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m
avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U спалах:w:ATmegaBOOT_168_atmega1280.hex
avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U замок:w:0x0F:m
```

Для спалаху програми використовуйте щось схоже:

```
avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i
```

### Атмега1284p

Цей чіп зазвичай знаходиться в стилі "Melzi" 3d принтер дошки.

Для миття завантажувача використовуйте щось схоже:

```
wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/завантажити / перезавантажити/оптизавантажити_atmega1284p.hex Р

avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U замок:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m
avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U спалах:w:optiboot_atmega1284p.hex
avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U замок:w:0x0F:m
```

Для спалаху програми використовуйте щось схоже:

```
avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i
```

Зауважте, що кількість дошок стилю «Мельці» прийшло попередньо завантажене завантажувачем, який використовує приманку 57600. У цьому випадку, щоб спалахувати додаток, використовуйте щось, як це замість:

```
avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/klipper.elf.hex:i
```

### Напляскване1286

Цей документ не охоплює метод, щоб мити завантажувач до At90usb1286, а не охоплює загальний додаток, що миготливий до цього пристрою.

Пристрій Teensy++ від pjrc.com поставляється з фірмовим завантажувачем. Для користувача миготливий інструмент від <https://github.com/PaulStoffregen/teensy_loader_cli>. За допомогою чогось іншого можна записати:

```
підлітковий вік_loader_cli --mcu=at90usb1286 з/клиппер.elf.hex -р
```

### Атмега168

Atmega168 має обмежений простір спалаху. При використанні завантажувача рекомендується використовувати завантажувач Optiboot. Для спалаху, який завантажувач використовує щось схоже:

```
catalàDeutschEnglishEspañolFrançaisItalianoLatviešuLietuviųNederlandsNorskPolskiPortuguêsRomânăSlovenčinaSvenskaالعربيةفارسیעבריתΕλληνικάБългарскиРусскийСрпски / srpskiУкраїнська中文(台灣) Р

avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U замок:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDDD:m -U lfuse:w:0xFF:m
avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U спалах:w:optiboot_atmega168.hex
avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U замок:w:0x0F:m
```

Для того, щоб мити додаток за допомогою Optibootloader використовуйте щось схоже:

```
avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/klipper.elf.hex:i
```

## Мікроконтролери SAM3 (Arduino Due)

Незвичайно використовувати завантажувач з SAM3 mcu. Сама чіп має ROM, що дозволяє спалаху програмувати з 3.3V серійного порту або з USB.

Для того, щоб увімкнути ROM, штифт "запаювання" проводиться високою під час скидання, яка стирає вміст спалаху, і викликає ROM для запуску. На Arduino Due, цей послідовність може бути виконана шляхом встановлення швидкості шнура 1200 на "програмування USB-порту" (порт USB, найближчий до джерела живлення).

Код <https://github.com/shumatech/BOSSA> може бути використаний для програми SAM3. Рекомендується використовувати версію 1.9 або пізніше.

Для спалаху програми використовуйте щось схоже:

```
bssac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b
Bssac -U -p /dev/ttyACM0 -R
```

## Мікроконтролери SAM4 (Duet Wifi)

Незвичайно використовувати завантажувач SAM4 mcu. Сама чіп має ROM, що дозволяє спалаху програмувати з 3.3V серійного порту або з USB.

Для того, щоб увімкнути ROM, штифт "запаювання" проводиться високою під час скидання, яка стирає вміст спалаху, і викликає ROM для запуску.

Код <https://github.com/shumatech/BOSSA> може використовуватися для програми SAM4. Потрібно використовувати версію `1.8.0` або вище.

Для спалаху програми використовуйте щось схоже:

```
босак --порт=/dev/ttyACM0 -b -U -e -w -v -R з/клиппер.bin
```

## Мікроконтролери SAMDC21 (Duet3D 1LC)

SAMC21 миготливий через інтерфейс серійного дроту ARM (SWD). Це зазвичай робиться з виділеним SWD апаратним донголом. Крім того, можна скористатися [Равесняний Пі з OpenOCD](#running-openocd-on-the-raspberry-pi).

При використанні OpenOCD з SAMC21 додаткові кроки повинні бути прийняті, щоб спочатку покласти чіп в режим холодного роз'єму, якщо дошка використовує SWD шпильки для інших цілей. Якщо використовувати OpenOCD на Rasberry Pi, це можна зробити, використовуючи команду, перш ніж викликати OpenOCD.

```
СКЛК=25
ДІО=24
СТ=18

echo "Exporting SWCLK і SRST шпильки."
Echo $SWCLK > /sys/class/gpio/export
ехо $SRST > /sys/class/gpio/export
echo "out" > /sys/class/gpio/gpio$SWCLK/direction
ехо "out" > /sys/class/gpio/gpio$SRST/direction

echo "Setting SWCLK низький і пульсуючий SRST."
echo "0" > /sys/class/gpio/gpio$SWCLK/value
echo "0" > /sys/class/gpio/gpio$SRST/value
echo "1" > /sys/class/gpio/gpio$SRST/value

echo "Unexporting SWCLK і SRST шпильки."
Echo $SWCLK > /sys/class/gpio/unexport
Echo $SRST > /sys/class/gpio/unexport
```

Для спалаху програми з OpenOCD використовуйте наступні налаштування чіпа:

```
домашня сторінка / Теґи Leuchtturm
```

Зберігати програму; наприклад, klipper може бути побудована для цього чіпа. Флеш з командами OpenOCD аналогічно:

```
at91samd чіп-сераза
at91samd завантажити 0 р.
javascript licenses api веб-сайт go1.13.8
```

## Мікроконтролери SAMD21 (Arduino Zero)

Завантажувач SAMD21 прошивається через інтерфейс ARM Serial Wire Debug (SWD). Зазвичай це робиться за допомогою спеціального апаратного ключа SWD. Крім того, можна використовувати [Raspberry Pi з OpenOCD](#running-openocd-on-the-raspberry-pi).

Для миття завантажувача з OpenOCD використовуйте такі налаштування чіпа:

```
домашня сторінка / Теґи Leuchtturm
```

Зберігайте завантажувач - наприклад:

```
wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/завантажувачі/zero/samd21_sam_ba.bin Р
```

Флеш з командами OpenOCD аналогічно:

```
at91samd завантажити 0 р.
javascript licenses api веб-сайт go1.13.8
```

Найпоширеніший завантажувач на SAMD21 є одним, знайденим на "Arduino Zero". Він використовує завантажувач 8KiB (додаток необхідно скомпільувати за допомогою стартової адреси 8KiB). Один може ввести цей завантажувач двічі натиснувши кнопку скидання. Для спалаху програми використовуйте щось схоже:

```
bssac -U -p /dev/ttyACM0 --offset=0x2000 -w/klipper.bin -v -b -R
```

На відміну від "Arduino M0" використовує 16KiB завантажувач (додаток необхідно скомпільувати з стартовою адресою 16KiB). Для того, щоб мити додаток на цьому завантажувачі, скидайте мікроконтролер і запустіть флеш-команду протягом перших декількох секунд завантаження - щось схоже:

```
avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper.elf.hex:i
```

## Мікроконтролери SAMD51 (Adafruit Metro-M4)

Як і SAMD21, завантажувач SAMD51 миготливий через інтерфейс ARM Serial Wire Debug (SWD). Для миття завантажувача з [OpenOCD на Малина Пі](#running-openocd-on-the-raspberry-pi) використовуйте наступне налаштування чіпа:

```
джерело [find цільовий/atsame5x.cfg]
```

Зберігати завантажувач - кілька завантажувальних навантажувачів доступні з <https://github.com/adafruit/uf2-samdx1/ релізів/latest>. Наприклад:

```
wget 'https://github.com/adafruit/uf2-samdx1/випуск/download/v3.7.0/завантажитиloader-itsybitsy_m4-v3.7.0.bin р
```

Флеш з командами OpenOCD аналогічно:

```
at91samd завантажити 0 р.
програма bootloader-itsybitsy_m4-v3.7.0.b верифікації
код товару: 16384
```

SAMD51 використовує 16KiB завантажувач (додаток необхідно скомпільувати з стартовою адресою 16KiB). Для спалаху програми використовуйте щось схоже:

```
босак -U -p /dev/ttyACM0 --offset=0x4000 -w/klipper.bin -v -b -R
```

## Мікроконтролери STM32F103 (синій підвіконня)

Пристрої STM32F103 мають ROM, які можуть спалахувати завантажувач або додаток через 3.3V серійний. Зазвичай одна б проводила PA10 (MCU Rx) і PA9 (MCU Tx) шпильки до адаптера 3.3V UART. Щоб отримати доступ до ROM, слід підключити "завантажити 0" шпильку до високих і "завантажити 1" шпильку до низьких, а потім скидати пристрій. Пакет "stm32flash" може бути використаний для того, щоб заблокувати пристрій за допомогою чогось:

```
стм32фл -w/klipper.bin -v -g 0 /dev/ttyAMA0
```

Зверніть увагу, що якщо один використовує Raspberry Pi для серії 3.3V, протокол Stm32flash використовує режим серійного парі, який Raspberry Pi's "mini UART" не підтримує. Див. <https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-uarts> для деталей, що дозволяє повною мірою на Raspberry Pi GPIO шпильки.

Після того, як миготливий, встановити як "завантажити 0" і "завантажити 1" назад до низького, так що майбутні скидки завантаження з флешки.

### STM32F103 з стем32дуіно завантажувачем

Проект "stm32duino" має USB-розвантажувач, який здатний завантажити - див. <https://github.com/rogerclarkmelbourne/STM32duino-loadloader>

Цей завантажувач може бути спалахований через 3.3V серійно з чимось схожим:

```
wget 'https://github.com/rogerclarkmelbourne/STM32duino-loader/raw/master/binaries/generic_boot20_pc13.bin Р

Стм32фл -w загальний_boot20_pc13.bin -v -g 0 /dev/ttyAMA0
```

Цей завантажувач використовує 8KiB флеш-простору (додаток необхідно скомпільувати з стартовою адресою 8KiB). Захопити додаток з чимось схожим:

```
дфу-утил -d 1eaf:0003 -a 2 -R -D з/клиппер.бін
```

Завантажувач зазвичай працює лише за короткий період після завантаження. Це може бути необхідно, щоб час вище команд, так що він працює в той час як завантажувач все ще активний (завантажувач буде спалахувати дошку під керівництвом, поки він працює). Крім того, встановіть "завантажити 0" шпильку на низький і "завантажити 1" шпильку для високого перебування в завантажувачі після скидання.

### STM32F103 з HID завантажувачем

The [HID Bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) є компактним, без водіям завантажувача, здатний перемикатися USB. Також доступний [fork з побудовою специфіки SKR Mini E3 1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest).

Для генеричних щитів STM32F103, таких як синя таблетка, можливо, мити завантажувач через 3.3V серійний за допомогою stm32flash, як зазначено в розділі stm32duino вище, підкреслюючи назву файлу для бажаного ходового завантажувача бінарними (тобто: hid_generic_pc13.bin для синього стовпа).

Неможливо використовувати stm32flash для SKR Mini E3, оскільки штифт boot0 прив’язаний безпосередньо до землі, а не роз’єднаний через контакти роз’єму. Рекомендується використовувати STLink V2 із STM32Cubeprogrammer для прошивки завантажувача. Якщо у вас немає доступу до STLink, також можна використовувати [Raspberry Pi та OpenOCD](#running-openocd-on-the-raspberry-pi) із такою конфігурацією чіпа:

```
джерело [find цільовий/stm32f1x.cfg]
```

Якщо ви хочете зробити резервну копію поточного спалаху з наступним командуванням. Зверніть увагу, що це може зайняти час для завершення:

```
flash read_bank 0 btt_skr_mini_e3_backup.bin
```

нарешті, ви можете спалахувати з командами, такими як:

```
stm32f1x маса_erase 0
програма javascript licenses api веб-сайт go1.13.8
```

УВАГА:

- Приклад вище стирання чіпа потім програми завантажувача. Незалежно від способу, обраного для спалаху, рекомендується витирати чіп до спалаху.
- Перед тим, як миготливий SKR Mini E3 з цим завантаженням ви повинні знати, що ви більше не зможете оновити прошивку через sdcard.
- You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:
   ```
   Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
DEPRECATED! use 'adapter speed' not 'adapter_khz'
Info : BCM2835 GPIO JTAG/SWD bitbang driver
Info : JTAG and SWD modes enabled
Info : clock speed 40 kHz
Info : SWD DPIDR 0x1ba01477
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
Info : stm32f1x.cpu: external reset detected
Info : starting gdb server for stm32f1x.cpu on 3333
Info : Listening on port 3333 for gdb connections
   ```
Після чого можна випустити скидання кнопки.

Цей завантажувач вимагає 2KiB флеш-простору (додаток необхідно скомпільувати з стартовою адресою 2KiB).

Програма hid-flash використовується для завантаження бінарних навантажувач. Ви можете встановити це програмне забезпечення за допомогою наступних команд:

```
sudo apt встановити libusb-1.0
javascript licenses api веб-сайт go1.13.8
зроби
```

Якщо ви завантажувач працюєте, ви можете спалахувати з чимось схожим:

```
~/klipper/lib/hidflash/hid-flash javascript licenses api веб-сайт go1.13.8
```

ви можете використовувати `make flash` для флеш-кліппера безпосередньо:

```
зробити флеш FLASH_DEVICE=1209: BEBA
```

А якщо клиппер раніше спалахнув:

```
зробити флеш FLASH_DEVICE=/dev/ttyACM0
```

Може знадобитися вручну ввести завантажувач, це можна зробити за допомогою установки "завантаження 0" низькою і "завантаження 1" висока. На SKR Mini E3 "Ботт 1" не доступний, тому це може бути зроблено шляхом налаштування шпильки PA2 низькою, якщо ви спалахнули "hid_btt_skr_mini_e3.bin". Цей шпилька позначений "TX0" на заголовку TFT у документі SKR Mini E3. Є заземний шпилька поруч з PA2, який можна використовувати для витягування PA2 низькою.

### STM32F103/STM32F072 з завантаженням MSC

[MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-завантажувач) є бездротовим завантажувачем, здатним спалахувати над USB.

Можливо, мити завантажувач за допомогою 3.3V серійного за допомогою stm32flash, як зазначено в розділі stm32duino вище, підстановивши назву файлу для потрібного MSC завантажувача бінарного (тобто: MSCboot-Bluepill.bin для синього стовпа).

Для дощок STM32F072 також можна мити завантажувач над USB (через DFU) з чимось схожим:

```
 javaScript licenses API Веб-сайт Go1.13.8
```

Цей завантажувач використовує 8KiB або 16KiB флеш-простору, див. опис завантажувача (додаток необхідно скомпільувати з відповідною стартовою адресою).

Завантажувач може бути активований, натиснувши кнопку скидання дошки двічі. Як тільки активується завантажувач, дошка з'являється як флеш-накопичувач USB, на який файл klipper.bin можна копіювати.

### STM32F103/STM32F0x2 з завантажувачем CanBoot

[CanBoot](https://github.com/Arksine/CanBoot) bootloader забезпечує можливість завантаження прошивки Klipper над CANBUS. Сам завантажувач виходить з коду джерела Klipper. Сьогодні CanBoot підтримує моделі STM32F103, STM32F042 та STM32F072.

Рекомендується використовувати ST-Link програміст для флешки CanBoot, однак він повинен бути можливим за допомогою `stm32flash` на пристроях STM32F103, а `dfu-util` на пристроях STM32F042/STM32F072. Переглянути попередні розділи в цьому документі для інструкцій щодо цих методів миття, заміни `canboot.bin` для імені файлу, де це доречно. Репозиторій CanBoot, пов'язаний вище, надає інструкції для побудови завантажувача.

У перший раз CanBoot був спалахований, він повинен виявити, що немає програми присутні і ввести завантажувач. Якщо це не відбувається, можна ввести завантажувача, натиснувши кнопку скидання двічі у спадку.

`flash_can.py` утиліта поставляється в папці `lib/canboot` може бути використана для завантаження прошивки Klipper. Пристрої UUID необхідно спалахувати. Якщо ви не маєте UUID, це можливо для запиту вузлів, які наразі працюють завантажувачем:

```
python3 flash_can.py -q
```

Це поверне UUIDs для всіх підключених вузлів, які не призначають UUID. Це повинно включати всі вузли в даний час в завантажувачі.

Після того, як у вас є UUID, ви можете завантажити прошивку з наступним командуванням:

```
python3 flash_can.py -i can0 -р javascript licenses api веб-сайт go1.13.8 -u aabbccddeeff
```

Де ` aabbccddeeff` замінено на UUID. Зверніть увагу, що параметри `-i` та `-f` можуть бути використані, вони за замовчуванням `can0` та ` ~/klipper/out/klipper.bin` відповідно.

При побудові Кліппера для використання з CanBoot виберіть варіант завантаження 8 KiB.

## Мікроконтролери STM32F4 (SKR Pro 1.1)

Мікроконтролери STM32F4 обладнані вбудованим системним завантажувачем, здатним спалахувати над USB (через DFU), 3.3V Serial та різними способами (див. розділ STM AN2606 для отримання додаткової інформації). Деякі дошки STM32F4, такі як SKR Pro 1.1, не здатні ввести завантажувач DFU. HID Bootloader доступний для STM32F405/407 на підставі дошки повинні користувачеві віддати перевагу спалаху через USB через sdcard. Зауважте, що ви можете налаштувати і побудувати версію конкретно до вашої ради, [будування для SKR Pro 1.1 доступний тут](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest).

Якщо ваша дошка є DFU, можливо, найдоступніший спосіб миготіння, швидше за все, через 3.3V-серійне, що випливає з тієї ж процедури, як [розумка STM32F103 за допомогою stm32flash](#stm32f103-micro-controllers-blue-pill-devices). Наприклад:

```
wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin

Стм32фл -р JavaScript licenses API Веб-сайт Go1.13.8
```

Цей завантажувач вимагає 16Kib флеш-простору на STM32F4 (додаток необхідно скомпільувати з стартовою адресою 16KiB).

У STM32F1 STM32F4 використовується інструмент для завантаження бункерів до MCU. Див. інструкції, описані вище для деталей, як побудувати і використовувати hid-flash.

Може знадобитися вручну ввести завантажувача, це може бути зроблено за допомогою налаштування "завантаження 0" низький, "завантаження 1" високий і роз'єм в пристрої. Після програмування завершено розгорнути пристрій і встановити "завантажити 1" назад до низького, тому додаток буде завантажено.

## LPC176x мікроконтролери (Smoothieboards)

Цей документ не описує метод, щоб спалахувати себе завантажувача - див. <http://smoothieware.org/flashing-the-bootloader> для подальшої інформації про цю тему.

Це звичайний для смузібордів, які приходять з завантажувачем з: <https://github.com/triffid/LPC17x-DFU-Bootloader>. При використанні цього завантажувача програма повинна бути складена з стартовою адресою 16KiB. Найпростіший спосіб спалахувати додаток з цим завантаженням для копіювання файлу програми (наприклад, `out/klipper.bin`) до файлу, названого `firmware.bin` на SD-карті, а потім перезавантажити мікроконтролер з цією SD-картою.

## Запуск OpenOCD на Малини Пі

OpenOCD - це програмний пакет, який може виконати низькорівневе чіп-флешинг і відключення. Він може використовувати штифти GPIO на Raspberry Pi для спілкування з різними чіпами ARM.

Цей розділ описує, як можна встановити та запустити OpenOCD. <https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi>

Починайте завантажувати та компілювати програмне забезпечення (навчальний крок може зайняти кілька хвилин і «зробити» крок може зайняти 30+ хвилин):

```
sudo apt-get оновлення
sudo apt-get встановити autoconf libtool телnet
javascript licenses api веб-сайт go1.13.8
javascript licenses api веб-сайт go1.13.8
git клон http://openocd.zylin.com/openocd
cd openocd
./перезавантаження
./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install
зроби
встановити
```

### Налаштування OpenOCD

Створіть файл налаштування OpenOCD:

```
javascript licenses api веб-сайт go1.13.8
```

Використовуйте конфігурацію, схожу на наступне:

```
Нема Використання RPi шпильки: GPIO25 для SWDCLK, GPIO24 для SWDIO, GPIO18 для nRST
[find інтерфейс/raspberrypi2-native.cfg]
bcm2835gpio_swd_nums 25 24
bcm2835gpio_srst_num 18 років
транспорт вибрати опуклий

Нема Використання апаратного скидання дроту для скидання чіпа
JavaScript licenses API Веб-сайт
Адаптер_nsrst_delay 100 р.
Адаптер_nsrst_assert_width 100 р.

Нема Вкажіть тип чіпа
джерело [find цільовий/atsame5x.cfg]

Нема Налаштування швидкості адаптера
Адаптер_khz 40

Нема Підключення до чіпа
Увійти
цілі
скидання halt
```

### Провід Малини Пі до цільового чіпа

Poweroff як малиновий Пі і цільовий чіп перед сережкою! Перевірити цільовий чіп використовує 3.3V перед підключенням до Raspberry Pi!

Підключіть GND, SWDCLK, SWDIO та RST на цільовому чіпі до GND, GPIO25, GPIO24 та GPIO18 відповідно до Raspberry Pi.

Потім живлення Малини Пі і забезпечити живлення до цільового чіпа.

### Завантажити OpenOCD

Запуск OpenOCD:

```
javascript licenses api веб-сайт go1.13.8
javascript licenses api веб-сайт go1.13.8 -f ~/openocd/openocd.cfg
```

Визначені вище повинні викликати OpenOCD, щоб випромінювати деякі текстові повідомлення, а потім чекати (не варто негайно повернутися до командного рядка Unix). Якщо виходи OpenOCD самостійно або якщо він продовжує випромінювати текстові повідомлення, то подвійний перевірте проводку.

Після того, як OpenOCD працює і стабільний, ви можете відправити його команди через телнет. Відкрийте чергову сш-сесію і запустіть наступне:

```
telnet 127.0.0.1 4444
```

(Одно може вийти телнет, натиснувши ctrl+), а потім запустити команду "кинути".)

### OpenOCD і gdb

Можливе використання OpenOCD з gdb до debug Klipper. Наступні команди припускають один біговий диск на машині настільного класу.

Додайте наступний файл налаштування OpenOCD:

```
код товару: 0.0.0.0
javascript licenses api веб-сайт go1.13.8
```

Перезапустіть OpenOCD на Raspberry Pi, а потім запустіть команду Unix на настільній машині:

```
cd /path/to/klipper/
javascript licenses api веб-сайт go1.13.8
```

В рамках gdb запуску:

```
ціль дистанційний octopi:44444
```

(Replace "octopi" з ім'ям хостів Малина Пі.) Після того, як gdb працює, можна встановити точки розбиття і перевіряти реєстри.
