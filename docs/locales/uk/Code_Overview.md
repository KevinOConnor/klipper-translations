# Огляд коду

Цей документ описує загальну версію коду та основний потік кодів Klipper.

## Каталог Layout

Каталог **src/** містить джерело C для коду мікроконтролера. **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, **src/lpc176x/**, **src/pru/**, і **src/stm32/** каталоги містять архітектуру специфічний мікроконтролерний код. **src/simulator/** містить кодові шпильки, які дозволяють мікроконтролеру проводити тестування, зібрані на інших архітектурах. **src/generic/** каталог містить код помічника, який може бути корисний для різних архітектур. Будівля влаштовує для включає в себе "board/somefile.h" для першого погляду в поточний каталог архітектури (наприклад, src/avr/somefile.h) і потім в генеричний каталог (наприклад, src/generic/somefile.h).

Каталог **klippy/** містить програмне забезпечення хост. Більшість програмного забезпечення є письмовим на Python, проте **klippy/chelper/** каталог містить деякі C кодові помічники. **klippy/kinematics/** каталог містить код kinematics роботи. **klippy/extras/** каталог містить код хосту, що посилюється "модулі".

**lib/** каталог містить зовнішній код бібліотеки 3rd, який необхідний для побудови деяких цілей.

**config/** каталог містить приклади файлів конфігурації принтера.

**scripts/** каталог містить скрипти побудови часу, корисні для складання коду мікроконтролера.

**test/** каталог містить автоматизовані тестові випадки.

Під час складання конструктор може створити каталог **out/**. Це містить тимчасові об'єкти часу будівництва. Остаточний об'єкт мікроконтролера, який побудований **out/klipper.elf.hex** на AVR і **out/klipper.bin** на ARM.

## Micro-контрольний потік коду

Виконання коду мікроконтролера починається в специфічному для архітектури коді (наприклад, **src/avr/main.c**), який зрештою викликає sched_main(), розташований у **src/sched.c**. Код sched_main() починається із запуску всіх функцій, які були позначені макросом DECL_INIT(). Потім він продовжує багаторазово запускати всі функції, позначені макросом DECL_TASK().

Однією з основних функцій задач є команди_dispatch() розташована в **src/command.c**. Ця функція називається з плати певним вхідним / вихідним кодом (наприклад, **src/avr/serial.c**, **src/generic/serial_irq.c**) і вона працює функції команд, пов'язані з командами, що знаходяться в вхідному струмі. Командні функції заявлені за допомогою макросису DECL_COMMAND() (див. документ [protocol](Protocol.md) для отримання додаткової інформації).

Завдання, ідентифікувати, і командні функції завжди працюють з перервами, ввімкненими (як правило, вони можуть тимчасово відключати перерву, якщо це необхідно). Ці функції повинні уникати довгих паузи, затримок або зробити роботу, яка триває значного часу. (Довге затримки в цих функціях "таск" призводить до спланування Джиттера для інших "тасків" - затримок понад 100us може стати помітними, затримки більше 500us може призвести до введення командних ретрансмісій, затримки понад 100 м може призвести до перезавантаження годинника.) Ці функції працюють за певними часами.

Функції таймера плануються за допомогою виклику sched_add_timer() (розташовується в **src/sched.c**). Код планувальника влаштовує задану функцію, яка буде викликана за запитом час. Перервами таймера спочатку використовуються в архітектурі конкретний обробник перерву (наприклад, **src/avr/timer.c**), який викликає sched_timer_dispatch() розташований в **src/sched.c**. Перерва таймера призводить до виконання функцій таймера графіка. Функція таймера завжди працює з вимкненими відключенням. Функції таймера завжди повинні завершитися в декількох мікросекундах. На завершення події таймера функція може вибрати для перепланування себе.

У разі виявлення помилки коду може викликати вимкнення () (а макрос, який викликає sched_shutdown(), розташованого в **src/sched.c**). Викликання вимкнення () викликає всі функції, позначені макросом DECL_SHUTDOWN() для запуску. Відключені функції завжди працюють з відключенням.

Багато функціональних можливостей мікроконтролера передбачає роботу з загальноприйнятими вхідними / вихідними шпильками (GPIO). Для того, щоб абстрагувати конкретний код з високого рівня, всі події GPIO реалізовані в архітектурі конкретні обгортки (наприклад, **src/avr/gpio.c**). Код скомпільований з оптимізацією gcc's "-flto -fwhole-program", що робить відмінну роботу з нахилом функцій по частинах компіляції, тому більшість з цих крихітних функцій gpio вбудовані в своїх абонентів, і не існує постійної вартості для їх використання.

## Огляд коду Klippy

Хост-код (Klippy) призначений для запуску на недорогому комп'ютері (наприклад, Raspberry Pi) з мікроконтролером. Код в першу чергу написаний на Python, проте він використовує CFFI для реалізації деяких функцій в C-коді.

Початкове виконання починається в **klippy/klippy.py**. Цей читає аргументи командного рядка, відкриває файл налаштування принтера, миттєво отримує основні об'єкти принтера, і починає серійне підключення. Головне виконання команд G-коду в методі process_commands() в **klippy/gcode.py**. Цей код переводить команду G-коду на виклики об'єкта принтера, які часто переводять дії для команд, які будуть виконані на мікроконтролері (за заявленою через макросектор DECL_COMMAND у мікроконтролері).

Є чотири нитки в коді хости Klippy. Головні ручки з різьбленням Gcode команди. Друга нитка (який повністю переходить в **klippy/chelper/serialqueue.c** C код) ручок низького рівня IO з серійним портом. Третя нитка використовується для обробки повідомлень від мікроконтролера в Python-коді (див. **klippy/serialhdl.py**). Четверта нитка пише повідомлення про відключення до журналу (див. **klippy/queuelogger.py**), так що інші нитки ніколи не блокуються на записах журналу.

## Кодовий потік команди переміщення

Типовий рух принтера починається, коли команда "G1" надходить до хосту Кліппи, і вона завершується, коли на мікроконтролері виробляють відповідні імпульси. Цей розділ визначає потік коду типової команди руху. Документ [кінематика](кінематика.md) надає подальшу інформацію про механіки рухів.

* Обробка для команди руху починається в gcode.py. Мета gcode. py - перевести G-код у внутрішні дзвінки. Команда G1 буде викликати cmd_G1 () в klippy/extras/gcode_move.py. Код gcode_move.py код ручить зміни походження (наприклад, G92), зміни відносно абсолютної позиції (наприклад, G90) і зміни блоків (наприклад, F6000=100mm/s). Код переходу: `_process_data() -> _process_commands() -> cmd_G1()`. У кінцевому підсумку клас ToolHead викликаний виконання фактичного запиту: ` cmd_G1 () -> ToolHead.move()`
* Клас ToolHead (в інструментальномуголові.py) ручок "look-ahead" і відстежує термін дії друку. Головний кодпат для переміщення: `ToolHead.move() до Посилання до LookAheadQueue.flush() -> Move.set_junction() до ToolHead._process_moves()`.

   * ToolHead.move() створює об'єкт Move() з параметрами руху (в карцесському просторі і в блоках секунд і міліметрів).
   * Клас кінематики надається можливість аудиту кожного руху (`ToolHead.move() -> kin.check_move()`). Класи кінематики розташовані в klippy/kinematics/ каталозі. Введіть номер мобільного, який Ви вказали при укладаннi договору з банком - для ідентифікації. Якщо перевірте_move() завершується успішно, то основну кінематику необхідно мати можливість обробити рух.
   * LookAheadQueue.add_move() розміщує об'єкт переходу на чергу "look-ahead".
   * LookAheadQueue.flush() визначає початок та кінцеві значення кожного руху.
   * Move.set_junction() реалізує "трапецієподібний генератор" на ходу. "trapezoid генератор" розбиває кожен переїзд на три частини: постійну фазу прискорення, з подальшою стабільною швидкою фазою, з подальшою фазою декларації. Кожен перехід містить ці три фази в цьому порядку, але деякі фази можуть бути з нульової тривалості.
   * Коли ToolHead._process_moves() називається, все про переміщення відомий - його розташування, його кінцеве місце розташування, його прискорення, його початок/здійснення/закінчення швидкості, а відстань, що подорожується під час прискорення/збільшення/відкриття. Вся інформація зберігається в класі Move() і знаходиться в карцесіанському просторі в підрозділах міліметрів і секунд.
* Klipper використовує [інеративний розчинник](https://en.wikipedia.org/wiki/Root-finding_algorithm) для створення кроку для кожного кроку. З точки зору ефективності генеруються імпульси крокової залози в C-коді. Переходи спочатку розміщені на "trapezoid чергу руху": `ToolHead._process_moves() -> трапеція ` (в klippy/chelper/trapq.c). `ToolHead._process_moves() -> JavaScript licenses API Веб-сайт Go1.13.8 до JavaScript licenses API Веб-сайт Go1.13.8 -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> itersolve_gen_steps_range()` (в klippy/chelper/itersolve.c). Мета ітеративного розчинника полягає в тому, щоб знайти покрокові терміни, враховуючи функцію, яка обчислює позицію крокової від часу. Це робиться багаторазово "чуття" в різні часи до моменту отримання крокової позиції формула повертає бажане положення наступного кроку на степпері. Зворотній зв'язок, виготовлений з кожного вагітна, використовується для поліпшення майбутніх вгадок, щоб процес швидко зважився до бажаного часу. Формули позиції кінематичних степперів розташовані в каталозі klippy/chelper/ (наприклад, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c).
* Зверніть увагу, що екструдера ручається в власних kinematic класі: `ToolHead._process_moves() -> ПринтерExtruder.move()`. Так як Move() клас визначає точний час руху і так як покрокові імпульси надсилаються до мікроконтролеру з певними термінами, крокові рухи, що виробляються класом екструдера, будуть в синхронізації з рухом голови, хоча код зберігається окремо.
* Після того, як ітеративний розчинник обчислює час, які вони додаються в масив: `itersolve_gen_steps_range() -> stepcompress_append()` (в klippy/chelper/stepcompress.c). Широкий асортимент (struct stepcompress.queue) зберігає відповідні мікроконтролерні годинникові лічильники для кожного кроку. Тут значення «мікроконтролера годинникової лічильника» безпосередньо відповідає мікроконтролювальному лічильнику мікроконтролерів - це відносно того, коли мікроконтролер був прослужений.
* Наступним основним кроком є стиснення кроків: `stepcompress_flush() -> компресор_bisect_add()` (в klippy/chelper/stepcompress.c). Цей код генерує і кодує ряд мікроконтролерів "queue_step" команд, які відповідають списку крокових часів, побудованих на попередньому етапі. Ці команди "queue_step" потім чергуються, апріоризовані і надсилаються на мікроконтролер (через stepcompress.c:steppersync і серійнийqueue.c:serialqueue).
* Обробка команд queue_step на мікроконтролері починається в src/command.c, який аналізує команду та викликає `command_queue_step()`. Код command_queue_step() (у файлі src/stepper.c) просто додає параметри кожної команди queue_step до черги кожного степера. За нормальної роботи команда queue_step аналізується та ставиться в чергу принаймні за 100 мс до моменту першого кроку. Нарешті, генерація крокових подій виконується в `stepper_event()`. Він викликається з переривання апаратного таймера в запланований час першого кроку. Код stepper_event() генерує покроковий імпульс, а потім переплановує свій запуск на момент наступного покрокового імпульсу для заданих параметрів queue_step. Параметрами для кожної команди queue_step є «interval», «count» і «add». На високому рівні stepper_event() запускає таку кількість разів: `do_step(); наступний_час_пробудження = час_останнього_пробудження + інтервал; інтервал += додати;`

Здавалося б, дуже багато складнощів виконувати рух. Проте, в інструментальних заняттях є тільки цікаві частини. Це частина коду, який визначає рухи та їх терміни. Решта частини обробки в основному просто зв'язок і сантехніка.

## Додавання модуля

Код Klippy має динамічну можливість завантаження модуля. Якщо в розділі «конфігурація» зазначено «my_module» в файлі налаштування принтера, то програмне забезпечення автоматично намагатиметься завантажити модуль python klippy/extras/my_module.py . Ця система модуля є кращим методом для додавання нових функцій до Klipper.

Найпростіший спосіб додати новий модуль для використання існуючого модуля як посилання - див. **klippy/extras/servo.py** як приклад.

Також можна скористатися:

* Виконання модуля починається в рівні модуля `load_config()` функції (для розділів налаштувань форми [my_module]) або в `load_config_prefix()` (для розділів налаштування форми [my_module my_name]). Ця функція передається об'єктом "config" і вона повинна повернути новий об'єкт "printer", пов'язаний з заданим розділом конфігурації.
* Під час процесу миттєвого використання нового об'єкту принтера, об'єкт налаштування може бути використаний для зчитування параметрів з вказаного розділу налаштування. `config.get()`, `config.getfloat()`, `config.getint()` і т.д. методи. Обов'язково прочитайте всі значення з конфігурації під час побудови об'єкта принтера - якщо користувач визначає параметр налаштування, який не прочитаний під час цієї фази, то він буде запропоновано, це типо в конфігурації і помилка буде піднятися.
* Використовуйте метод `config.get_printer()` для отримання посилання на основний клас «принтер». Цей клас "принтер" зберігає посилання на всі "принтери об'єктів", які були миттєві. Використовуйте метод `printer.lookup_object()` для пошуку посилань на інші об'єкти принтера. Практично всі функціональні можливості (навіть основні кінематичними модулями) закріплюються в одному з цих об'єктів принтера. Зауважте, що коли новий модуль миттєвий, не всі інші об'єкти принтера будуть миттєві. Модуль "gcode" і "pins" завжди буде доступний, але для інших модулів це хороша ідея для видалення зовнішнього вигляду.
* Зареєструвати обробники подій за допомогою `printer.register_event_handler()` метод, якщо код повинен бути викликаний під час "подруги" підняті іншими об'єктами принтера. Кожна назва події - рядок, а за конвенцією - це ім'я головного модуля джерела, який піднімає захід разом з коротким ім'ям для дії, що відбувається (наприклад, "кліпп:зв'язок"). Параметри, що надходять до кожного обробника події, є специфічними для даного заходу (в залежності від умов обробки та виконання). Два спільних стартапів:
   * klippy:connect – ця подія генерується після створення екземплярів усіх об’єктів принтера. Він зазвичай використовується для пошуку інших об’єктів принтера, перевірки налаштувань конфігурації та виконання початкового «рукостискання» з обладнанням принтера.
   * klippy:читати - Цей захід генерується після того, як всі обробники з'єднуються успішно. Він вказує на те, що принтер переходить в стан, який готовий обробляти нормальні операції. Не підняти помилку в цьому зворотному зв'язку.
* Якщо є помилка в налаштуваннях користувача, обов'язково підніміть його під час `load_config()` або "повідомлення" фази. Використовуйте або `raise config.error("my error")` або ` растровий принтер.config_error("my error")` для повідомлення про помилку.
* Використовуйте модуль "pins" для налаштування шпильки на мікроконтролері. Це, як правило, зроблено з чимось схожий на `printer.lookup_object("pins").setup_pin("pwm", config.get("my_pin")`. Повернутий об'єкт можна замовити в режимі run-time.
* Якщо об'єкт принтера визначає `get_status()` метод потім модуль може експортувати [статус інформації](Status_Reference.md) через [macros](Command_Templates.md) і через [API Server](API_Server.md). `get_status()` метод повинен повернути словник Python з ключами, які є рядками і значеннями, які є цілими, плавлення, рядки, списки, словники, Правда, False або None. Також можуть використовуватися тюпли (і іменовані шрифти). Переліки та словники, які експортуються, повинні бути оброблені як "імітовані" - якщо їх зміни вмісту, то новий об'єкт повинен бути повернений з `get_status()`, інакше сервер API не виявить ці зміни.
* Якщо модуль потребує доступу до системних послідовників або зовнішніх дескрипторів файлів, то скористайтеся `printer.get_reactor()` для отримання доступу до глобального класу «event реактор». Цей клас реактора дозволяє одночасно планувати таймери, чекаючи введення на декриптах файлів, а також до "завантажити" хост-коду.
* Не використовуйте глобальні змінні. Весь стан слід зберігати в об'єкті принтера, що повертається з функції `load_config()`. Це важливо в іншому випадку команда RESTART не може виконуватися як очікується. Також, з аналогічних причин, якщо відкриті будь-які зовнішні файли (або розетки), то обов'язково зареєструйте "кліппи:роз'єднання" обробника події і закрийте їх з цього зворотного зв'язку.
* Уникайте доступу до внутрішніх змінних користувачів (або викличних методів, які починаються з нуля) інших об'єктів принтера. Спостереження цієї конвенції полегшує управління майбутніми змінами.
* Рекомендовано призначити значення для всіх змінних користувачів у конструкторі Python. (Таким чином, уникнення здатності Python до динамічного створення змінних користувачів.)
* Якщо змінна Python полягає в тому, щоб зберігати значення точки плавлення, то рекомендується завжди призначити і маніпулювати, що змінна з плаваючою точкою константи (і ніколи не використовувати цілі константи). Наприклад, воліє `self.speed = 1` над `self.speed = 1`, і воліє `self.speed = 2. * x` над `self.speed = 2 * x`. Консистентне використання значень точки плавлення може уникнути важко дебвугових кіл у перетвореннях типу Python.
* Якщо ви подаєте модуль для включення в основний код Кліппера, обов'язково встановіть повідомлення про авторське право у верхній частині модуля. Переглянути існуючі модулі для бажаного формату.

## Додавання нової кінематики

Цей розділ надає деякі поради щодо додавання підтримки Klipper для додаткових типів принтерів kinematics. Цей тип діяльності вимагає відмінного розуміння математичних формул для цільової кінематики. Також потрібна навички розробки програмного забезпечення - хоча потрібно лише оновити програмне забезпечення.

Корисні кроки:

1. Почати навчати "[кодовий потік руху](#code-flow-of-a-move-command)" секція та [Кіноматика документа](Kinematics.md).
1. Огляд існуючих кінематичних класів в klippy/kinematics/ каталог. Кінематичні класи виконуються з перетворенням руху в картопезькі координати руху на кожному степпері. Ви можете копіювати один з цих файлів як початкова точка.
1. Впровадити функції C stepper kinematic позицію для кожного кроку, якщо вони вже доступні (див. kin_cart.c, kin_corexy.c, kin_delta.c в klippy/chelper/). Функція повинна викликати `move_get_coord()` для перетворення заданого часу руху (в секундах) до картезійського координування (в міліметрах), а потім розрахувати бажану позицію кроку (в міліметрах) з цієї координати.
1. Впровадження `calc_position()` методу в новому класі kinematics. Цей метод розраховує позицію в карцесіанських координатах з позиції кожного кроку. Не потрібно бути ефективним, оскільки це, як правило, називається під час обробки та пробування операцій.
1. Other methods. Implement the `check_move()`, `get_status()`, `get_steppers()`, `home()`, `clear_homing_state()`, and `set_position()` methods. These functions are typically used to provide kinematic specific checks. However, at the start of development one can use boiler-plate code here.
1. Впровадження тестових випадків. Створіть файл g-коду з рядом переходів, які можуть перевірити важливі випадки для даної кінематики. Дотримуйтесь [debugging документації](Debugging.md) для перетворення цього файлу g-коду до команди мікроконтролерів. Це корисно для здійснення кутових випадків і для перевірки регресій.

## Портування на новий мікроконтролер

Цей розділ надає деякі поради щодо портування мікроконтролера Klipper до нової архітектури. Даний вид діяльності вимагає хороших знань вбудованого розвитку і практичного доступу до цільового мікроконтролера.

Корисні кроки:

1. Почати виявляти будь-які бібліотеки 3rd, які будуть використані під час порту. Загальні приклади включають в себе "CMSIS" обгортки і виробник "HAL" бібліотеки. Всі тристоронні коди повинні бути GNU GPLv3 сумісні. Код 3-ї партії повинен бути здійснений до каталогу Klipper lib/. Оновлення файлу lib/README з інформацією про те, де було отримано бібліотеку. Відповідність копіювання коду в репозиторію Кліппера, але якщо будь-які зміни потрібні, то ці зміни повинні бути вказані явно в файлі lib/README.
1. Створіть новий архітектурний підрозділ в каталозі src/ та додайте початкову підтримку Kconfig та Makefile. Використовуйте існуючі архітектури як довідник. Сарк/симулятор забезпечує базовий приклад мінімальної початкової точки.
1. Перше основне завдання кодування - довести підтримку зв'язку на цільову дошку. Це найскладніший крок у новому порту. Після того, як основне спілкування працює, інші кроки, як правило, набагато простіше. Призначений для використання серійного пристрою типу UART під час початкового розвитку, оскільки ці види апаратних пристроїв, як правило, простіше увімкнути та контролювати. Під час цієї фази ліберал може використовувати код помічника з src/generic/ каталогу (перевірити, як src/simulator/Makefile включає загальний код C в структуру). Також необхідно визначити таймер_read_time() (який повертає поточний системний годинник) в цій фазі, але не потрібно повністю підтримувати часову обробку.
1. Ознайомитися з консолі. py tool (як описано в [debugging документ](Debugging.md))) і переконатися підключення до мікроконтролера з ним. Цей інструмент переводить протокол мікроконтролерів низького рівня до читабельної форми людини.
1. Додайте підтримку відправлення таймера з апаратних переривань. Дивитися Кліппер [commit 970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f) як приклад кроків 1-5 зроблено для архітектури LPC176x.
1. Придбати базовий вхід GPIO і вихідний супровід. Див Klipper [commit c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54) як приклад цього.
1. Викличте додаткові периферійні пристрої - наприклад, див. Klipper commit [65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27), [c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5) і [c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29).
1. Створіть зразок Klipper config файл у каталозі config/. Тестування мікроконтролера з основною клипкою. py програма.
1. Враховуйте, додаючи приклади тестування на тест / каталог.

Додаткові поради кодування:

1. Уникайте використання "C bitfields" для доступу до реєстрів IO; віддайте перевагу прямій зчитування та писати операції 32bit, 16bit, або 8bit цілих. Технічні характеристики C не вказують на те, як компілятор повинен реалізувати C bitfields (наприклад, endianness, і трохи макетування), і важко визначити, які операції IO відбуваються на бітфілді або писати.
1. Надання чітких значень для реєстрів IO замість використання чит-модіфікованих операцій. Це, якщо оновлення поля в реєстрі IO, де інші поля мають відомі значення, то бажано явно писати повний вміст реєстру. Очікується записувати код, який менший, швидше, і простіше відхиляти.

## Координаційні системи

Внутрішньо, Klipper в першу чергу відстежує позицію в рядках інструментів, які відносяться до координаційної системи, зазначеної в файлі конфігурації. Це, більшість кодів Klipper ніколи не відчувають зміни в координатних системах. Якщо користувач робить запит на зміну походження (наприклад, `G92` команди), то цей ефект отримується шляхом перетягування майбутніх команд до початкової координаційної системи.

Тим не менш, в деяких випадках корисно отримати позицію інструментального головка в деяких інших координатних системах і Klipper має кілька інструментів для полегшення цього. Це можна побачити за допомогою команди GET_SETTING. Наприклад:

```
Надіслати: GET_SETTING
Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613
Recv: // stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132
Рев: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121
Рев: // Ключниця: X:8.338078 Y:-3.123175 З:233.347878 E:0.000000
Рев: // gcode: X:8.338078 Y:-3.123175 З:233.347878 E:0.000000
Реквізити: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000
Recv: // gcode кодування: кс:0.000000 Y:0.000000 Z:0.000000
```

Позиція "mcu" (`stepper.get_mcu_position()` в коді) є загальною кількістю кроків, що мікроконтролер видано в позитивному напрямку, мінус кількість кроків, виданих в негативному напрямку, оскільки мікроконтролер був останній скидання. Якщо робот перебуває в русі, коли запит видається, то вказана вартість включає переміщення на мікроконтролері, але не включає в себе переміщення по черзі.

Положення «Степпер» (`Степпер.get_commanded_position()`) є позицією даної крокової стрілки як відстежується кодом кінематики. Це, як правило, відповідає позиції (в мм) перевезення по її рейки, відносно позиції_endstop, зазначеного в файлі конфігурації. (Симові Кінематики крокової позиції в ради замість міліметрів.) Якщо робот перебуває в русі, коли запит видається, то вказана вартість включає переміщення на мікроконтролері, але не включає в себе переміщення по черзі. Один може використовуватися `toolhead.flush_step_генерація()` або `toolhead.wait_moves()` виклики, щоб повністю почистити зовнішній вигляд і покроковий код генерації.

Позиція "кінематичний" (`kin.calc_position()`) є карцеезіанською позицією інструментарію, отриманою з позицій "степпер" і є відносно координаційної системи, зазначеної в файлі конфігурації. Це може відрізнятися від запитуваного каресянського положення через гранульацію крокових двигунів. Якщо робот перебуває в русі, коли позиції «степпера» беруться тоді, вказане значення включає переміщення, що переміщуються на мікроконтролері, але не включає в себе переміщення по черзі. Один може використовуватися `toolhead.flush_step_генерація()` або `toolhead.wait_moves()` виклики, щоб повністю почистити зовнішній вигляд і покроковий код генерації.

Позиція "toolhead" (`toolhead.get_position()`) є останнім запитуваним положенням панелі інструментів в карцесіанських координатах відносно координаційної системи, зазначеної в файлі конфігурації. Якщо робот перебуває в русі, коли запит буде видана інформація, вказана вартість включає в себе всі необхідні переходи (навіть ті, хто очікується, що видається на крокові двигуни).

Позиція "gcode" - це остання запитувана позиція з `G1` (або `G0`) в картопесійських координатах відносно координаційної системи, зазначеної в файлі конфігурації. Це може відрізнятися від положення "toolhead" якщо виконується перетворення g-коду (наприклад, ліжко_mesh, ліжко_tilt, skew_correction). Це може відрізнятися від фактичних координат, зазначених в останні `G1` команди, якщо джерело g-коду було змінено (наприклад, `G92`, `SET_GCODE_OFFSET`, `M221`). `M114` команда (`gcode_move.get_status()['gcode_position']`) повідомить про позицію останнього g-коду відносно поточного g-коду координатної системи.

"Gcode base" є розташуванням походження g-коду в карцесіанських координатах відносно координаційної системи, зазначеної в файлі конфігурації. Команди, такі як `G92`, `SET_GCODE_OFFSET`, і `M221` змініть цей значення.

"gcode homing" - це місце для використання для походження g-коду (в карцесіанських координатах відносно координаційної системи, зазначеної в файлі конфігурації) після `G28` домашнього командування. `SET_GCODE_OFFSET` команда може змінити це значення.

## час

Фундаментально до роботи Кліппера – обробка годинників, часів та часових апаратів. Кліппер виконує дії на принтері шляхом планування подій, що відбуваються в найближчому майбутньому. Наприклад, для включення вентилятора, код може запланувати зміни до GPIO шпильки в 100 м. Для того, щоб прийняти миттєву дію. Таким чином, обробка часу в Klipper має вирішальне значення для коректної роботи.

Є три типи разів відстежуються внутрішньо в програмному забезпеченні Klipper:

* Час роботи Час системи використовує монотонний годинник системи - це плаваючий номер точки, що зберігається в секундах і він (рідко) відносно, коли запущений комп'ютер. Терміни системи мають обмежене використання в програмному забезпеченні - вони в першу чергу використовуються при взаємодії з операційною системою. В рамках хост-коду, час системи часто зберігаються в змінних названих *eventtime* або *curtime*.
* Час друку. Час друку синхронізується до основного годинника мікроконтролера (мікроконтролер, визначеного в розділі налаштування "[mcu]). Це плаваючий номер точки, який зберігається в секундах і є відносно того, коли основний маку був останній перезавантажений. Перетворення з "передруку часу" до основних апаратних годинників мікроконтролера шляхом збільшення часу друку статично налаштованої частоти. Високотехнологічний хост-код використовує час друку, щоб розрахувати практично всі фізичні дії (наприклад, рух голови, зміни обігрівача і т.д.). В рамках хост-коду, час друку зазвичай зберігаються в змінних значеннях *print_time* або *move_time*.
* MCU годинник. Це апаратний годинниковий лічильник на кожному мікроконтролері. Він зберігається як ціле і його рівень оновлення відносно частоти заданої мікроконтролера. Програмне забезпечення хосту переводить свої внутрішні часи до годинників до передачі в маку. Код mcu тільки коли-небудь відстежує час в годинникових клітках. У коді хосту, значення годинників відстежуються як 64bit цілих, тоді як код mcu використовує 32bit цілих чисел. У коді хосту, годинники зазвичай зберігаються у змінних з іменами, що містяться *clock* або *ticks*.

Перетворення між різними форматами часу в першу чергу виконується в **klippy/clocksync.py** код.

Деякі речі, які слід знати при перегляді коду:

* 32bit і 64bit годинники: Щоб зменшити пропускну здатність і поліпшити ефективність мікроконтролерів, годинники на мікроконтролерах відстежуються як 32bit цілих чисел. Якщо порівняти два годинники в коді mcu, то `timer_is_before()` функція завжди повинна бути використана для забезпечення цілих валків, які обробляються належним чином. Програмне забезпечення host перетворює 32bit годинники до 64bit годинники, застосувавши біти високого замовлення з останнього mcu timestamp він отримав - не повідомлення від mcu коли-небудь більше 2^31 годинникових кліщів в майбутньому або минулому, так що ця конвертація ніколи не є однозначним. Ведуться перетворення з 64bit годинників до 32bit годинників, просто розкручування висотних біт. Для забезпечення неоднозначності в цьому перетворенні, **klippy/chelper/serialqueue.c** код буде буферні повідомлення до тих пір, поки вони знаходяться в 2^31 годинникових клітках їх цільового часу.
* Кілька мікроконтролерів: Програма містить декілька мікроконтролерів на одному принтері. У цьому випадку «МКУ годинник» кожного мікроконтролера відстежується окремо. За годинникsync.py код ручить годинниковий дрейф між мікроконтролерами, змінивши спосіб, він перетворюється з "передрукувати час" в "MCU годинник". На вторинному скосі частота МКУ, яка використовується в цьому перетворенні, регулярно оновлюється до облікового запису для вимірюваного дрейфу.
