# G-коди

Цей документ описує команди які підтримує Klipper. Це команди які ви можете ввести у вікні терміналу OctoPrint.

## Команди G-коду

Klipper підтримує такі стандартні команди G-коду:

- Переміщення (G0 або G1): `G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<швидкість>]`
- Затримка: `G4 P<мілісекунди>`
- Перейти до початку: `G28 [X] [Y] [Z]`
- Вимкніть двигуни: `M18` або `M84`
- Зачекайте, поки завершаться поточні ходи: `M400`
- Використовуйте абсолютні/відносні відстані для екструзії: `M82`, `M83`
- Використовуйте абсолютні/відносні координати: `G90`, `G91`
- Установити позицію: `G92 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>]`
- Установіть відсоток перевизначення коефіцієнта швидкості: `M220 S<percent>`
- Установіть відсоток перевизначення коефіцієнта екструдування: `M221 S<percent>`
- Установити прискорення: `M204 S<value>` АБО `M204 P<value> T<value>`
   - Примітка: якщо S не вказано, а вказано як P, так і T, тоді для прискорення встановлюється мінімальне значення P і T. Якщо вказано лише одне з P або T, команда не має ефекту.
- Отримайте температуру екструдера: "M105".
- Встановіть температуру екструдера: `M104 [T<index>] [S<temperature>]`
- Встановіть температуру екструдера та зачекайте: `M109 [T<index>] S<temperature>`
   - Примітка: M109 завжди чекає, поки температура досягне заданого значення
- Встановлена температура шару: `M140 [S<temperature>]`
- Встановіть температуру ліжка та зачекайте: `M190 S<температура>`
   - Примітка: M190 завжди чекає, поки температура досягне потрібного значення
- Встановіть швидкість вентилятора: `M106 S<value>`
- Вимкніть вентилятор: `M107`
- Аварійна зупинка: `М112`
- Отримати поточну позицію: `M114`
- Отримати версію мікропрограми: `M115`

Щоб отримати додаткові відомості про команди вище, перегляньте [документацію G-коду RepRap](http://reprap.org/wiki/G-code).

Метою Klipper є підтримка команд G-Code, створених звичайним стороннім програмним забезпеченням (наприклад, OctoPrint, Printrun, Slic3r, Cura тощо) у їхніх стандартних конфігураціях. Це не мета підтримувати всі можливі команди G-коду. Натомість Klipper віддає перевагу зрозумілим для людини ["розширеним командам G-коду"](#additional-commands). Подібним чином вихід терміналу G-Code призначений лише для читання людиною - див. [документ сервера API] (API_Server.md), якщо керувати Klipper із зовнішнього програмного забезпечення.

Якщо вам потрібна менш поширена команда G-Code, її можна реалізувати за допомогою спеціального [gcode_macro конфігураційного розділу](Config_Reference.md#gcode_macro). Наприклад, це можна використовувати для реалізації: `G12`, `G29`, `G30`, `G31`, `M42`, `M80`, `M81`, `T1` тощо.

## Додаткові команди

Klipper використовує "розширені" команди G-коду для загальної конфігурації та стану. Усі ці розширені команди мають схожий формат — вони починаються з назви команди та можуть супроводжуватися одним або кількома параметрами. Наприклад: `SET_SERVO SERVO=myservo ANGLE=5.3`. У цьому документі команди та параметри наведено великими літерами, однак вони не чутливі до регістру. (Отже, "SET_SERVO" і "set_servo" запускають ту саму команду.)

Цей розділ упорядковано за назвою модуля Klipper, яка зазвичай слідує за назвами розділів, указаними у [файлі конфігурації принтера] (Config_Reference.md). Зауважте, що деякі модулі завантажуються автоматично.

### [adxl345]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації adxl345](Config_Reference.md#adxl345).

#### ACCELEROMETER_MEASURE

`ACCELEROMETER_MEASURE [CHIP=<config_name>] [NAME=<value>]`: починає вимірювання акселерометра із заданою кількістю вибірок за секунду. Якщо CHIP не вказано, за замовчуванням буде "adxl345". Команда працює в режимі старт-стоп: при першому виконанні запускає вимірювання, наступне виконання припиняє їх. Результати вимірювань записуються у файл з іменем `/tmp/adxl345-<chip>-<name>.csv`, де `<chip>` — це назва мікросхеми акселерометра (`my_chip_name` від `[adxl345 my_chip_name]` ), а `<name>` є необов'язковим параметром NAME. Якщо NAME не вказано, за замовчуванням використовується поточний час у форматі "YYYYMMDDHHMMSS." Якщо акселерометр не має назви в розділі конфігурації (просто `[adxl345]`), то частина назви `<chip>` не генерується.

#### ACCELEROMETER_QUERY

`ACCELEROMETER_QUERY [CHIP=<config_name>] [RATE=<value>]`: запитує акселерометр для поточного значення. Якщо CHIP не вказано, за замовчуванням буде "adxl345". Якщо RATE не вказано, використовується значення за замовчуванням. Ця команда корисна для перевірки підключення до акселерометра ADXL345: одним із повернених значень має бути прискорення вільного падіння (+/- певний шум мікросхеми).

#### ACCELEROMETER_DEBUG_READ

`ACCELEROMETER_DEBUG_READ [CHIP=<config_name>] REG=<register>`: надсилає запит ADXL345 на реєстр "зареєструвати" (наприклад, 44 або 0x2C). Може бути корисним для налагодження.

#### ACCELEROMETER_DEBUG_WRITE

`ACCELEROMETER_DEBUG_WRITE [CHIP=<config_name>] REG=<реєстр> VAL=<значення>`: записує необроблене «значення» в регістр «реєстр». І «значення», і «реєстр» можуть бути десятковим або шістнадцятковим цілим числом. Використовуйте обережно та зверніться до таблиці даних ADXL345 для довідки.

### [кут]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації кута](Config_Reference.md#angle).

#### ANGLE_CALIBRATE

`ANGLE_CALIBRATE CHIP=<chip_name>`: Виконайте калібрування кута на даному датчику (має бути розділ конфігурації `[angle chip_name]`, який вказав параметр `stepper`). ВАЖЛИВО: цей інструмент надає команду кроковому двигуну рухатися без перевірки нормальних кінематичних меж. В ідеалі двигун слід від’єднати від будь-якої каретки принтера перед виконанням калібрування. Якщо кроковий кроковий пристрій не можна від’єднати від принтера, перед початком калібрування переконайтеся, що каретка знаходиться біля центру напрямної. (Під час цього тесту кроковий двигун може рухатися вперед або назад на два повних оберти.) Після завершення цього тесту скористайтеся командою `SAVE_CONFIG`, щоб зберегти дані калібрування у файлі конфігурації. Щоб використовувати цей інструмент, потрібно встановити пакет Python "numpy" (додаткову інформацію див. у [документі про вимірювання резонансу](Measuring_Resonances.md#software-installation).

#### ANGLE_CHIP_CALIBRATE

`ANGLE_CHIP_CALIBRATE CHIP=<chip_name>`: Perform internal sensor calibration, if implemented (MT6826S/MT6835).

- **MT68XX**: The motor should be disconnected from any printer carriage before performing calibration. After calibration, the sensor should be reset by disconnecting the power.

#### ANGLE_DEBUG_READ

`ANGLE_DEBUG_READ CHIP=<config_name> REG=<register>`: запитує "реєстр" регістра датчика (наприклад, 44 або 0x2C). Може бути корисним для налагодження. Це доступно лише для мікросхем tle5012b.

#### ANGLE_DEBUG_WRITE

`ANGLE_DEBUG_WRITE CHIP=<config_name> REG=<register> VAL=<value>`: записує необроблене «значення» в регістр «register». І «значення», і «реєстр» можуть бути десятковим або шістнадцятковим цілим числом. Використовуйте обережно та зверніться до таблиці даних датчика для довідки. Це доступно лише для мікросхем tle5012b.

### [axis_twist_compensation]

The following commands are available when the [axis_twist_compensation config
section](Config_Reference.md#axis_twist_compensation) is enabled.

#### AXIS_TWIST_COMPENSATION_CALIBRATE

`AXIS_TWIST_COMPENSATION_CALIBRATE [AXIS=<X|Y>] [AUTO=<True|False>] [SAMPLE_COUNT=<value>]`

Calibrates axis twist compensation by specifying the target axis or enabling automatic calibration.

- **AXIS:** Define the axis (`X` or `Y`) for which the twist compensation will be calibrated. If not specified, the axis defaults to `'X'`.
- **AUTO:** Enables automatic calibration mode. When `AUTO=True`, the calibration will run for both the X and Y axes. In this mode, `AXIS` cannot be specified. If both `AXIS` and `AUTO` are provided, an error will be raised.

### [bed_mesh]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації bed_mesh](Config_Reference.md#bed_mesh) (також див. [довідник щодо сітки для ліжка](Bed_Mesh.md)).

#### BED_MESH_CALIBRATE

`BED_MESH_CALIBRATE [PROFILE=<name>] [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>] [<mesh_parameter>=<value>] [ADAPTIVE=1] [ADAPTIVE_MARGIN=<value> ]`: ця команда досліджує ліжко, використовуючи згенеровані точки, визначені параметрами в конфігурації. Після зондування генерується сітка, а z-рух регулюється відповідно до сітки. Сітка буде збережена в профілі, визначеному параметром `PROFILE`, або `default`, якщо не вказано. Дивіться команду PROBE, щоб дізнатися про додаткові параметри зонду. Якщо вказано METHOD=manual, інструмент ручного тестування активовано - дивіться команду MANUAL_PROBE вище, щоб дізнатися більше про додаткові команди, доступні, коли цей інструмент активний. Додаткове значення `HORIZONTAL_MOVE_Z` замінює параметр `horizontal_move_z`, указаний у файлі конфігурації. Якщо вказано ADAPTIVE=1, тоді об’єкти, визначені файлом Gcode, який друкується, використовуватимуться для визначення досліджуваної області. Додаткове значення `ADAPTIVE_MARGIN` замінює параметр `adaptive_margin`, указаний у файлі конфігурації.

#### BED_MESH_OUTPUT

`BED_MESH_OUTPUT PGP=[<0:1>]`: ця команда виводить на термінал поточні досліджувані значення z і поточні значення сітки. Якщо вказано PGP=1, координати X, Y, згенеровані bed_mesh, разом із відповідними індексами будуть виведені на термінал.

#### BED_MESH_MAP

`BED_MESH_MAP`: як і BED_MESH_OUTPUT, ця команда друкує поточний стан сітки на терміналі. Замість друку значень у форматі, зрозумілому людині, стан серіалізується у форматі json. Це дозволяє плагінам octoprint легко збирати дані та генерувати карти висот, які приблизно відповідають поверхні ліжка.

#### BED_MESH_CLEAR

`BED_MESH_CLEAR`: ця команда очищає сітку та видаляє всі налаштування z. Рекомендовано розмістити це у вашому кінцевому gcode.

#### BED_MESH_PROFILE

`BED_MESH_PROFILE LOAD=<name> SAVE=<name> REMOVE=<name>`: ця команда забезпечує керування профілем для стану сітки. LOAD відновить стан сітки з профілю, який відповідає наданій назві. SAVE збереже поточний стан сітки в профілі, що відповідає наданій назві. Видалити видалить профіль, який відповідає наданому імені, із постійної пам’яті. Зауважте, що після виконання операцій SAVE або REMOVE потрібно запустити gcode SAVE_CONFIG, щоб зробити зміни в постійній пам’яті постійними.

#### BED_MESH_OFFSET

`BED_MESH_OFFSET [X=<значення>] [Y=<значення>] [ZFADE=<значення]`: застосовує зміщення X, Y та/або ZFADE до пошуку сітки. Це корисно для принтерів із незалежними екструдерами, оскільки зсув необхідний для правильного налаштування Z після зміни інструменту. Зауважте, що зміщення ZFADE не застосовує додаткове коригування z напряму, воно використовується для виправлення обчислення «згасання», коли до осі Z застосовано «зміщення gcode».

### [гвинти_ліжка]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації bed_screws](Config_Reference.md#bed_screws) (також див. [посібник з ручного рівня](Manual_Level.md#adjusting-bed-leveling-screws)).

#### BED_SCREWS_ADJUST

`BED_SCREWS_ADJUST`: Ця команда викличе інструмент регулювання кріпильних гвинтів. Він керуватиме насадкою в різних місцях (як визначено у конфігураційному файлі) і дозволить регулювати гвинти станини так, щоб станина була на постійній відстані від сопла.

### [bed_tilt]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації bed_tilt](Config_Reference.md#bed_tilt).

#### BED_TILT_CALIBRATE

`BED_TILT_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>]`: ця команда перевірить точки, указані в конфігурації, а потім порекомендує оновлені налаштування нахилу x і y. Дивіться команду PROBE, щоб дізнатися про додаткові параметри зонду. Якщо вказано METHOD=manual, інструмент ручного тестування активовано - дивіться команду MANUAL_PROBE вище, щоб дізнатися більше про додаткові команди, доступні, коли цей інструмент активний. Додаткове значення `HORIZONTAL_MOVE_Z` замінює параметр `horizontal_move_z`, указаний у файлі конфігурації.

### [bltouch]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації bltouch](Config_Reference.md#bltouch) (також див. [посібник BL-Touch](BLTouch.md)).

#### BLTOUCH_DEBUG

`BLTOUCH_DEBUG COMMAND=<команда>`: надсилає команду на BLTouch. Це може бути корисним для налагодження. Доступні команди: `pin_down`, `touch_mode`, `pin_up`, `self_test`, `reset`. BL-Touch V3.0 або V3.1 також може підтримувати команди `set_5V_output_mode`, `set_OD_output_mode`, `output_mode_store`.

#### BLTOUCH_STORE

`BLTOUCH_STORE MODE=<output_mode>`: зберігає режим виведення в EEPROM BLTouch V3.1. Доступні режими виводу: `5V`, `OD`

### [файл конфігурації]

Модуль configfile завантажується автоматично.

#### SAVE_CONFIG

`SAVE_CONFIG`: ця команда перезапише основний файл конфігурації принтера та перезапустить програмне забезпечення хоста. Ця команда використовується в поєднанні з іншими командами калібрування для збереження результатів калібрувальних тестів.

### [delayed_gcode]

Наступну команду ввімкнено, якщо ввімкнено [розділ конфігурації delayed_gcode](Config_Reference.md#delayed_gcode) (також див. [посібник із шаблонів](Command_Templates.md#delayed-gcodes)).

#### UPDATE_DELAYED_GCODE

`UPDATE_DELAYED_GCODE [ID=<name>] [DURATION=<seconds>]`: оновлює тривалість затримки для визначеного [delayed_gcode] і запускає таймер для виконання gcode. Значення 0 скасує виконання відкладеного gcode, що очікує на виконання.

### [delta_calibrate]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації delta_calibrate](Config_Reference.md#linear-delta-kinematics) (також див. [посібник із калібрування дельти](Delta_Calibrate.md)).

#### DELTA_CALIBRATE

`DELTA_CALIBRATE [METHOD=manual] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>]`: ця команда перевірить сім точок на станині та рекомендує оновлені положення кінцевих упорів, кути башти та радіус. Дивіться команду PROBE, щоб дізнатися про додаткові параметри зонду. Якщо вказано METHOD=manual, інструмент ручного тестування активовано - дивіться команду MANUAL_PROBE вище, щоб дізнатися більше про додаткові команди, доступні, коли цей інструмент активний. Додаткове значення `HORIZONTAL_MOVE_Z` замінює параметр `horizontal_move_z`, указаний у файлі конфігурації.

#### DELTA_ANALYZE

`DELTA_ANALYZE`: Ця команда використовується під час розширеного дельта-калібрування. Докладніше див. у [Delta Calibrate](Delta_Calibrate.md).

### [дисплей]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації дисплея](Config_Reference.md#gcode_macro).

#### SET_DISPLAY_GROUP

`SET_DISPLAY_GROUP [DISPLAY=<дисплей>] GROUP=<група>`: установіть активну групу відображення РК-дисплея. Це дозволяє визначити декілька груп відображення даних у конфігурації, напр. `[display_data <group> <elementname>]` і перемикатися між ними за допомогою цієї розширеної команди gcode. Якщо DISPLAY не вказано, за замовчуванням буде «display» (основний дисплей).

### [дисплей_статус]

Модуль display_status завантажується автоматично, якщо ввімкнено [розділ конфігурації дисплея](Config_Reference.md#display). Він надає такі стандартні команди G-коду:

- Відображення повідомлення: `M117 <повідомлення>`
- Встановити відсоток збірки: `M73 P<percent>`

Також надається така розширена команда G-коду:

- `SET_DISPLAY_TEXT MSG=<message>`: Виконує еквівалент M117, встановлюючи наданий `MSG` як поточне повідомлення на дисплеї. Якщо `MSG` пропущено, дисплей буде очищено.

### [dual_carriage]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації dual_carriage](Config_Reference.md#dual_carriage).

#### SET_DUAL_CARRIAGE

`SET_DUAL_CARRIAGE CARRIAGE=[0|1] [MODE=[PRIMARY|COPY|MIRROR]]`: Ця команда змінить режим вказаної каретки. Якщо `РЕЖИМ` не вказано, за замовчуванням буде `ПЕРВИННИЙ`. Встановлення режиму на `PRIMARY` дезактивує іншу каретку та змушує вказану каретку виконувати наступні команди G-коду як є. Режими `COPY` і `MIRROR` підтримуються лише для `CARRIAGE=1`. Якщо встановлено будь-який із цих режимів, каретка 1 відстежуватиме подальші переміщення каретки 0 і або копіюватиме її відносні рухи (у режимі `COPY`), або виконуватиме їх у протилежному (дзеркальному) напрямку (у режимі `MIRROR`). ).

#### SAVE_DUAL_CARRIAGE_STATE

`SAVE_DUAL_CARRIAGE_STATE [NAME=<state_name>]`: Збереження поточних позицій подвійних кареток і їх режимів. Збереження та відновлення стану DUAL_CARRIAGE може бути корисним у сценаріях і макросах, а також у перевизначеннях процедур повернення до початкового місця. Якщо вказано NAME, це дозволяє назвати збережений стан у заданому рядку. Якщо NAME не вказано, за замовчуванням використовується значення "default".

#### RESTORE_DUAL_CARRIAGE_STATE

`RESTORE_DUAL_CARRIAGE_STATE [NAME=<state_name>] [MOVE=[0|1] [MOVE_SPEED=<speed>]]`: відновити попередньо збережені позиції подвійних кареток та їхні режими, якщо не вказано «MOVE=0» у цьому випадку будуть відновлені лише збережені режими, але не положення кареток. Якщо позиції відновлюються і вказано "MOVE_SPEED", то переміщення інструментальної головки виконуватимуться із заданою швидкістю (у мм/с); інакше переміщення інструментальної головки використовуватиме швидкість наведення рейки. Зауважте, що каретки відновлюють свої позиції лише над власною віссю, що може знадобитися для правильного відновлення режимів КОПІЮВАННЯ та ДЗЕРКАЛЬНОГО відображення подвійної каретки.

### [кінцева_фаза]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації endstop_phase](Config_Reference.md#endstop_phase) (також див. [посібник з фази endstop](Endstop_Phase.md)).

#### ENDSTOP_PHASE_CALIBRATE

`ENDSTOP_PHASE_CALIBRATE [STEPPER=<config_name>]`: якщо параметр STEPPER не надано, ця команда звітуватиме про статистику крокових фаз кінцевої зупинки під час попередніх операцій наведення. Якщо надається параметр STEPPER, він організовує запис даного параметра фази кінцевої зупинки у файл конфігурації (у поєднанні з командою SAVE_CONFIG).

### [exclude_object]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації exclude_object](Config_Reference.md#exclude_object) (також див. [посібник з виключення об’єктів](Exclude_Object.md)):

#### `EXCLUDE_OBJECT`

`EXCLUDE_OBJECT [NAME=назва_об’єкта] [CURRENT=1] [RESET=1]`: без параметрів буде повернуто список усіх наразі виключених об’єктів.

Якщо вказано параметр `NAME`, названий об'єкт буде виключено з друку.

Якщо вказано параметр `CURRENT`, поточний об'єкт буде виключено з друку.

Якщо задано параметр `RESET`, список виключених об'єктів буде очищено. Крім того, включення `NAME` призведе до скидання лише названого об’єкта. Це **може** спричинити помилки друку, якщо шари вже були пропущені.

#### `EXCLUDE_OBJECT_DEFINE`

`EXCLUDE_OBJECT_DEFINE [NAME=назва_об’єкта [CENTER=X,Y] [POLYGON=[[x,y],...]] [RESET=1] [JSON=1]`: надає короткий опис об’єкта у файлі.

За відсутності параметрів буде показано список визначених об’єктів, відомих Klipper. Повертає список рядків, якщо не вказано параметр `JSON`, коли він повертає деталі об’єкта у форматі json.

Якщо включено параметр `NAME`, це визначає об’єкт, який потрібно виключити.

- `NAME`: цей параметр обов'язковий. Це ідентифікатор, який використовується іншими командами в цьому модулі.
- `CENTER`: координати X, Y для об’єкта.
- `ПОЛІГОН`: масив координат X, Y, які забезпечують контур об’єкта.

Коли вказано параметр `RESET`, усі визначені об’єкти буде очищено, а модуль `[exclude_object]` буде скинуто.

#### `EXCLUDE_OBJECT_START`

`EXCLUDE_OBJECT_START NAME=назва_об’єкта`: ця команда приймає параметр `NAME` і позначає початок gcode для об’єкта на поточному рівні.

#### `EXCLUDE_OBJECT_END`

`EXCLUDE_OBJECT_END [NAME=object_name]`: позначає кінець gcode об’єкта для шару. Він поєднується з `EXCLUDE_OBJECT_START`. Параметр `NAME` необов'язковий і попереджатиме, лише якщо надане ім'я не збігається з поточним об'єктом.

### [екструдер]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації екструдера](Config_Reference.md#extruder):

#### ACTIVATE_EXTRUDER

`ACTIVATE_EXTRUDER EXTRUDER=<config_name>`: у принтері з кількома розділами конфігурації [extruder](Config_Reference.md#extruder) ця команда змінює активний hotend.

#### SET_PRESSURE_ADVANCE

`SET_PRESSURE_ADVANCE [EXTRUDER=<config_name>] [ADVANCE=<pressure_advance>] [SMOOTH_TIME=<pressure_advance_smooth_time>]`: установіть параметри підвищення тиску крокового екструдера (як визначено в [extruder](Config_Reference.md#extruder) або [  extruder_stepper](Config_Reference.md#extruder_stepper) розділ конфігурації). Якщо ЕКСТРУДЕР не вказано, за замовчуванням використовується степер, визначений у активному хотенді.

#### SET_EXTRUDER_ROTATION_DISTANCE

`SET_EXTRUDER_ROTATION_DISTANCE EXTRUDER=<config_name> [DISTANCE=<distance>]`: установіть нове значення для «відстані обертання» наданого крокового екструдера (як визначено в [extruder](Config_Reference.md#extruder) або [extruder_stepper](Config_Reference) .md#extruder_stepper) розділ конфігурації). Якщо відстань обертання є від’ємним числом, кроковий рух буде інвертованим (відносно напрямку крокового кроку, указаного у файлі конфігурації). Змінені налаштування не зберігаються під час скидання Klipper. Використовуйте з обережністю, оскільки невеликі зміни можуть призвести до надмірного тиску між екструдером і гарячою частиною. Виконайте належне калібрування нитки перед використанням. Якщо значення «DISTANCE» не вказано, ця команда поверне поточну відстань обертання.

#### SYNC_EXTRUDER_MOTION

`SYNC_EXTRUDER_MOTION EXTRUDER=<ім'я> MOTION_QUEUE=<ім'я>': ця команда викличе крок, указаний EXTRUDER (як визначено в конфігурації [extruder](Config_Reference.md#extruder) або [extruder_stepper](Config_Reference.md#extruder_stepper) розділ), щоб стати синхронізованим із рухом екструдера, визначеного MOTION_QUEUE (як визначено в розділі конфігурації [extruder](Config_Reference.md#extruder). Якщо MOTION_QUEUE є порожнім рядком, тоді кроковий механізм буде десинхронізовано від усіх рухів екструдера.

### [fan_generic]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації fan_generic](Config_Reference.md#fan_generic).

#### SET_FAN_SPEED

`SET_FAN_SPEED FAN=config_name SPEED=<швидкість>` Ця команда встановлює швидкість вентилятора. "швидкість" має бути між 0,0 і 1,0.

`SET_FAN_SPEED PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>]`: If `TEMPLATE` is specified then it assigns a [display_template](Config_Reference.md#display_template) to the given fan. For example, if one defined a `[display_template my_fan_template]` config section then one could assign `TEMPLATE=my_fan_template` here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the fan will be automatically set to the resulting speed. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use `SET_FAN_SPEED` commands to manage the values directly).

### [filament_switch_sensor]

Наступна команда доступна, якщо ввімкнено розділ конфігурації [filament_switch_sensor](Config_Reference.md#filament_switch_sensor) або [filament_motion_sensor](Config_Reference.md#filament_motion_sensor).

#### QUERY_FILAMENT_SENSOR

`QUERY_FILAMENT_SENSOR SENSOR=<назва_сенсора>`: запитує поточний статус датчика нитки. Дані, що відображаються на терміналі, залежатимуть від типу датчика, визначеного в конфігурації.

#### SET_FILAMENT_SENSOR

`SET_FILAMENT_SENSOR SENSOR=<назва_сенсора> ENABLE=[0|1]`: вмикає/вимикає датчик нитки. Якщо ENABLE встановлено на 0, датчик нитки буде вимкнено, якщо встановлено на 1, він увімкнено.

### [firmware_retraction]

Наступні стандартні команди G-Code доступні, якщо ввімкнено [розділ конфігурації firmware_retraction](Config_Reference.md#firmware_retraction). Ці команди дозволяють використовувати функцію ретракції вбудованого програмного забезпечення, доступну в багатьох слайсерах, щоб зменшити кількість рядків під час неекструзійних переміщень від однієї частини друку до іншої. Відповідне налаштування просування тиску зменшує необхідну довжину втягування.

- `G10`: втягує екструдер із використанням поточних налаштованих параметрів.
- `G11`: скасовує втягування екструдера за допомогою поточних налаштованих параметрів.

Також доступні такі додаткові команди.

#### SET_RETRACTION

`SET_RETRACTION [RETRACT_LENGTH=<мм>] [RETRACT_SPEED=<мм/с>] [UNRETRACT_EXTRA_LENGTH=<мм>] [UNRETRACT_SPEED=<мм/с>]`: налаштуйте параметри, які використовуються для ретракції мікропрограми. RETRACT_LENGTH визначає довжину нитки для втягування та розтягування. Швидкість втягування регулюється за допомогою RETRACT_SPEED і зазвичай встановлюється відносно високою. Швидкість скасування ретракції регулюється за допомогою UNRETRACT_SPEED і не є критичною, хоча часто нижча, ніж RETRACT_SPEED. У деяких випадках корисно додати невелику додаткову довжину при скасуванні відкликання, і це встановлюється через UNRETRACT_EXTRA_LENGTH. SET_RETRACTION зазвичай встановлюється як частина конфігурації слайсера для кожної нитки, оскільки для різних ниток потрібні різні налаштування параметрів.

#### GET_RETRACTION

`GET_RETRACTION`: запитує поточні параметри, які використовуються відкликанням мікропрограми, і відображає їх на терміналі.

### [force_move]

Модуль force_move завантажується автоматично, однак деякі команди вимагають налаштування `enable_force_move` у [конфігурації принтера](Config_Reference.md#force_move).

#### STEPPER_BUZZ

`STEPPER_BUZZ STEPPER=<config_name>`: перемістіть заданий степпер на один мм вперед, а потім на один мм назад, повторюючи 10 разів. Це діагностичний інструмент, який допомагає перевірити підключення крокового кроку.

#### FORCE_MOVE

`FORCE_MOVE STEPPER=<назва_конфігурації> DISTANCE=<значення> VELOCITY=<значення> [ACCEL=<значення>]`: ця команда примусово перемістить заданий крок на задану відстань (у мм) із заданою постійною швидкістю (у мм/ s). Якщо вказано значення ACCEL і воно більше нуля, буде використано задане прискорення (у мм/с^2); інакше прискорення не виконується. Граничні перевірки не проводяться; кінематичні оновлення не виконуються; інші паралельні степери на осі не будуть переміщатися. Будьте обережні, оскільки неправильна команда може призвести до пошкодження! Використання цієї команди майже напевно переведе кінематику низького рівня в неправильний стан. потім видайте G28, щоб скинути кінематику. Ця команда призначена для низькорівневої діагностики та налагодження.

#### SET_KINEMATIC_POSITION

`SET_KINEMATIC_POSITION [X=<value>] [Y=<value>] [Z=<value>] [CLEAR=<[X][Y][Z]>]`: Force the low-level kinematic code to believe the toolhead is at the given cartesian position. This is a diagnostic and debugging command; use SET_GCODE_OFFSET and/or G92 for regular axis transformations. If an axis is not specified then it will default to the position that the head was last commanded to. Setting an incorrect or invalid position may lead to internal software errors. Use the CLEAR parameter to forget the homing state for the given axes. Note that CLEAR will not override the previous functionality; if an axis is not specified to CLEAR it will have its kinematic position set as per above. This command may invalidate future boundary checks; issue a G28 afterwards to reset the kinematics.

### [gcode]

Модуль gcode завантажується автоматично.

#### ПЕРЕЗАПУСК

`ПЕРЕЗАПУСК`: це змусить програмне забезпечення хоста перезавантажити свою конфігурацію та виконати внутрішнє скидання. Ця команда не видалить стан помилки з мікроконтролера (див. FIRMWARE_RESTART), а також не завантажить нове програмне забезпечення (див. [FAQ](FAQ.md#how-do-i-upgrade-to-the-latest-software)).

#### FIRMWARE_RESTART

`FIRMWARE_RESTART`: це схоже на команду RESTART, але також очищає будь-який стан помилки мікроконтролера.

#### СТАТУС

`СТАТУС`: звіт про статус програмного забезпечення хоста Klipper.

#### ДОПОМОГА

`HELP`: звіт про список доступних розширених команд G-коду.

### [gcode_arcs]

Наступні стандартні команди G-Code доступні, якщо ввімкнено [розділ конфігурації gcode_arcs](Config_Reference.md#gcode_arcs):

- Переміщення дуги за годинниковою стрілкою (G2), переміщення дуги проти годинникової стрілки (G3): `G2|G3 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<швидкість>] I<значення> J<значення>|I<значення> K<значення>|J<значення> K<значення>`
- Вибір площини дуги: G17 (площина XY), G18 (площина XZ), G19 (площина YZ)

### [gcode_macro]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації gcode_macro](Config_Reference.md#gcode_macro) (також див. [посібник із шаблонів команд](Command_Templates.md)).

#### SET_GCODE_VARIABLE

`SET_GCODE_VARIABLE MACRO=<назва_макросу> VARIABLE=<назва> VALUE=<значення>`: ця команда дозволяє змінювати значення змінної gcode_macro під час виконання. Надане VALUE аналізується як літерал Python.

### [gcode_move]

Модуль gcode_move завантажується автоматично.

#### GET_POSITION

`GET_POSITION`: повертає інформацію про поточне розташування інструментальної головки. Додаткову інформацію див. у документації для розробників [виходу GET_POSITION](Code_Overview.md#coordinate-systems).

#### SET_GCODE_OFFSET

`SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>] [Y=<pos>|Y_ADJUST=<adjust>] [Z=<pos>|Z_ADJUST=<adjust>] [MOVE=1 [MOVE_SPEED=<speed  >]]`: установіть позиційне зміщення для застосування до майбутніх команд G-коду. Це зазвичай використовується для віртуальної зміни зміщення шару Z або для встановлення зсуву сопла XY під час перемикання екструдерів. Наприклад, якщо надіслано "SET_GCODE_OFFSET Z=0,2", то майбутні переміщення G-коду матимуть 0,2 мм до їх висоти Z. Якщо використовуються параметри стилю X_ADJUST, тоді коригування буде додано до будь-якого існуючого зміщення (наприклад, «SET_GCODE_OFFSET Z=-0,2», а потім «SET_GCODE_OFFSET Z_ADJUST=0,3» призведе до загального зміщення Z, що дорівнює 0,1). Якщо вказано «MOVE=1», буде виконано переміщення інструментальної головки для застосування заданого зміщення (інакше зміщення набуде чинності під час наступного абсолютного переміщення G-коду, що визначає дану вісь). Якщо вказано "MOVE_SPEED", то переміщення інструментальної головки виконуватиметься із заданою швидкістю (у мм/с); інакше для переміщення інструментальної головки використовуватиметься остання задана швидкість G-коду.

#### SAVE_GCODE_STATE

`SAVE_GCODE_STATE [NAME=<state_name>]`: зберегти поточний стан аналізу координат g-коду. Збереження та відновлення стану g-коду корисно в сценаріях і макросах. Ця команда зберігає поточний режим абсолютних координат g-коду (G90/G91), абсолютний режим екструдування (M82/M83), початок (G92), зміщення (SET_GCODE_OFFSET), перевизначення швидкості (M220), перевизначення екструдера (M221), швидкість переміщення , поточне положення XYZ і відносне положення екструдера "E". Якщо вказано NAME, це дозволяє назвати збережений стан у заданому рядку. Якщо NAME не вказано, за замовчуванням використовується значення "default".

#### RESTORE_GCODE_STATE

`RESTORE_GCODE_STATE [NAME=<ім'я_стану>] [MOVE=1 [MOVE_SPEED=<швидкість>]]`: відновити стан, попередньо збережений за допомогою SAVE_GCODE_STATE. Якщо вказано "MOVE=1", буде виконано переміщення інструментальної головки для повернення до попередньої позиції XYZ. Якщо вказано "MOVE_SPEED", то переміщення інструментальної головки виконуватиметься із заданою швидкістю (у мм/с); інакше переміщення інструментальної головки використовуватиме відновлену швидкість g-коду.

### [сенсор_ширини_нитки_холу]

Наступні команди доступні, коли ввімкнено [розділ конфігурації датчика ширини нитки tsl1401cl](Config_Reference.md#tsl1401cl_filament_width_sensor) або [розділ конфігурації датчика ширини нитки Холла](Config_Reference.md#hall_filament_width_sensor) (також див. [Датчик ширини нитки TSLl401CL]( TSL1401CL_Filament_Width_Sensor.md) і [Датчик ширини нитки Холла](Hall_Filament_Width_Sensor.md)):

#### QUERY_FILAMENT_WIDTH

`QUERY_FILAMENT_WIDTH`: повертає поточну виміряну ширину нитки.

#### RESET_FILAMENT_WIDTH_SENSOR

`RESET_FILAMENT_WIDTH_SENSOR`: Очистити всі показання датчика. Допомагає після заміни нитки.

#### DISABLE_FILAMENT_WIDTH_SENSOR

`DISABLE_FILAMENT_WIDTH_SENSOR`: Вимкніть датчик ширини нитки та припиніть використовувати його для контролю потоку.

#### ENABLE_FILAMENT_WIDTH_SENSOR

`ENABLE_FILAMENT_WIDTH_SENSOR`: увімкніть датчик ширини нитки та почніть використовувати його для керування потоком.

#### QUERY_RAW_FILAMENT_WIDTH

`QUERY_RAW_FILAMENT_WIDTH`: повертає поточні показники каналу АЦП і значення датчика RAW для точок калібрування.

#### ENABLE_FILAMENT_WIDTH_LOG

`ENABLE_FILAMENT_WIDTH_LOG`: увімкнути реєстрацію діаметра.

#### DISABLE_FILAMENT_WIDTH_LOG

`DISABLE_FILAMENT_WIDTH_LOG`: Вимкнути реєстрацію діаметра.

### [нагрівачі]

Модуль нагрівачів завантажується автоматично, якщо нагрівач визначено у файлі конфігурації.

#### TURN_OFF_HEATERS

`TURN_OFF_HEATERS`: Вимкнути всі обігрівачі.

#### TEMPERATURE_WAIT

`TEMPERATURE_WAIT SENSOR=<config_name> [MINIMUM=<target>] [MAXIMUM=<target>]`: зачекайте, доки даний датчик температури не досягне або перевищить вказане МІНІМАЛЬНЕ значення та/або досягне або буде нижче заданого МАКСИМУМУ.

#### SET_HEATER_TEMPERATURE

`SET_HEATER_TEMPERATURE HEATER=<heater_name> [TARGET=<target_temperature>]`: встановлює цільову температуру для обігрівача. Якщо цільова температура не вказана, цільове значення дорівнює 0.

### [idle_timeout]

Модуль idle_timeout завантажується автоматично.

#### SET_IDLE_TIMEOUT

`SET_IDLE_TIMEOUT [TIMEOUT=<timeout>]`: дозволяє користувачеві встановлювати час простою (у секундах).

### [input_shaper]

Наступну команду ввімкнено, якщо ввімкнено [розділ конфігурації input_shaper](Config_Reference.md#input_shaper) (також див. [посібник із компенсації резонансу](Resonance_Compensation.md)).

#### SET_INPUT_SHAPER

`SET_INPUT_SHAPER [SHAPER_FREQ_X=<shaper_freq_x>] [SHAPER_FREQ_Y=<shaper_freq_y>] [DAMPING_RATIO_X=<damping_ratio_x>] [DAMPING_RATIO_Y=<shaper_ratio_y>] [SHAPER_TYPE_X=<shaper_type_x>] [ SHAPER_TYPE_Y=<shaper_type_y>  ]`: змінити параметри формувача вхідних даних. Зауважте, що параметр SHAPER_TYPE скидає вхідний формувач для обох осей X і Y, навіть якщо в розділі [input_shaper] налаштовано різні типи формувача. SHAPER_TYPE не можна використовувати разом із параметрами SHAPER_TYPE_X і SHAPER_TYPE_Y. Перегляньте [довідку конфігурації](Config_Reference.md#input_shaper), щоб отримати додаткові відомості про кожен із цих параметрів.

### [ручний_зонд]

Модуль manual_probe завантажується автоматично.

#### MANUAL_PROBE

`MANUAL_PROBE [SPEED=<швидкість>]`: запустіть допоміжний сценарій, корисний для вимірювання висоти сопла в заданому місці. Якщо вказано SPEED, він встановлює швидкість команд TESTZ (за замовчуванням 5 мм/с). Під час ручного тестування доступні такі додаткові команди:

- `ACCEPT`: Ця команда приймає поточну позицію Z і завершує ручний інструмент зондування.
- `ABORT`: ця команда завершує роботу інструменту ручного зондування.
- `TESTZ Z=<value>`: ця команда переміщує сопло вгору або вниз на величину, указану в «value». Наприклад, `TESTZ Z=-,1` перемістить сопло вниз на 0,1 мм, тоді як `TESTZ Z=,1` перемістить сопло вгору на 0,1 мм. Значення також може бути `+`, `-`, `++` або `--`, щоб перемістити сопло вгору або вниз на величину відносно попередніх спроб.

#### Z_ENDSTOP_CALIBRATE

`Z_ENDSTOP_CALIBRATE [SPEED=<швидкість>]`: запустіть допоміжний сценарій, корисний для калібрування параметра конфігурації Z position_endstop. Перегляньте команду MANUAL_PROBE, щоб дізнатися більше про параметри та додаткові команди, доступні, коли інструмент активний.

#### Z_OFFSET_APPLY_ENDSTOP

`Z_OFFSET_APPLY_ENDSTOP`: взяти поточне зміщення G-коду Z (він же babystepping) і відняти його від stepper_z endstop_position. Це діє, щоб прийняти часто використовуване значення babystepping і "зробити його постійним". Потрібен `SAVE_CONFIG`, щоб вступити в силу.

### [ручний_степпер]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації manual_stepper](Config_Reference.md#manual_stepper).

#### MANUAL_STEPPER

`MANUAL_STEPPER STEPPER=назва_конфігурації [ENABLE=[0|1]] [SET_POSITION=<pos>] [SPEED=<швидкість>] [ACCEL=<accel>] [MOVE=<pos> [STOP_ON_ENDSTOP=[1|2|-  1|-2]] [SYNC=0]]`: ця команда змінить стан степера. Використовуйте параметр ENABLE, щоб увімкнути/вимкнути степпер. Використовуйте параметр SET_POSITION, щоб змусити степер вважати, що він знаходиться в заданій позиції. Використовуйте параметр MOVE, щоб запросити переміщення до заданої позиції. Якщо вказано SPEED та/або ACCEL, наведені значення використовуватимуться замість стандартних значень, указаних у файлі конфігурації. Якщо вказано нульове значення ACCEL, прискорення не виконуватиметься. Якщо вказано STOP_ON_ENDSTOP=1, переміщення завершиться раніше, якщо кінцева зупинка повідомить про спрацьовування (використовуйте STOP_ON_ENDSTOP=2, щоб завершити переміщення без помилок, навіть якщо кінцева зупинка не запускається, використовуйте -1 або -2, щоб зупинитися, коли кінцева зупинка не повідомляє спрацьовує). Зазвичай майбутні команди G-коду будуть заплановані для виконання після завершення крокового руху, однак якщо рух крокового кроку вручну використовує SYNC=0, майбутні команди руху G-коду можуть виконуватися паралельно з рухом крокового кроку.

### [mcp4018]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації mcp4018](Config_Reference.md#mcp4018).

#### SET_DIGIPOT

`SET_DIGIPOT DIGIPOT=config_name WIPER=<value>`: ця команда змінить поточне значення digipot. Зазвичай це значення має бути між 0,0 і 1,0, якщо в конфігурації не визначено «масштаб». Якщо визначено «масштаб», це значення має бути між 0,0 і «масштабом».

### [під керівництвом]

Наступна команда доступна, коли ввімкнено будь-який із [розділів конфігурації світлодіодів](Config_Reference.md#leds).

#### SET_LED

`SET_LED LED=<config_name> RED=<value> GREEN=<value> BLUE=<value> WHITE=<value> [INDEX=<index>] [TRANSMIT=0] [SYNC=1]`: це встановлює світлодіод вихід. Кожен колір "<value>" має бути від 0,0 до 1,0. Опція WHITE дійсна лише для світлодіодів RGBW. Якщо світлодіод підтримує кілька чіпів у послідовному з’єднанні, тоді можна вказати INDEX, щоб змінити колір лише даного чіпа (1 для першого чіпа, 2 для другого тощо). Якщо INDEX не надано, тоді всі світлодіоди в ланцюжку буде встановлено на наданий колір. Якщо вказано TRANSMIT=0, зміна кольору буде здійснена лише для наступної команди SET_LED, яка не вказує TRANSMIT=0; це може бути корисним у поєднанні з параметром INDEX для групування кількох оновлень у послідовному ланцюжку. За замовчуванням команда SET_LED синхронізує свої зміни з іншими поточними командами gcode. Це може призвести до небажаної поведінки, якщо світлодіоди встановлюються, коли принтер не друкує, оскільки це призведе до скидання часу простою. Якщо ретельний час не потрібен, можна вказати додатковий параметр SYNC=0, щоб застосувати зміни без скидання тайм-ауту простою.

#### SET_LED_TEMPLATE

`SET_LED_TEMPLATE LED=<назва_індикатора> TEMPLATE=<назва_шаблону> [<параметр_x>=<літерал>] [INDEX=<індекс>]`: призначити [шаблон_дисплея](Config_Reference.md#шаблон_дисплея) заданому [світлодіодному](Config_Reference) .md#світлодіоди). Наприклад, якщо визначити розділ конфігурації`[display_template my_led_template]`, то тут можна призначити `TEMPLATE=my_led_template`. Display_template має створювати розділений комами рядок, що містить чотири числа з плаваючою комою, що відповідають параметрам червоного, зеленого, синього та білого кольорів. Шаблон буде постійно оцінюватися, і світлодіод автоматично встановлюватиметься на отримані кольори. Можна встановити параметри display_template для використання під час оцінки шаблону (параметри аналізуватимуться як літерали Python). Якщо INDEX не вказано, тоді всі мікросхеми в послідовному ланцюжку світлодіода будуть встановлені на шаблон, інакше буде оновлено лише мікросхему з заданим індексом. Якщо TEMPLATE є порожнім рядком, тоді ця команда очистить будь-який попередній шаблон, призначений світлодіодному індикатору (тоді можна використовувати команди `SET_LED` для керування параметрами кольору світлодіода).

### [вихідний_контакт]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації output_pin](Config_Reference.md#output_pin).

#### SET_PIN

`SET_PIN PIN=config_name VALUE=<value>`: установіть PIN-код на заданий вихід `VALUE`. VALUE має бути 0 або 1 для «цифрових» вихідних контактів. Для контактів ШІМ встановіть значення від 0,0 до 1,0 або від 0,0 до `scale`, якщо масштаб налаштовано в розділі конфігурації output_pin.

`SET_PIN PIN=config_name TEMPLATE=<template_name> [<param_x>=<literal>]`: If `TEMPLATE` is specified then it assigns a [display_template](Config_Reference.md#display_template) to the given pin. For example, if one defined a `[display_template my_pin_template]` config section then one could assign `TEMPLATE=my_pin_template` here. The display_template should produce a string containing a floating point number with the desired value. The template will be continuously evaluated and the pin will be automatically set to the resulting value. One may set display_template parameters to use during template evaluation (parameters will be parsed as Python literals). If TEMPLATE is an empty string then this command will clear any previous template assigned to the pin (one can then use `SET_PIN` commands to manage the values directly).

### [палітра2]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації palete2](Config_Reference.md#palette2).

Друк палітри працює шляхом вбудовування спеціальних OCodes (Omega Codes) у файл GCode:

- `O1`...`O32`: ці коди зчитуються з потоку GCode, обробляються цим модулем і передаються на пристрій Palette 2.

Також доступні такі додаткові команди.

#### PALETTE_CONNECT

`PALETTE_CONNECT`: ця команда ініціалізує з’єднання з палітрою 2.

#### PALETTE_DISCONNECT

`PALETTE_DISCONNECT`: ця команда від’єднується від палітри 2.

#### PALETTE_CLEAR

`PALETTE_CLEAR`: Ця команда наказує Palette 2 очистити всі вхідні та вихідні шляхи нитки.

#### PALETTE_CUT

`PALETTE_CUT`: ця команда дає вказівку Palette 2 розрізати нитку, яка наразі завантажена в осердя з’єднання.

#### PALETTE_SMART_LOAD

`PALETTE_SMART_LOAD`: ця команда запускає інтелектуальну послідовність завантаження палітри 2. Нитка завантажується автоматично, видавлюючи її на відстань, відкалібровану на пристрої для принтера, і дає вказівки палітрі 2 після завершення завантаження. Ця команда схожа на натискання **Smart Load** безпосередньо на екрані Palette 2 після завершення завантаження нитки.

### [pid_calibrate]

Модуль pid_calibrate завантажується автоматично, якщо нагрівач визначено у конфігураційному файлі.

#### PID_CALIBRATE

`PID_CALIBRATE HEATER=<config_name> TARGET=<temperature> [WRITE_FILE=1]`: Виконайте тест калібрування PID. Зазначений нагрівач буде ввімкнено, доки не буде досягнуто вказану цільову температуру, а потім нагрівач вимкнеться та ввімкнеться на кілька циклів. Якщо ввімкнути параметр WRITE_FILE, буде створено файл /tmp/heattest.txt із журналом усіх зразків температури, взятих під час тесту.

### [pause_resume]

Наступні команди доступні, коли ввімкнено [розділ конфігурації pause_resume](Config_Reference.md#pause_resume):

#### ПАУЗА

`PAUSE`: призупиняє поточний друк. Поточна позиція фіксується для відновлення після відновлення.

#### РЕЗЮМЕ

`RESUME [VELOCITY=<value>]`: відновлює друк із паузи, спочатку відновлюючи попередньо записану позицію. Параметр VELOCITY визначає швидкість, з якою інструмент має повернутися до початкового захопленого положення.

#### CLEAR_PAUSE

`CLEAR_PAUSE`: Очищає поточний призупинений стан без відновлення друку. Це корисно, якщо ви вирішите скасувати друк після ПАУЗИ. Рекомендовано додати це до вашого стартового gcode, щоб переконатися, що стан паузи є свіжим для кожного друку.

#### CANCEL_PRINT

`CANCEL_PRINT`: скасовує поточний друк.

### [print_stats]

Модуль print_stats завантажується автоматично.

#### SET_PRINT_STATS_INFO

`SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= <current_layer>]`: передавати інформацію про зріз, як-от дію шару та підсумок, до Klipper. Додайте `SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>]` до розділу gcode початку слайсера та `SET_PRINT_STATS_INFO [CURRENT_LAYER= <current_layer>]` до розділу gcode зміни шару, щоб передати інформацію про шар із вашого слайсера до Klipper.

### [зонд]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації зонда](Config_Reference.md#probe) або [розділ конфігурації bltouch](Config_Reference.md#bltouch) (також див. [посібник з калібрування зонда](Probe_Calibrate.md)).

#### ЗОНД

`PROBE [PROBE_SPEED=<мм/с>] [LIFT_SPEED=<мм/с>] [SAMPLES=<кількість>] [SAMPLE_RETRACT_DIST=<мм>] [SAMPLES_TOLERANCE=<мм>] [SAMPLES_TOLERANCE_RETRIES=<кількість>] [SAMPLES_RESULT=медіана|середнє]`: перемістіть сопло вниз, доки не спрацює датчик. Якщо надається будь-який із додаткових параметрів, вони замінюють еквівалентне налаштування в [розділі конфігурації зонда](Config_Reference.md#probe).

#### QUERY_PROBE

`QUERY_PROBE`: Повідомити про поточний статус зонду ("запущений" або "відкритий").

#### PROBE_ACCURACY

`PROBE_ACCURACY [PROBE_SPEED=<mm/s>] [SAMPLES=<count>] [SAMPLE_RETRACT_DIST=<mm>]`: обчисліть максимальне, мінімальне, середнє, медіане та стандартне відхилення кількох зразків зонда. За замовчуванням береться 10 ЗРАЗКІВ. В іншому випадку додаткові параметри за умовчанням мають еквівалентні налаштування в розділі конфігурації зонда.

#### PROBE_CALIBRATE

`PROBE_CALIBRATE [SPEED=<швидкість>] [<probe_parameter>=<значення>]`: запустіть допоміжний сценарій, корисний для калібрування z_offset зонда. Дивіться команду PROBE, щоб дізнатися про додаткові параметри зонду. Перегляньте команду MANUAL_PROBE, щоб дізнатися більше про параметр SPEED і додаткові команди, доступні, коли інструмент активний. Зауважте, що команда PROBE_CALIBRATE використовує змінну швидкості для переміщення в напрямку XY, а також у напрямку Z.

#### Z_OFFSET_APPLY_PROBE

`Z_OFFSET_APPLY_PROBE`: Візьміть поточне зміщення Z Gcode (він же babystepping) і відніміть його від z_offset зонда. Це діє, щоб прийняти часто використовуване значення babystepping і "зробити його постійним". Потрібен `SAVE_CONFIG`, щоб вступити в силу.

### [probe_eddy_current]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації probe_eddy_current](Config_Reference.md#probe_eddy_current).

#### PROBE_EDDY_CURRENT_CALIBRATE

`PROBE_EDDY_CURRENT_CALIBRATE CHIP=<config_name>`: це запускає інструмент, який калібрує резонансні частоти датчика відповідно до висот Z. Інструменту знадобиться кілька хвилин, щоб завершити роботу. Після завершення скористайтеся командою SAVE_CONFIG, щоб зберегти результати у файлі printer.cfg.

#### LDC_CALIBRATE_DRIVE_CURRENT

`LDC_CALIBRATE_DRIVE_CURRENT CHIP=<config_name>` Цей інструмент відкалібрує регістр ldc1612 DRIVE_CURRENT0. Перед використанням цього інструменту перемістіть датчик так, щоб він знаходився біля центру ліжка та приблизно на 20 мм над поверхнею ліжка. Виконайте цю команду, щоб визначити відповідний DRIVE_CURRENT для датчика. Після виконання цієї команди використовуйте команду SAVE_CONFIG, щоб зберегти цей новий параметр у файлі конфігурації printer.cfg.

### [pwm_cycle_time]

Наступна команда доступна, коли ввімкнено [розділ конфігурації pwm_cycle_time](Config_Reference.md#pwm_cycle_time).

#### SET_PIN

`SET_PIN PIN=config_name VALUE=<value> [CYCLE_TIME=<cycle_time>]`: ця команда працює подібно до команд [output_pin](#output_pin) SET_PIN. Ця команда підтримує встановлення явного часу циклу за допомогою параметра CYCLE_TIME (вказаного в секундах). Зверніть увагу, що параметр CYCLE_TIME не зберігається між командами SET_PIN (будь-яка команда SET_PIN без явного параметра CYCLE_TIME використовуватиме `cycle_time', указаний у розділі конфігурації pwm_cycle_time).

### [quad_gantry_level]

The following commands are available when the [quad_gantry_level config section](Config_Reference.md#quad_gantry_level) is enabled.

#### QUAD_GANTRY_LEVEL

`QUAD_GANTRY_LEVEL [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>]`: This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional `RETRIES`, `RETRY_TOLERANCE`, and `HORIZONTAL_MOVE_Z` values override those options specified in the config file.

### [query_adc]

Модуль query_adc завантажується автоматично.

#### QUERY_ADC

`QUERY_ADC [NAME=<config_name>] [PULLUP=<value>]`: звіт про останнє отримане аналогове значення для налаштованого аналогового контакту. Якщо NAME не вказано, повідомляється список доступних імен adc. Якщо надається PULLUP (як значення в Омах), повідомляється необроблене аналогове значення разом із еквівалентним опором, враховуючи, що підтягування.

### [query_endstops]

Модуль query_endstops завантажується автоматично. Наразі доступні наступні стандартні команди G-коду, але використовувати їх не рекомендується:

- Отримати статус кінцевої зупинки: `M119` (використовуйте замість цього QUERY_ENDSTOPS.)

#### QUERY_ENDSTOPS

`QUERY_ENDSTOPS`: перевірте кінцеві упори осі та повідомте, чи вони "спрацьовані" чи перебувають у "відкритому" стані. Ця команда зазвичай використовується для перевірки правильності роботи кінцевого упору.

### [resonance_tester]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації resonance_tester](Config_Reference.md#resonance_tester) (також див. [посібник із вимірювання резонансів](Measuring_Resonances.md)).

#### MEASURE_AXES_NOISE

`MEASURE_AXES_NOISE`: Вимірює та виводить шум для всіх осей усіх увімкнених мікросхем акселерометра.

#### TEST_RESONANCES

`TEST_RESONANCES AXIS=<axis> [OUTPUT=<resonances,raw_data>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>] [HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [POINT=x,y,z] [INPUT_SHAPING=<0:1>]`: Runs the resonance test in all configured probe points for the requested "axis" and measures the acceleration using the accelerometer chips configured for the respective axis. "axis" can either be X or Y, or specify an arbitrary direction as `AXIS=dx,dy`, where dx and dy are floating point numbers defining a direction vector (e.g. `AXIS=X`, `AXIS=Y`, or `AXIS=1,-1` to define a diagonal direction). Note that `AXIS=dx,dy` and `AXIS=-dx,-dy` is equivalent. `chip_name` can be one or more configured accel chips, delimited with comma, for example `CHIPS="adxl345, adxl345 rpi"`. If POINT is specified it will override the point(s) configured in `[resonance_tester]`. If `INPUT_SHAPING=0` or not set(default), disables input shaping for the resonance testing, because it is not valid to run the resonance testing with the input shaper enabled. `OUTPUT` parameter is a comma-separated list of which outputs will be written. If `raw_data` is requested, then the raw accelerometer data is written into a file or a series of files `/tmp/raw_data_<axis>_[<chip_name>_][<point>_]<name>.csv` with (`<point>_` part of the name generated only if more than 1 probe point is configured or POINT is specified). If `resonances` is specified, the frequency response is calculated (across all probe points) and written into `/tmp/resonances_<axis>_<name>.csv` file. If unset, OUTPUT defaults to `resonances`, and NAME defaults to the current time in "YYYYMMDD_HHMMSS" format.

#### SHAPER_CALIBRATE

`SHAPER_CALIBRATE [AXIS=<axis>] [NAME=<name>] [FREQ_START=<min_freq>] [FREQ_END=<max_freq>] [ACCEL_PER_HZ=<accel_per_hz>][HZ_PER_SEC=<hz_per_sec>] [CHIPS=<chip_name>] [MAX_SMOOTHING=<max_smoothing>] [INPUT_SHAPING=<0:1>]`: Similarly to `TEST_RESONANCES`, runs the resonance test as configured, and tries to find the optimal parameters for the input shaper for the requested axis (or both X and Y axes if `AXIS` parameter is unset). If `MAX_SMOOTHING` is unset, its value is taken from `[resonance_tester]` section, with the default being unset. See the [Max smoothing](Measuring_Resonances.md#max-smoothing) of the measuring resonances guide for more information on the use of this feature. The results of the tuning are printed to the console, and the frequency responses and the different input shapers values are written to a CSV file(s) `/tmp/calibration_data_<axis>_<name>.csv`. Unless specified, NAME defaults to the current time in "YYYYMMDD_HHMMSS" format. Note that the suggested input shaper parameters can be persisted in the config by issuing `SAVE_CONFIG` command, and if `[input_shaper]` was already enabled previously, these parameters take effect immediately.

### [відповісти]

Наступні стандартні команди G-Code доступні, якщо ввімкнено [розділ конфігурації відповідей](Config_Reference.md#respond):

- `M118 <message>`: повторити повідомлення, перед яким налаштований префікс за умовчанням (або `echo:`, якщо префікс не налаштовано).

Також доступні такі додаткові команди.

#### ВІДПОВІСТИ

- `RESPOND MSG="<message>"`: повторити повідомлення, перед яким налаштовано налаштований префікс за замовчуванням (або `echo:`, якщо префікс не налаштовано).
- `RESPOND TYPE=echo MSG="<message>"`: повторити повідомлення, перед яким стоїть `echo:`.
- `RESPOND TYPE=echo_no_space MSG="<message>"`: повторити повідомлення, до якого додано `echo:` без пробілу між префіксом і повідомленням, корисно для сумісності з деякими плагінами octoprint, які очікують дуже специфічного форматування.
- `RESPOND TYPE=команда MSG="<message>"`: повторити повідомлення, перед яким стоїть `// `. OctoPrint можна налаштувати для відповіді на ці повідомлення (наприклад, `RESPOND TYPE=command MSG=action:pause`).
- `RESPOND TYPE=error MSG="<message>"`: повторити повідомлення, перед яким стоїть `!! `.
- `RESPOND PREFIX=<prefix> MSG="<message>"`: повторити повідомлення, перед яким стоїть `<префікс>`. (Параметр `PREFIX` матиме пріоритет над параметром `TYPE`)

### [зберегти_змінні]

Наступну команду ввімкнено, якщо ввімкнено [розділ конфігурації save_variables](Config_Reference.md#save_variables).

#### SAVE_VARIABLE

`SAVE_VARIABLE VARIABLE=<name> VALUE=<value>`: зберігає змінну на диск, щоб її можна було використовувати під час перезапусків. Усі збережені змінні завантажуються в dict `printer.save_variables.variables` під час запуску та можуть використовуватися в макросах gcode. Надане VALUE аналізується як літерал Python.

### [screws_tilt_adjust]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації screws_tilt_adjust](Config_Reference.md#screws_tilt_adjust) (також див. [посібник з ручного рівня](Manual_Level.md#adjusting-bed-leveling-screws-using-the-bed-probe))).

#### SCREWS_TILT_CALCULATE

`SCREWS_TILT_CALCULATE [DIRECTION=CW|CCW] [MAX_DEVIATION=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>]`: Ця команда викличе інструмент регулювання кріпильних гвинтів. Він надсилатиме команди насадці в різні місця (як визначено у конфігураційному файлі), досліджуючи висоту z і обчислюючи кількість обертів ручки для регулювання рівня ліжка. Якщо вказано DIRECTION, обертання ручки відбуватиметься в одному напрямку, за годинниковою стрілкою (CW) або проти годинникової стрілки (CCW). Дивіться команду PROBE, щоб дізнатися про додаткові параметри зонду. ВАЖЛИВО: Ви ПОВИННІ завжди виконувати G28 перед використанням цієї команди. Якщо вказано MAX_DEVIATION, команда викличе помилку gcode, якщо будь-яка різниця у висоті гвинта відносно висоти базового гвинта перевищує вказане значення. Додаткове значення `HORIZONTAL_MOVE_Z` замінює параметр `horizontal_move_z`, указаний у файлі конфігурації.

### [sdcard_loop]

Коли [розділ конфігурації sdcard_loop](Config_Reference.md#sdcard_loop) увімкнено, доступні такі розширені команди.

#### SDCARD_LOOP_BEGIN

`SDCARD_LOOP_BEGIN COUNT=<count>`: початок зацикленого розділу в SD-друкі. Лічильник, рівний 0, вказує на те, що розділ має бути зациклений на невизначений термін.

#### SDCARD_LOOP_END

`SDCARD_LOOP_END`: завершує зациклену секцію на SD-друкі.

#### SDCARD_LOOP_DESIST

`SDCARD_LOOP_DESIST`: завершити існуючі цикли без подальших ітерацій.

### [серво]

Наступні команди доступні, коли ввімкнено [розділ конфігурації сервосистеми](Config_Reference.md#servo).

#### SET_SERVO

`SET_SERVO SERVO=config_name [ANGLE=<градуси> | WIDTH=<seconds>]`: установіть позицію сервоприводу відповідно до заданого кута (у градусах) або ширини імпульсу (у секундах). Використовуйте `WIDTH=0`, щоб вимкнути вихід сервоприводу.

### [виправлення перекосу]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації skew_correction](Config_Reference.md#skew_correction) (також див. посібник [Skew Correction](Skew_Correction.md).

#### SET_SKEW

`SET_SKEW [XY=<ac_length,bd_length,ad_length>] [XZ=<ac,bd,ad>] [YZ=<ac,bd,ad>] [CLEAR=<0|1>]`: налаштовує [перекос ] модуль із розмірами (у мм), взятими з калібрувального відбитка. Можна ввести вимірювання для будь-якої комбінації площин, невведені площини збережуть своє поточне значення. Якщо введено `CLEAR=1`, усі виправлення перекосів буде вимкнено.

#### GET_CURRENT_SKEW

`GET_CURRENT_SKEW`: повідомляє про поточний перекіс принтера для кожної площини в радіанах і градусах. Перекіс обчислюється на основі параметрів, наданих через gcode `SET_SKEW`.

#### CALC_MEASURED_SKEW

`CALC_MEASURED_SKEW [AC=<ac_length>] [BD=<bd_length>] [AD=<ad_length>]`: обчислює та повідомляє перекіс (у радіанах і градусах) на основі виміряного відбитка. Це може бути корисним для визначення поточного перекосу принтера після застосування корекції. Це також може бути корисним перед застосуванням корекції, щоб визначити, чи потрібна корекція перекосу. Перегляньте [Корекція перекосу] (Skew_Correction.md) для отримання докладної інформації про об’єкти калібрування перекосу та вимірювання.

#### SKEW_PROFILE

`SKEW_PROFILE [LOAD=<name>] [SAVE=<name>] [REMOVE=<name>]`: Керування профілем для skew_correction. LOAD відновить спотворений стан із профілю, що відповідає наданій назві. SAVE збереже поточний стан перекосу в профілі, що відповідає наданій назві. Видалити видалить профіль, який відповідає наданому імені, із постійної пам’яті. Зауважте, що після виконання операцій SAVE або REMOVE потрібно запустити gcode SAVE_CONFIG, щоб зробити зміни в постійній пам’яті постійними.

### [smart_effector]

Кілька команд доступні, якщо ввімкнено [розділ конфігурації smart_effector](Config_Reference.md#smart_effector). Обов’язково перевірте офіційну документацію для Smart Effector на [Duet3D Wiki](https://duet3d.dozuki.com/Wiki/Smart_effector_and_carriage_adapters_for_delta_printer), перш ніж змінювати параметри Smart Effector. Також перегляньте [посібник з калібрування зонда](Probe_Calibrate.md).

#### SET_SMART_EFFECTOR

`SET_SMART_EFFECTOR [SENSITIVITY=<чутливість>] [ACCEL=<прискорення>] [RECOVERY_TIME=<час>]`: установіть параметри Smart Effector. Якщо вказано `SENSITIVITY`, відповідне значення записується в SmartEffector EEPROM (потрібно вказати `control_pin`). Прийнятні значення `<чутливості>`: 0..255, за замовчуванням 50. Нижчі значення вимагають меншої сили контакту сопла для спрацьовування (але існує більший ризик помилкового спрацьовування через вібрацію під час зондування), а вищі значення зменшують помилкове спрацьовування (але потрібна більша контактна сила для спрацьовування). Оскільки чутливість записується в EEPROM, вона зберігається після вимкнення, тому її не потрібно налаштовувати під час кожного запуску принтера. `ACCEL` і `RECOVERY_TIME` дозволяють замінити відповідні параметри під час виконання; див. [розділ конфігурації](Config_Reference.md#smart_effector) Smart Effector, щоб отримати додаткові відомості про ці параметри.

#### RESET_SMART_EFFECTOR

`RESET_SMART_EFFECTOR`: скидає чутливість Smart Effector до заводських налаштувань. У розділі конфігурації потрібно вказати `control_pin`.

### [stepper_enable]

Модуль stepper_enable завантажується автоматично.

#### SET_STEPPER_ENABLE

`SET_STEPPER_ENABLE STEPPER=<config_name> ENABLE=[0|1]`: увімкнути або вимкнути лише вказаний степер. Це інструмент діагностики та налагодження, яким слід користуватися обережно. Вимкнення двигуна осі не скидає інформацію про вихід. Ручне переміщення вимкненого степера може призвести до того, що машина працюватиме двигуном поза безпечними межами. Це може призвести до пошкодження компонентів осі, гарячих кінців і поверхні друку.

### [temperature_fan]

Наступна команда доступна, якщо ввімкнено [розділ конфігурації temperatur_fan](Config_Reference.md#temperature_fan).

#### SET_TEMPERATURE_FAN_TARGET

`SET_TEMPERATURE_FAN_TARGET temperature_fan=<temperature_fan_name> [target=<target_temperature>] [min_speed=<min_speed>] [max_speed=<max_speed>]`: встановлює цільову температуру для temperature_fan. Якщо ціль не вказано, для нього встановлюється температура, указана у файлі конфігурації. Якщо швидкості не вказано, зміни не застосовуються.

### [tmcXXXX]

Наступні команди доступні, якщо ввімкнено будь-який із [розділів конфігурації tmcXXXX](Config_Reference.md#tmc-stepper-driver-configuration).

#### DUMP_TMC

`DUMP_TMC STEPPER=<ім'я> [REGISTER=<ім'я>]`: ця команда читатиме всі регістри драйверів TMC і повідомлятиме їхні значення. Якщо надано REGISTER, буде створено лише вказаний реєстр.

#### INIT_TMC

`INIT_TMC STEPPER=<name>`: ця команда ініціалізує регістри TMC. Необхідно повторно ввімкнути драйвер, якщо живлення чіпа вимкнуто, а потім знову ввімкніть.

#### SET_TMC_CURRENT

`SET_TMC_CURRENT STEPPER=<name> CURRENT=<amps> HOLDCURRENT=<amps>`: це регулює струми запуску та утримання драйвера TMC. `HOLDCURRENT` не застосовується до драйверів tmc2660. Якщо використовується на драйвері, який має поле `globalscaler` (tmc5160 і tmc2240), якщо використовується StealthChop2, кроковий кроковий механізм потрібно утримувати в стані зупинки понад 130 мс, щоб драйвер виконав калібрування AT#1.

#### SET_TMC_FIELD

`SET_TMC_FIELD STEPPER=<ім'я> FIELD=<поле> VALUE=<значення> VELOCITY=<значення>`: це змінить значення вказаного поля реєстру драйвера TMC. Ця команда призначена лише для низькорівневої діагностики та налагодження, оскільки зміна полів під час виконання може призвести до небажаної та потенційно небезпечної поведінки вашого принтера. Натомість постійні зміни слід вносити за допомогою файлу конфігурації принтера. Для наведених значень перевірки на працездатність не виконуються. Замість VALUE також можна вказати VELOCITY. Ця швидкість перетворюється на 20-бітне представлення значення на основі TSTEP. Використовуйте аргумент ШВИДКІСТЬ лише для полів, які представляють швидкості.

### [насадка]

Модуль інструментальної головки завантажується автоматично.

#### SET_VELOCITY_LIMIT

`SET_VELOCITY_LIMIT [VELOCITY=<значення>] [ACCEL=<значення>] [MINIMUM_CRUISE_RATIO=<значення>] [SQUARE_CORNER_VELOCITY=<значення>]`: ця команда може змінити обмеження швидкості, указані у файлі конфігурації принтера. Опис кожного параметра див. у [розділі конфігурації принтера](Config_Reference.md#printer).

### [tuning_tower]

Модуль tuning_tower завантажується автоматично.

#### TUNING_TOWER

`TUNING_TOWER COMMAND=<команда> PARAMETER=<ім'я> START=<значення> [SKIP=<значення>] [FACTOR=<значення> [BAND=<значення>]] | [STEP_DELTA=<значення> STEP_HEIGHT=<значення>]`: інструмент для налаштування параметра для кожної висоти Z під час друку. Інструмент виконає задану `КОМАНДУ` із заданим `ПАРАМЕТРОМ`, призначеним для значення, яке змінюється в залежності від `Z` відповідно до формули. Використовуйте `FACTOR`, якщо ви будете використовувати лінійку або штангенциркуль для вимірювання висоти Z оптимального значення, або `STEP_DELTA` і `STEP_HEIGHT`, якщо модель вежі налаштування має смуги дискретних значень, як це зазвичай буває для веж температур. Якщо вказано `SKIP=<value>`, процес налаштування не починається, доки не буде досягнуто Z висоти `<value>`, а нижче цього значення буде встановлено на `START`; у цьому випадку «z_height», що використовується у формулах нижче, насправді є «max(z - пропуск, 0)». Є три можливі комбінації варіантів:

- `FACTOR`: значення змінюється зі швидкістю `factor` на міліметр. Використовується така формула: «значення = початок + коефіцієнт * z_висота». Ви можете включити оптимальну висоту Z безпосередньо у формулу, щоб визначити оптимальне значення параметра.
- `FACTOR` і `BAND`: значення змінюється із середньою швидкістю `factor` на міліметр, але в окремих діапазонах, де коригування здійснюватиметься лише через кожні `BAND` міліметри висоти Z. Використовується така формула: «значення = початок + коефіцієнт * ((поверх(z_висота / діапазон) + .5) * діапазон)».
- `STEP_DELTA` і `STEP_HEIGHT`: значення змінюється на `STEP_DELTA` кожні `STEP_HEIGHT` міліметрів. Використовується така формула: `value = start + step_delta * floor(z_height / step_height)`. Щоб визначити оптимальне значення, ви можете просто порахувати діапазони або прочитати етикетки настроювальних веж.

### [virtual_sdcard]

Klipper підтримує такі стандартні команди G-Code, якщо ввімкнено [розділ конфігурації virtual_sdcard](Config_Reference.md#virtual_sdcard):

- Список SD-карт: `M20`
- Ініціалізація SD-карти: `M21`
- Виберіть файл SD: `M23 <filename>`
- Початок/відновлення друку SD: `M24`
- Призупинити друк SD: `M25`
- Установіть позицію SD: `M26 S<offset>`
- Повідомити про стан друку SD: `M27`

Крім того, наведені нижче розширені команди доступні, якщо ввімкнено розділ конфігурації "virtual_sdcard".

#### SDCARD_PRINT_FILE

`SDCARD_PRINT_FILE FILENAME=<ім'я файлу>`: завантажте файл і почніть друк SD.

#### SDCARD_RESET_FILE

`SDCARD_RESET_FILE`: вивантажити файл і очистити стан SD.

### [z_thermal_adjust]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації z_thermal_adjust](Config_Reference.md#z_thermal_adjust).

#### SET_Z_THERMAL_ADJUST

`SET_Z_THERMAL_ADJUST [ENABLE=<0:1>] [TEMP_COEFF=<значення>] [REF_TEMP=<значення>]`: увімкнути або вимкнути температурне регулювання Z за допомогою `ENABLE`. Вимкнення не видаляє будь-які вже застосовані коригування, але призведе до заморожування поточного значення коригування - це запобігає потенційно небезпечному руху вниз по Z. Повторне ввімкнення потенційно може призвести до переміщення інструмента вгору під час оновлення та застосування коригування. `TEMP_COEFF` дозволяє налаштовувати температурний коефіцієнт налаштування під час виконання (тобто параметр конфігурації `TEMP_COEFF`). Значення `TEMP_COEFF` не зберігаються в конфігурації. `REF_TEMP` вручну змінює еталонну температуру, яка зазвичай встановлюється під час повернення до початкової точки (для використання, наприклад, у нестандартних процедурах повернення до початкової точки) – буде скинуто автоматично після повернення до початкової точки.

### [z_tilt]

Наступні команди доступні, якщо ввімкнено [розділ конфігурації z_tilt](Config_Reference.md#z_tilt).

#### Z_TILT_ADJUST

`Z_TILT_ADJUST [RETRIES=<value>] [RETRY_TOLERANCE=<value>] [HORIZONTAL_MOVE_Z=<value>] [<probe_parameter>=<value>]`: This command will probe the points specified in the config and then make independent adjustments to each Z stepper to compensate for tilt. See the PROBE command for details on the optional probe parameters. The optional `RETRIES`, `RETRY_TOLERANCE`, and `HORIZONTAL_MOVE_Z` values override those options specified in the config file.

### [temperature_probe]

Наступні команди доступні, коли ввімкнено [розділ конфігурації temperature_probe](Config_Reference.md#temperature_probe).

#### TEMPERATURE_PROBE_CALIBRATE

`TEMPERATURE_PROBE_CALIBRATE [PROBE=<назва зонда>] [TARGET=<значення>] [STEP=<значення>]`: ініціює калібрування дрейфу зонда для датчиків на основі вихрових струмів. `TARGET` — цільова температура для останнього зразка. Коли температура, зареєстрована під час зразка, перевищить калібрування «ЦІЛЬ» буде завершено. Параметр `STEP` встановлює дельту температури (у С) між зразками. Після взяття проби ця дельта використовується для планування виклику `TEMPERATURE_PROBE_NEXT`. За умовчанням `STEP` дорівнює 2.

#### TEMPERATURE_PROBE_NEXT

`TEMPERATURE_PROBE_NEXT`: після початку калібрування виконується ця команда для взяття наступного зразка. Його запуск автоматично заплановано, коли досягнуто дельта, визначену `STEP`, однак цю команду також можна запустити вручну, щоб примусово створити новий зразок. Ця команда доступна лише під час калібрування.

#### TEMPERATURE_PROBE_COMPLETE:

`TEMPERATURE_PROBE_COMPLETE`: можна використовувати для завершення калібрування та збереження поточного результату до досягнення температури `TARGET`. Ця команда доступна лише під час калібрування.

#### ПЕРЕРАТИ

`ABORT`: перериває процес калібрування, відкидаючи поточні результати.  Ця команда доступна лише під час калібрування дрейфу.

### TEMPERATURE_PROBE_ENABLE

`TEMPERATURE_PROBE_ENABLE ENABLE=[0|1]`: вмикає або вимикає компенсацію дрейфу температури. Якщо ENABLE встановлено на 0, компенсація дрейфу буде вимкнена, якщо встановлено на 1, вона ввімкнена.
