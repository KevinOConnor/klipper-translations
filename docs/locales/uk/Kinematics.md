# Кінематика

Цей документ надає огляд того, як Klipper реалізує рух роботи (їїї [кінематики](https://en.wikipedia.org/wiki/Kinematics)). Вміст може бути цікавим як розробникам, які зацікавлені в роботі на програмному забезпеченні, так і користувачам, які зацікавлені в кращому розумінні механіки їх машин.

## Прискорення

Klipper реалізує постійну схему прискорення, коли швидкість зміни голови друку - швидкість поступово змінюється на нову швидкість замість раптового дрочіння до неї. Кліппер завжди застосовує прискорення між головою інструменту та друком. Запобігання, залишивши екструдера, може бути досить крихким - швидкими струменями та/або зовнішніми змінами потоку призводять до низької якості та слабкої адгезії. Навіть коли не викривлення, якщо головка друку на одному рівні, як друк, то швидке дрочіння голови може викликати порушення нещодавно відкладеного ниток. Зміна швидкості друку голови (відносна до друку) знижує ризики порушення друку.

Також важливо обмежити прискорення, щоб крокові двигуни не пропустити або покласти зайвий стрес на машині. Кліппер обмежує крутний момент на кожному степпері за рахунок обмеження прискорення головки друку. Захоплюючий прискорення на головці друку, природно, обмежує крутний момент степперів, які рухають голову друку (і навпаки не завжди вірно).

Klipper реалізує постійне прискорення. Основна формула для постійного прискорення:

```
швидкість(час) = start_velocity + accel*time
```

## Трапезоїдний генератор

Кліппер використовує традиційний "трапецієїдний генератор" для моделювання руху кожного руху - кожен рух має початкову швидкість, він прискорює до швидкості зрізу при постійному прискорення, він круїзує на постійній швидкості, а потім скасовує до кінцевої швидкості за допомогою постійного прискорення.

![trapezoid](img/trapezoid..png)

Це називається "trapezoid генератор", оскільки схема швидкості руху виглядає як трапеція.

Швидкість зрізу завжди більше, ніж або дорівнює швидкості запуску і швидкості кінця. Фаза прискорення може бути від нульової тривалості (якщо початкова швидкість дорівнює швидкості зрізання), фаза зрізу може бути нульовою тривалістю (якщо рух негайно починає детекляцію після прискорення), а/або фазу декларації може бути нульовою тривалістю (якщо кінцева швидкість дорівнює швидкості зрізання).

![trapezoids](img/trapezoids.png)

## Дивитися

Система "look-ahead" використовується для визначення швидкості кутів між переміщеннями.

Розглянемо наступні два переміщення, що містяться на площині XY:

![corner](img/corner.png)

У вищезазначеній ситуації можна повністю детератувати після першого руху, а потім повністю прискорити при старті наступного руху, але це не ідеально, оскільки все, що прискорення і детелерація значно підвищить час друку і часті зміни в вихідного потоку призведе до низької якості друку.

Щоб вирішити це, механізм «look-ahead» чергує кілька незручних рухів і аналізує кути між переміщеннями, щоб визначити розумну швидкість, яка може бути отримана під час «включення» між двома переміщеннями. Якщо наступний рух майже в тому ж напрямку, то голову потрібно лише уповільнити трохи (якщо взагалі).

![lookahead](img/lookahead.png)

Однак, якщо наступний рух утворює гострий кут (голова збирається подорожувати практично зворотним напрямком на наступному русі), то дозволяється тільки невелика швидкість з'єднання.

![lookahead](img/lookahead-slow.png)

Швидкості перехрестя визначаються за допомогою "апроксимованого доцентрового прискорення". Найкраще [описано автором](https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/). Однак у Klipper швидкості перехрестя налаштовуються шляхом визначення бажаної швидкості кута 90° («швидкість прямокутного кута»), і швидкості перехрестя для інших кутів виводяться з цього.

Ключова формула для пошуку:

```
кінцева_швидкість^2 = початкова_швидкість^2 + 2*прискорення*відстань_переміщення
```

### Мінімальне співвідношення круїзу

Кліппер також реалізує механізм згладжування руху коротких «зигзагів». Розглянемо наступні переміщення:

![zigzag](img/zigzag.png)

У вищезазначених часті зміни від прискорення до депарації можуть викликати машину, щоб перемогти, що викликає стрес на машині і збільшує шум. Кліппер реалізує механізм забезпечення постійного руху на швидкості обробітку між прискоренням та декларацією. Це робиться шляхом зменшення верхньої швидкості деяких ходів (або послідовності руху) для забезпечення максимальної відстані, що подорожується на швидкості зрізу порівняно з дистанцією, що проходить під час прискорення та декларації.

Klipper реалізує цю функцію, відстежуючи як регулярне прискорення руху, так і віртуальну "прискорення до декларації" швидкість:

![smoothed](img/smoothed.png)

Зокрема, код розраховує, що швидкість кожного руху буде обмежена цим віртуальним «прискоренням до декларації» швидкістю. У вищезгаданому малюнку сірі лінії відображають цей віртуальний рівень прискорення для першого ходу. Якщо переїзд не може досягти повної швидкості за допомогою цієї швидкості віртуального прискорення, то його швидкість зводиться до максимальної швидкості, вона може отримати при цьому швидкість віртуального прискорення.

Для більшості переміщення ліміту буде або над існуючими лімітами руху, а не зміною поведінки індукується. Для коротких зигзаг рухається, однак, цей ліміт зменшує швидкість вершини. Зауважте, що не змінює фактичний прискорення в ході руху - переміщення продовжує використовувати нормальну схему прискорення до її регулювання швидкості.

## Формування кроків

Після завершення процесу пошуку, рух заголовка друку для даного руху повністю відомий (час, стартова позиція, кінцева позиція, швидкість в кожній точці) і можливість генерувати покрокові часи для руху. Цей процес виконується в рамках "кінематичних класів" в коді Кліппера. Зовні цих кінематичних класів, все відстежується в міліметрах, секундах і в карцесіанських координатних приміщеннях. Це завдання кінематичних класів для перетворення з цієї координатної системи в апаратні особливості конкретного принтера.

Klipper використовує [інеративний розчинник](https://en.wikipedia.org/wiki/Root-finding_algorithm) для створення кроку для кожного кроку. Код містить формули для розрахунку ідеальної карцесійської координації голови в кожен момент, і він має кінематичні формули для розрахунку ідеальної крокової позиції на основі карцесійських координат. З цими формулами, Klipper може визначити ідеальний час, який крок повинен бути на кожному кроці позиції. Наведені кроки потім плануються в зазначені терміни.

Основна формула, щоб визначити, наскільки далеко рух повинен подорожувати під постійним прискоренням:

```
відстань_переміщення = (швидкість_початку + .5 * прискорення * час_переміщення) * час_переміщення
```

і ключова формула для руху з постійною швидкістю:

```
відстань_переміщення = крейсерська_швидкість * час_переміщення
```

Ключові формули визначення координаційної координати руху, наданої відстані руху:

```
декартова_позиція = початок_x + відстань_переміщення * загальне_переміщення_x / загальне_переміщення
 декартове_положення_у_позиції = початок_у + відстань_переміщення * загальне_переміщення_у / загальне_переміщення
 decartesian_z_position = start_z + move_distance * total_z_movement / total_movement
```

### Картезіанські роботи

Генерування кроків для принтерів карцезів - найпростіший випадок. Рух на кожній осі безпосередньо пов'язаний з переміщенням в карцесієвому просторі.

Основні формули:

```
stepper_x_position = декартова_позиція_x
 stepper_y_position = декартова_позиція_y
 stepper_z_position = декартова_позиція_z
```

### CoreXY Роботи

Генерування кроків на верстаті CoreXY є лише більш складним, ніж базові роботи карцесіанів. Основні формули:

```
stepper_a_posesian_x_posesian_y_tion
stepper_b_позиція = cartesian_x_положення - cartesian_y_положення
stepper_z_position = кошики_z_положення
```

### Дельта Роботи

Покрокове покоління на роботі дельта на основі теореми Пітагораса:

```
stepper_position = (кв.м.)
- (cartesian_x_tion - вежа_x_положення)^2
- (cartesian_y_tion - вежа_y_положення)^2)
+ кошик
```

### Обмеження прискорення крокової двигуна

За допомогою дельта-кінематики можна для переміщення, який прискорює в карцесієвому просторі, щоб вимагати прискорення на конкретному кроковому двигуні більше, ніж прискорення руху. Це може статися, коли кроковий кронштейн більш горизонтальний, ніж вертикальний і лінія руху проходить біля вежі крокової. Незважаючи на те, що ці переміщення можуть вимагати прискорення крокового двигуна, більше, ніж максимальне налаштування принтера, ефективна маса, яка переміщається, що stepper буде меншою. Таким чином, більший кроковий прискорення не призводить до значно вище крокової крутки і тому вважається нешкідливим.

Тим не менш, щоб уникнути екстремальних випадків, Klipper застосовує максимальну стелю на степлері прискорення тричі налаштовується максимальна швидкість руху принтера. (Сімейно, максимальна швидкість крокової залози обмежена в три рази максимальна швидкість руху.) Для того, щоб забезпечити цей ліміт, пересувається на крайній край конструкції конверт (де кроковий кронштейн може бути майже горизонтальним) буде мати менший максимальний прискорення і швидкість.

### Екструдер кінематики

Кліппер реалізує екструдерний рух у власних кінематичних класах. З моменту закінчення і швидкості кожного руху голови друку повністю відомий для кожного руху, можна розрахувати покрокові часи для екструдера самостійно з покрокових розрахункових головок.

Основний рух екструдера простий для розрахунку. Покрокове покоління часу використовує ті ж формули, які використовують кареські роботи:

```
stepper_position = запитуваний_e_положення
```

### Прогнозування

Експериментація показало, що це можливо для поліпшення моделювання вирубки за базовою формулою екструдера. У ідеальному випадку, як екструзія рухається прогресу, однаковий об'єм нитки повинен бути відкладений в кожну точку вздовж руху і після руху не повинно бути об'єму, що виводиться після руху. На жаль, є загальним для того, щоб знайти, що основні екструзійні формули викликають занадто мало ниток, щоб вийти з екструзії при старті екструзійних ходів і для надлишку ниток, щоб екструдувати після екструзійних кінців. Це часто згадується як «зефір».

![ooze](img/ooze.png)

Система «випередження тиску» намагається врахувати це, використовуючи іншу модель для екструдера. Замість того, щоб наївно вірити, що кожен мм^3 нитки, що подається в екструдер, призведе до того, що така кількість мм^3 негайно виходить з екструдера, він використовує модель, засновану на тиску. Тиск зростає, коли нитка проштовхується в екструдер (як у [законі Гука](https://en.wikipedia.org/wiki/Hooke%27s_law)), і тиск, необхідний для екструдування, залежить від швидкості потоку через отвір сопла (як у [законі Пуазейля](https://en.wikipedia.org/wiki/Poiseuille_law)). Ключова ідея полягає в тому, що зв’язок між ниткою, тиском і швидкістю потоку можна змоделювати за допомогою лінійного коефіцієнта:

```
pa_позиція = номінальний_поставка + тиск_advance_coeff * номінальний_velocity
```

Див. [Налаштування](Pressure_Advance.md) документ для інформації про те, як знайти цей коефіцієнт підвищення тиску.

Базова формула переднього тиску може викликати двигун екструдера, щоб зробити різкі зміни швидкості. Кліппер реалізує «змотування» руху екструдера, щоб уникнути цього.

![pressure-advance](img/pressure-velocity.png)

Наведений графік показує приклад двох екструзійних переходів з ненульною швидкістю кутів між ними. Зверніть увагу, що система підвищення тиску викликає додаткові нитки, щоб бути відштовховані в екструдера під час прискорення. Чим вище бажана швидкість потоку ниток, тим більше ниток потрібно підштовхуватися під час прискорення до обліку тиску. Під час декатерації голови екстра загинається (вихід буде мати негативну швидкість).

"розморожування" реалізується за допомогою вагового посередина позиції екструдера протягом невеликого періоду часу (як зазначено `pressure_advance_smooth_time` параметр налаштування). Цей averaging може проміжок декількох g-кодових переходів. Зауважте, як двигун екструдера почне переміщатися до номінального запуску першого екструзійного руху і продовжить рухатися після номінального кінця останнього екструзійного руху.

Ключова формула для "змоченого тиску заздалегідь":

```
гладка_pa_положення(t) =
* (smooth_time/2 - abs(t - x) * dx,
від=t-smooth_time/2, to=t+smooth_time/2)
/ (smooth_time/2)^2 )
```
