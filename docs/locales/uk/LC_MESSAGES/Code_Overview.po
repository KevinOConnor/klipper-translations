# Максим Горпиніч <mgorpinic2005@gmail.com>, 2024.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2024-11-07 00:00+0000\n"
"Last-Translator: Максим Горпиніч <mgorpinic2005@gmail.com>\n"
"Language-Team: Ukrainian <https://hosted.weblate.org/projects/klipper/"
"code_overview/uk/>\n"
"Language: uk\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 5.8.2\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr ""
"Цей документ описує загальну версію коду та основний потік кодів Klipper."

msgid "Directory Layout"
msgstr "Каталог Layout"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"Каталог **src/** містить джерело C для коду мікроконтролера. **src/atsam/**, "
"**src/atsamd/**, **src/avr/**, **src/linux/**, **src/lpc176x/**, **src/pru/**"
", і **src/stm32/** каталоги містять архітектуру специфічний "
"мікроконтролерний код. **src/simulator/** містить кодові шпильки, які "
"дозволяють мікроконтролеру проводити тестування, зібрані на інших "
"архітектурах. **src/generic/** каталог містить код помічника, який може бути "
"корисний для різних архітектур. Будівля влаштовує для включає в себе \"board"
"/somefile.h\" для першого погляду в поточний каталог архітектури (наприклад, "
"src/avr/somefile.h) і потім в генеричний каталог (наприклад, src/generic/"
"somefile.h)."

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"Каталог **klippy/** містить програмне забезпечення хост. Більшість "
"програмного забезпечення є письмовим на Python, проте **klippy/chelper/** "
"каталог містить деякі C кодові помічники. **klippy/kinematics/** каталог "
"містить код kinematics роботи. **klippy/extras/** каталог містить код хосту, "
"що посилюється \"модулі\"."

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr ""
"**lib/** каталог містить зовнішній код бібліотеки 3rd, який необхідний для "
"побудови деяких цілей."

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr "**config/** каталог містить приклади файлів конфігурації принтера."

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr ""
"**scripts/** каталог містить скрипти побудови часу, корисні для складання "
"коду мікроконтролера."

msgid "The **test/** directory contains automated test cases."
msgstr "**test/** каталог містить автоматизовані тестові випадки."

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"Під час складання конструктор може створити каталог **out/**. Це містить "
"тимчасові об'єкти часу будівництва. Остаточний об'єкт мікроконтролера, який "
"побудований **out/klipper.elf.hex** на AVR і **out/klipper.bin** на ARM."

msgid "Micro-controller code flow"
msgstr "Micro-контрольний потік коду"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"Виконання коду мікроконтролера починається в специфічному для архітектури "
"коді (наприклад, **src/avr/main.c**), який зрештою викликає sched_main(), "
"розташований у **src/sched.c**. Код sched_main() починається із запуску всіх "
"функцій, які були позначені макросом DECL_INIT(). Потім він продовжує "
"багаторазово запускати всі функції, позначені макросом DECL_TASK()."

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"Однією з основних функцій задач є команди_dispatch() розташована в **src/"
"command.c**. Ця функція називається з плати певним вхідним / вихідним кодом ("
"наприклад, **src/avr/serial.c**, **src/generic/serial_irq.c**) і вона працює "
"функції команд, пов'язані з командами, що знаходяться в вхідному струмі. "
"Командні функції заявлені за допомогою макросису DECL_COMMAND() (див. "
"документ [protocol](Protocol.md) для отримання додаткової інформації)."

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"Функції таймера плануються за допомогою виклику sched_add_timer() ("
"розташовується в **src/sched.c**). Код планувальника влаштовує задану "
"функцію, яка буде викликана за запитом час. Перервами таймера спочатку "
"використовуються в архітектурі конкретний обробник перерву (наприклад, **src/"
"avr/timer.c**), який викликає sched_timer_dispatch() розташований в **src/"
"sched.c**. Перерва таймера призводить до виконання функцій таймера графіка. "
"Функція таймера завжди працює з вимкненими відключенням. Функції таймера "
"завжди повинні завершитися в декількох мікросекундах. На завершення події "
"таймера функція може вибрати для перепланування себе."

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"У разі виявлення помилки коду може викликати вимкнення () (а макрос, який "
"викликає sched_shutdown(), розташованого в **src/sched.c**). Викликання "
"вимкнення () викликає всі функції, позначені макросом DECL_SHUTDOWN() для "
"запуску. Відключені функції завжди працюють з відключенням."

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"Багато функціональних можливостей мікроконтролера передбачає роботу з "
"загальноприйнятими вхідними / вихідними шпильками (GPIO). Для того, щоб "
"абстрагувати конкретний код з високого рівня, всі події GPIO реалізовані в "
"архітектурі конкретні обгортки (наприклад, **src/avr/gpio.c**). Код "
"скомпільований з оптимізацією gcc's \"-flto -fwhole-program\", що робить "
"відмінну роботу з нахилом функцій по частинах компіляції, тому більшість з "
"цих крихітних функцій gpio вбудовані в своїх абонентів, і не існує постійної "
"вартості для їх використання."

msgid "Klippy code overview"
msgstr "Огляд коду Klippy"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"Хост-код (Klippy) призначений для запуску на недорогому комп'ютері ("
"наприклад, Raspberry Pi) з мікроконтролером. Код в першу чергу написаний на "
"Python, проте він використовує CFFI для реалізації деяких функцій в C-коді."

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"Початкове виконання починається в **klippy/klippy.py**. Цей читає аргументи "
"командного рядка, відкриває файл налаштування принтера, миттєво отримує "
"основні об'єкти принтера, і починає серійне підключення. Головне виконання "
"команд G-коду в методі process_commands() в **klippy/gcode.py**. Цей код "
"переводить команду G-коду на виклики об'єкта принтера, які часто переводять "
"дії для команд, які будуть виконані на мікроконтролері (за заявленою через "
"макросектор DECL_COMMAND у мікроконтролері)."

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"Є чотири нитки в коді хости Klippy. Головні ручки з різьбленням Gcode "
"команди. Друга нитка (який повністю переходить в **klippy/chelper/serialqueue"
".c** C код) ручок низького рівня IO з серійним портом. Третя нитка "
"використовується для обробки повідомлень від мікроконтролера в Python-коді ("
"див. **klippy/serialhdl.py**). Четверта нитка пише повідомлення про "
"відключення до журналу (див. **klippy/queuelogger.py**), так що інші нитки "
"ніколи не блокуються на записах журналу."

msgid "Code flow of a move command"
msgstr "Кодовий потік команди переміщення"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"Типовий рух принтера починається, коли команда \"G1\" надходить до хосту "
"Кліппи, і вона завершується, коли на мікроконтролері виробляють відповідні "
"імпульси. Цей розділ визначає потік коду типової команди руху. Документ "
"[кінематика](кінематика.md) надає подальшу інформацію про механіки рухів."

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"Обробка для команди руху починається в gcode.py. Мета gcode. py - перевести "
"G-код у внутрішні дзвінки. Команда G1 буде викликати cmd_G1 () в klippy/"
"extras/gcode_move.py. Код gcode_move.py код ручить зміни походження ("
"наприклад, G92), зміни відносно абсолютної позиції (наприклад, G90) і зміни "
"блоків (наприклад, F6000=100mm/s). Код переходу: `_process_data() -> "
"_process_commands() -> cmd_G1()`. У кінцевому підсумку клас ToolHead "
"викликаний виконання фактичного запиту: ` cmd_G1 () -> ToolHead.move()`"

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr ""
"ToolHead.move() створює об'єкт Move() з параметрами руху (в карцесському "
"просторі і в блоках секунд і міліметрів)."

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"Клас кінематики надається можливість аудиту кожного руху (`ToolHead.move() -"
"> kin.check_move()`). Класи кінематики розташовані в klippy/kinematics/ "
"каталозі. Введіть номер мобільного, який Ви вказали при укладаннi договору з "
"банком - для ідентифікації. Якщо перевірте_move() завершується успішно, то "
"основну кінематику необхідно мати можливість обробити рух."

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction() реалізує \"трапецієподібний генератор\" на ходу. "
"\"trapezoid генератор\" розбиває кожен переїзд на три частини: постійну фазу "
"прискорення, з подальшою стабільною швидкою фазою, з подальшою фазою "
"декларації. Кожен перехід містить ці три фази в цьому порядку, але деякі "
"фази можуть бути з нульової тривалості."

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"Коли ToolHead._process_moves() називається, все про переміщення відомий - "
"його розташування, його кінцеве місце розташування, його прискорення, його "
"початок/здійснення/закінчення швидкості, а відстань, що подорожується під "
"час прискорення/збільшення/відкриття. Вся інформація зберігається в класі "
"Move() і знаходиться в карцесіанському просторі в підрозділах міліметрів і "
"секунд."

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"Зверніть увагу, що екструдера ручається в власних kinematic класі: `ToolHead."
"_process_moves() -> ПринтерExtruder.move()`. Так як Move() клас визначає "
"точний час руху і так як покрокові імпульси надсилаються до мікроконтролеру "
"з певними термінами, крокові рухи, що виробляються класом екструдера, будуть "
"в синхронізації з рухом голови, хоча код зберігається окремо."

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"Після того, як ітеративний розчинник обчислює час, які вони додаються в "
"масив: `itersolve_gen_steps_range() -> stepcompress_append()` (в klippy/"
"chelper/stepcompress.c). Широкий асортимент (struct stepcompress.queue) "
"зберігає відповідні мікроконтролерні годинникові лічильники для кожного "
"кроку. Тут значення «мікроконтролера годинникової лічильника» безпосередньо "
"відповідає мікроконтролювальному лічильнику мікроконтролерів - це відносно "
"того, коли мікроконтролер був прослужений."

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"Наступним основним кроком є стиснення кроків: `stepcompress_flush() -> "
"компресор_bisect_add()` (в klippy/chelper/stepcompress.c). Цей код генерує і "
"кодує ряд мікроконтролерів \"queue_step\" команд, які відповідають списку "
"крокових часів, побудованих на попередньому етапі. Ці команди \"queue_step\" "
"потім чергуються, апріоризовані і надсилаються на мікроконтролер (через "
"stepcompress.c:steppersync і серійнийqueue.c:serialqueue)."

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"Обробка команд queue_step на мікроконтролері починається в src/command.c, "
"який аналізує команду та викликає `command_queue_step()`. Код "
"command_queue_step() (у файлі src/stepper.c) просто додає параметри кожної "
"команди queue_step до черги кожного степера. За нормальної роботи команда "
"queue_step аналізується та ставиться в чергу принаймні за 100 мс до моменту "
"першого кроку. Нарешті, генерація крокових подій виконується в "
"`stepper_event()`. Він викликається з переривання апаратного таймера в "
"запланований час першого кроку. Код stepper_event() генерує покроковий "
"імпульс, а потім переплановує свій запуск на момент наступного покрокового "
"імпульсу для заданих параметрів queue_step. Параметрами для кожної команди "
"queue_step є «interval», «count» і «add». На високому рівні stepper_event() "
"запускає таку кількість разів: `do_step(); наступний_час_пробудження = "
"час_останнього_пробудження + інтервал; інтервал += додати;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"Здавалося б, дуже багато складнощів виконувати рух. Проте, в "
"інструментальних заняттях є тільки цікаві частини. Це частина коду, який "
"визначає рухи та їх терміни. Решта частини обробки в основному просто "
"зв'язок і сантехніка."

msgid "Adding a host module"
msgstr "Додавання модуля"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"Код Klippy має динамічну можливість завантаження модуля. Якщо в розділі "
"«конфігурація» зазначено «my_module» в файлі налаштування принтера, то "
"програмне забезпечення автоматично намагатиметься завантажити модуль python "
"klippy/extras/my_module.py . Ця система модуля є кращим методом для "
"додавання нових функцій до Klipper."

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr ""
"Найпростіший спосіб додати новий модуль для використання існуючого модуля як "
"посилання - див. **klippy/extras/servo.py** як приклад."

msgid "The following may also be useful:"
msgstr "Також можна скористатися:"

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"Виконання модуля починається в рівні модуля `load_config()` функції (для "
"розділів налаштувань форми [my_module]) або в `load_config_prefix()` (для "
"розділів налаштування форми [my_module my_name]). Ця функція передається "
"об'єктом \"config\" і вона повинна повернути новий об'єкт \"printer\", "
"пов'язаний з заданим розділом конфігурації."

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"Під час процесу миттєвого використання нового об'єкту принтера, об'єкт "
"налаштування може бути використаний для зчитування параметрів з вказаного "
"розділу налаштування. `config.get()`, `config.getfloat()`, `config.getint()` "
"і т.д. методи. Обов'язково прочитайте всі значення з конфігурації під час "
"побудови об'єкта принтера - якщо користувач визначає параметр налаштування, "
"який не прочитаний під час цієї фази, то він буде запропоновано, це типо в "
"конфігурації і помилка буде піднятися."

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"Використовуйте метод `config.get_printer()` для отримання посилання на "
"основний клас «принтер». Цей клас \"принтер\" зберігає посилання на всі "
"\"принтери об'єктів\", які були миттєві. Використовуйте метод `printer."
"lookup_object()` для пошуку посилань на інші об'єкти принтера. Практично всі "
"функціональні можливості (навіть основні кінематичними модулями) "
"закріплюються в одному з цих об'єктів принтера. Зауважте, що коли новий "
"модуль миттєвий, не всі інші об'єкти принтера будуть миттєві. Модуль \"gcode"
"\" і \"pins\" завжди буде доступний, але для інших модулів це хороша ідея "
"для видалення зовнішнього вигляду."

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"Зареєструвати обробники подій за допомогою `printer.register_event_handler()`"
" метод, якщо код повинен бути викликаний під час \"подруги\" підняті іншими "
"об'єктами принтера. Кожна назва події - рядок, а за конвенцією - це ім'я "
"головного модуля джерела, який піднімає захід разом з коротким ім'ям для "
"дії, що відбувається (наприклад, \"кліпп:зв'язок\"). Параметри, що надходять "
"до кожного обробника події, є специфічними для даного заходу (в залежності "
"від умов обробки та виконання). Два спільних стартапів:"

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect – ця подія генерується після створення екземплярів усіх об’"
"єктів принтера. Він зазвичай використовується для пошуку інших об’єктів "
"принтера, перевірки налаштувань конфігурації та виконання початкового "
"«рукостискання» з обладнанням принтера."

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:читати - Цей захід генерується після того, як всі обробники "
"з'єднуються успішно. Він вказує на те, що принтер переходить в стан, який "
"готовий обробляти нормальні операції. Не підняти помилку в цьому зворотному "
"зв'язку."

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"Якщо є помилка в налаштуваннях користувача, обов'язково підніміть його під "
"час `load_config()` або \"повідомлення\" фази. Використовуйте або `raise "
"config.error(\"my error\")` або ` растровий принтер.config_error(\"my error\""
")` для повідомлення про помилку."

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"Використовуйте модуль \"pins\" для налаштування шпильки на мікроконтролері. "
"Це, як правило, зроблено з чимось схожий на `printer.lookup_object(\"pins\")."
"setup_pin(\"pwm\", config.get(\"my_pin\")`. Повернутий об'єкт можна замовити "
"в режимі run-time."

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"Якщо модуль потребує доступу до системних послідовників або зовнішніх "
"дескрипторів файлів, то скористайтеся `printer.get_reactor()` для отримання "
"доступу до глобального класу «event реактор». Цей клас реактора дозволяє "
"одночасно планувати таймери, чекаючи введення на декриптах файлів, а також "
"до \"завантажити\" хост-коду."

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"Не використовуйте глобальні змінні. Весь стан слід зберігати в об'єкті "
"принтера, що повертається з функції `load_config()`. Це важливо в іншому "
"випадку команда RESTART не може виконуватися як очікується. Також, з "
"аналогічних причин, якщо відкриті будь-які зовнішні файли (або розетки), то "
"обов'язково зареєструйте \"кліппи:роз'єднання\" обробника події і закрийте "
"їх з цього зворотного зв'язку."

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr ""
"Уникайте доступу до внутрішніх змінних користувачів (або викличних методів, "
"які починаються з нуля) інших об'єктів принтера. Спостереження цієї "
"конвенції полегшує управління майбутніми змінами."

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr ""
"Якщо ви подаєте модуль для включення в основний код Кліппера, обов'язково "
"встановіть повідомлення про авторське право у верхній частині модуля. "
"Переглянути існуючі модулі для бажаного формату."

msgid "Adding new kinematics"
msgstr "Додавання нової кінематики"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"Цей розділ надає деякі поради щодо додавання підтримки Klipper для "
"додаткових типів принтерів kinematics. Цей тип діяльності вимагає відмінного "
"розуміння математичних формул для цільової кінематики. Також потрібна "
"навички розробки програмного забезпечення - хоча потрібно лише оновити "
"програмне забезпечення."

msgid "Useful steps:"
msgstr "Корисні кроки:"

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"Почати навчати \"[кодовий потік руху](#code-flow-of-a-move-command)\" секція "
"та [Кіноматика документа](Kinematics.md)."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"Огляд існуючих кінематичних класів в klippy/kinematics/ каталог. Кінематичні "
"класи виконуються з перетворенням руху в картопезькі координати руху на "
"кожному степпері. Ви можете копіювати один з цих файлів як початкова точка."

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"Впровадити функції C stepper kinematic позицію для кожного кроку, якщо вони "
"вже доступні (див. kin_cart.c, kin_corexy.c, kin_delta.c в klippy/chelper/). "
"Функція повинна викликати `move_get_coord()` для перетворення заданого часу "
"руху (в секундах) до картезійського координування (в міліметрах), а потім "
"розрахувати бажану позицію кроку (в міліметрах) з цієї координати."

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"Впровадження `calc_position()` методу в новому класі kinematics. Цей метод "
"розраховує позицію в карцесіанських координатах з позиції кожного кроку. Не "
"потрібно бути ефективним, оскільки це, як правило, називається під час "
"обробки та пробування операцій."

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"Інші методи. `check_move()`, `get_status()`, `get_steppers`, `home()`, і "
"`set_position()` Ці функції зазвичай використовуються для надання "
"кінематичних специфічних перевірок. Однак на старті розробки можна "
"скористатися котельно-платним кодом тут."

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"Впровадження тестових випадків. Створіть файл g-коду з рядом переходів, які "
"можуть перевірити важливі випадки для даної кінематики. Дотримуйтесь ["
"debugging документації](Debugging.md) для перетворення цього файлу g-коду до "
"команди мікроконтролерів. Це корисно для здійснення кутових випадків і для "
"перевірки регресій."

msgid "Porting to a new micro-controller"
msgstr "Портування на новий мікроконтролер"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr ""
"Цей розділ надає деякі поради щодо портування мікроконтролера Klipper до "
"нової архітектури. Даний вид діяльності вимагає хороших знань вбудованого "
"розвитку і практичного доступу до цільового мікроконтролера."

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"Почати виявляти будь-які бібліотеки 3rd, які будуть використані під час "
"порту. Загальні приклади включають в себе \"CMSIS\" обгортки і виробник \"HAL"
"\" бібліотеки. Всі тристоронні коди повинні бути GNU GPLv3 сумісні. Код 3-ї "
"партії повинен бути здійснений до каталогу Klipper lib/. Оновлення файлу lib/"
"README з інформацією про те, де було отримано бібліотеку. Відповідність "
"копіювання коду в репозиторію Кліппера, але якщо будь-які зміни потрібні, то "
"ці зміни повинні бути вказані явно в файлі lib/README."

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"Створіть новий архітектурний підрозділ в каталозі src/ та додайте початкову "
"підтримку Kconfig та Makefile. Використовуйте існуючі архітектури як "
"довідник. Сарк/симулятор забезпечує базовий приклад мінімальної початкової "
"точки."

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"Ознайомитися з консолі. py tool (як описано в [debugging документ](Debugging."
"md))) і переконатися підключення до мікроконтролера з ним. Цей інструмент "
"переводить протокол мікроконтролерів низького рівня до читабельної форми "
"людини."

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr ""
"Створіть зразок Klipper config файл у каталозі config/. Тестування "
"мікроконтролера з основною клипкою. py програма."

msgid "Consider adding build test cases in the test/ directory."
msgstr "Враховуйте, додаючи приклади тестування на тест / каталог."

msgid "Coordinate Systems"
msgstr "Координаційні системи"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"Внутрішньо, Klipper в першу чергу відстежує позицію в рядках інструментів, "
"які відносяться до координаційної системи, зазначеної в файлі конфігурації. "
"Це, більшість кодів Klipper ніколи не відчувають зміни в координатних "
"системах. Якщо користувач робить запит на зміну походження (наприклад, `G92` "
"команди), то цей ефект отримується шляхом перетягування майбутніх команд до "
"початкової координаційної системи."

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"Тим не менш, в деяких випадках корисно отримати позицію інструментального "
"головка в деяких інших координатних системах і Klipper має кілька "
"інструментів для полегшення цього. Це можна побачити за допомогою команди "
"GET_SETTING. Наприклад:"

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"Положення «Степпер» (`Степпер.get_commanded_position()`) є позицією даної "
"крокової стрілки як відстежується кодом кінематики. Це, як правило, "
"відповідає позиції (в мм) перевезення по її рейки, відносно позиції_endstop, "
"зазначеного в файлі конфігурації. (Симові Кінематики крокової позиції в ради "
"замість міліметрів.) Якщо робот перебуває в русі, коли запит видається, то "
"вказана вартість включає переміщення на мікроконтролері, але не включає в "
"себе переміщення по черзі. Один може використовуватися `toolhead."
"flush_step_генерація()` або `toolhead.wait_moves()` виклики, щоб повністю "
"почистити зовнішній вигляд і покроковий код генерації."

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"Позиція \"кінематичний\" (`kin.calc_position()`) є карцеезіанською позицією "
"інструментарію, отриманою з позицій \"степпер\" і є відносно координаційної "
"системи, зазначеної в файлі конфігурації. Це може відрізнятися від "
"запитуваного каресянського положення через гранульацію крокових двигунів. "
"Якщо робот перебуває в русі, коли позиції «степпера» беруться тоді, вказане "
"значення включає переміщення, що переміщуються на мікроконтролері, але не "
"включає в себе переміщення по черзі. Один може використовуватися `toolhead."
"flush_step_генерація()` або `toolhead.wait_moves()` виклики, щоб повністю "
"почистити зовнішній вигляд і покроковий код генерації."

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"Позиція \"toolhead\" (`toolhead.get_position()`) є останнім запитуваним "
"положенням панелі інструментів в карцесіанських координатах відносно "
"координаційної системи, зазначеної в файлі конфігурації. Якщо робот "
"перебуває в русі, коли запит буде видана інформація, вказана вартість "
"включає в себе всі необхідні переходи (навіть ті, хто очікується, що "
"видається на крокові двигуни)."

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"Позиція \"gcode\" - це остання запитувана позиція з `G1` (або `G0`) в "
"картопесійських координатах відносно координаційної системи, зазначеної в "
"файлі конфігурації. Це може відрізнятися від положення \"toolhead\" якщо "
"виконується перетворення g-коду (наприклад, ліжко_mesh, ліжко_tilt, "
"skew_correction). Це може відрізнятися від фактичних координат, зазначених в "
"останні `G1` команди, якщо джерело g-коду було змінено (наприклад, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). `M114` команда (`gcode_move."
"get_status()['gcode_position']`) повідомить про позицію останнього g-коду "
"відносно поточного g-коду координатної системи."

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"\"Gcode base\" є розташуванням походження g-коду в карцесіанських "
"координатах відносно координаційної системи, зазначеної в файлі "
"конфігурації. Команди, такі як `G92`, `SET_GCODE_OFFSET`, і `M221` змініть "
"цей значення."

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"\"gcode homing\" - це місце для використання для походження g-коду (в "
"карцесіанських координатах відносно координаційної системи, зазначеної в "
"файлі конфігурації) після `G28` домашнього командування. `SET_GCODE_OFFSET` "
"команда може змінити це значення."

msgid "Time"
msgstr "час"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"Фундаментально до роботи Кліппера – обробка годинників, часів та часових "
"апаратів. Кліппер виконує дії на принтері шляхом планування подій, що "
"відбуваються в найближчому майбутньому. Наприклад, для включення "
"вентилятора, код може запланувати зміни до GPIO шпильки в 100 м. Для того, "
"щоб прийняти миттєву дію. Таким чином, обробка часу в Klipper має вирішальне "
"значення для коректної роботи."

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr ""
"Є три типи разів відстежуються внутрішньо в програмному забезпеченні Klipper:"

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"Час роботи Час системи використовує монотонний годинник системи - це "
"плаваючий номер точки, що зберігається в секундах і він (рідко) відносно, "
"коли запущений комп'ютер. Терміни системи мають обмежене використання в "
"програмному забезпеченні - вони в першу чергу використовуються при взаємодії "
"з операційною системою. В рамках хост-коду, час системи часто зберігаються в "
"змінних названих *eventtime* або *curtime*."

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"Час друку. Час друку синхронізується до основного годинника мікроконтролера ("
"мікроконтролер, визначеного в розділі налаштування \"[mcu]). Це плаваючий "
"номер точки, який зберігається в секундах і є відносно того, коли основний "
"маку був останній перезавантажений. Перетворення з \"передруку часу\" до "
"основних апаратних годинників мікроконтролера шляхом збільшення часу друку "
"статично налаштованої частоти. Високотехнологічний хост-код використовує час "
"друку, щоб розрахувати практично всі фізичні дії (наприклад, рух голови, "
"зміни обігрівача і т.д.). В рамках хост-коду, час друку зазвичай "
"зберігаються в змінних значеннях *print_time* або *move_time*."

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"MCU годинник. Це апаратний годинниковий лічильник на кожному "
"мікроконтролері. Він зберігається як ціле і його рівень оновлення відносно "
"частоти заданої мікроконтролера. Програмне забезпечення хосту переводить "
"свої внутрішні часи до годинників до передачі в маку. Код mcu тільки коли-"
"небудь відстежує час в годинникових клітках. У коді хосту, значення "
"годинників відстежуються як 64bit цілих, тоді як код mcu використовує 32bit "
"цілих чисел. У коді хосту, годинники зазвичай зберігаються у змінних з "
"іменами, що містяться *clock* або *ticks*."

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr ""
"Перетворення між різними форматами часу в першу чергу виконується в **klippy/"
"clocksync.py** код."

msgid "Some things to be aware of when reviewing the code:"
msgstr "Деякі речі, які слід знати при перегляді коду:"

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"32bit і 64bit годинники: Щоб зменшити пропускну здатність і поліпшити "
"ефективність мікроконтролерів, годинники на мікроконтролерах відстежуються "
"як 32bit цілих чисел. Якщо порівняти два годинники в коді mcu, то "
"`timer_is_before()` функція завжди повинна бути використана для забезпечення "
"цілих валків, які обробляються належним чином. Програмне забезпечення host "
"перетворює 32bit годинники до 64bit годинники, застосувавши біти високого "
"замовлення з останнього mcu timestamp він отримав - не повідомлення від mcu "
"коли-небудь більше 2^31 годинникових кліщів в майбутньому або минулому, так "
"що ця конвертація ніколи не є однозначним. Ведуться перетворення з 64bit "
"годинників до 32bit годинників, просто розкручування висотних біт. Для "
"забезпечення неоднозначності в цьому перетворенні, **klippy/chelper/"
"serialqueue.c** код буде буферні повідомлення до тих пір, поки вони "
"знаходяться в 2^31 годинникових клітках їх цільового часу."

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"Кілька мікроконтролерів: Програма містить декілька мікроконтролерів на "
"одному принтері. У цьому випадку «МКУ годинник» кожного мікроконтролера "
"відстежується окремо. За годинникsync.py код ручить годинниковий дрейф між "
"мікроконтролерами, змінивши спосіб, він перетворюється з \"передрукувати "
"час\" в \"MCU годинник\". На вторинному скосі частота МКУ, яка "
"використовується в цьому перетворенні, регулярно оновлюється до облікового "
"запису для вимірюваного дрейфу."

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Надіслати: GET_SETTING\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Рев: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Рев: // Ключниця: X:8.338078 Y:-3.123175 З:233.347878 E:0.000000\n"
"Рев: // gcode: X:8.338078 Y:-3.123175 З:233.347878 E:0.000000\n"
"Реквізити: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode кодування: кс:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "Огляд коду"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"Позиція \"mcu\" (`stepper.get_mcu_position()` в коді) є загальною кількістю "
"кроків, що мікроконтролер видано в позитивному напрямку, мінус кількість "
"кроків, виданих в негативному напрямку, оскільки мікроконтролер був останній "
"скидання. Якщо робот перебуває в русі, коли запит видається, то вказана "
"вартість включає переміщення на мікроконтролері, але не включає в себе "
"переміщення по черзі."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"Додайте підтримку відправлення таймера з апаратних переривань. Дивитися "
"Кліппер [commit 970831ee](https://github.com/Klipper3d/klipper/commit/"
"970831ee0d3b91897196e92270d98b2a3067427f) як приклад кроків 1-5 зроблено для "
"архітектури LPC176x."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"Придбати базовий вхід GPIO і вихідний супровід. Див Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/"
"c78b90767f19c9e8510c3155b89fb7ad64ca3c54) як приклад цього."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"Викличте додаткові периферійні пристрої - наприклад, див. Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/"
"65613aeddfb9ef86905cb1dade9e773a02ef3c27), [c812a40a](https://github.com/"
"Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5) і "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/"
"c381d03aad5c3ee761169b7c7bced519cc14da29)."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"Якщо об'єкт принтера визначає `get_status()` метод потім модуль може "
"експортувати [статус інформації](Status_Reference.md) через "
"[macros](Command_Templates.md) і через [API Server](API_Server.md). "
"`get_status()` метод повинен повернути словник Python з ключами, які є "
"рядками і значеннями, які є цілими, плавлення, рядки, списки, словники, "
"Правда, False або None. Також можуть використовуватися тюпли (і іменовані "
"шрифти). Переліки та словники, які експортуються, повинні бути оброблені як "
"\"імітовані\" - якщо їх зміни вмісту, то новий об'єкт повинен бути "
"повернений з `get_status()`, інакше сервер API не виявить ці зміни."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr ""
"Рекомендовано призначити значення для всіх змінних користувачів у "
"конструкторі Python. (Таким чином, уникнення здатності Python до динамічного "
"створення змінних користувачів.)"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"Якщо змінна Python полягає в тому, щоб зберігати значення точки плавлення, "
"то рекомендується завжди призначити і маніпулювати, що змінна з плаваючою "
"точкою константи (і ніколи не використовувати цілі константи). Наприклад, "
"воліє `self.speed = 1` над `self.speed = 1`, і воліє `self.speed = 2. * x` "
"над `self.speed = 2 * x`. Консистентне використання значень точки плавлення "
"може уникнути важко дебвугових кіл у перетвореннях типу Python."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"Перше основне завдання кодування - довести підтримку зв'язку на цільову "
"дошку. Це найскладніший крок у новому порту. Після того, як основне "
"спілкування працює, інші кроки, як правило, набагато простіше. Призначений "
"для використання серійного пристрою типу UART під час початкового розвитку, "
"оскільки ці види апаратних пристроїв, як правило, простіше увімкнути та "
"контролювати. Під час цієї фази ліберал може використовувати код помічника з "
"src/generic/ каталогу (перевірити, як src/simulator/Makefile включає "
"загальний код C в структуру). Також необхідно визначити таймер_read_time() ("
"який повертає поточний системний годинник) в цій фазі, але не потрібно "
"повністю підтримувати часову обробку."

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "Додаткові поради кодування:"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"Уникайте використання \"C bitfields\" для доступу до реєстрів IO; віддайте "
"перевагу прямій зчитування та писати операції 32bit, 16bit, або 8bit цілих. "
"Технічні характеристики C не вказують на те, як компілятор повинен "
"реалізувати C bitfields (наприклад, endianness, і трохи макетування), і "
"важко визначити, які операції IO відбуваються на бітфілді або писати."

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"Надання чітких значень для реєстрів IO замість використання чит-"
"модіфікованих операцій. Це, якщо оновлення поля в реєстрі IO, де інші поля "
"мають відомі значення, то бажано явно писати повний вміст реєстру. "
"Очікується записувати код, який менший, швидше, і простіше відхиляти."

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"Завдання, ідентифікувати, і командні функції завжди працюють з перервами, "
"ввімкненими (як правило, вони можуть тимчасово відключати перерву, якщо це "
"необхідно). Ці функції повинні уникати довгих паузи, затримок або зробити "
"роботу, яка триває значного часу. (Довге затримки в цих функціях \"таск\" "
"призводить до спланування Джиттера для інших \"тасків\" - затримок понад "
"100us може стати помітними, затримки більше 500us може призвести до введення "
"командних ретрансмісій, затримки понад 100 м може призвести до "
"перезавантаження годинника.) Ці функції працюють за певними часами."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> LookAheadQueue.add_move() -> LookAheadQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"Клас ToolHead (в інструментальномуголові.py) ручок \"look-ahead\" і "
"відстежує термін дії друку. Головний кодпат для переміщення: `ToolHead.move()"
" до Посилання до LookAheadQueue.flush() -> Move.set_junction() до ToolHead."
"_process_moves()`."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"LookAheadQueue.add_move() places the move object on the \"look-ahead\" "
"queue."
msgstr ""
"LookAheadQueue.add_move() розміщує об'єкт переходу на чергу \"look-ahead\"."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"LookAheadQueue.flush() determines the start and end velocities of each move."
msgstr ""
"LookAheadQueue.flush() визначає початок та кінцеві значення кожного руху."

#: docs/Code_Overview.md:block 24 (unordered list)
msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._advance_move_time() -> ToolHead._advance_flush_time() -> "
"MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> "
"itersolve_gen_steps_range()` (in klippy/chelper/itersolve.c). The goal of "
"the iterative solver is to find step times given a function that calculates "
"a stepper position from a time. This is done by repeatedly \"guessing\" "
"various times until the stepper position formula returns the desired "
"position of the next step on the stepper. The feedback produced from each "
"guess is used to improve future guesses so that the process rapidly "
"converges to the desired time. The kinematic stepper position formulas are "
"located in the klippy/chelper/ directory (eg, kin_cart.c, kin_corexy.c, "
"kin_delta.c, kin_extruder.c)."
msgstr ""
"Klipper використовує [інеративний розчинник](https://en.wikipedia.org/wiki/"
"Root-finding_algorithm) для створення кроку для кожного кроку. З точки зору "
"ефективності генеруються імпульси крокової залози в C-коді. Переходи "
"спочатку розміщені на \"trapezoid чергу руху\": `ToolHead._process_moves() -"
"> трапеція ` (в klippy/chelper/trapq.c). `ToolHead._process_moves() -> "
"JavaScript licenses API Веб-сайт Go1.13.8 до JavaScript licenses API Веб-"
"сайт Go1.13.8 -> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -"
"> itersolve_gen_steps_range()` (в klippy/chelper/itersolve.c). Мета "
"ітеративного розчинника полягає в тому, щоб знайти покрокові терміни, "
"враховуючи функцію, яка обчислює позицію крокової від часу. Це робиться "
"багаторазово \"чуття\" в різні часи до моменту отримання крокової позиції "
"формула повертає бажане положення наступного кроку на степпері. Зворотній "
"зв'язок, виготовлений з кожного вагітна, використовується для поліпшення "
"майбутніх вгадок, щоб процес швидко зважився до бажаного часу. Формули "
"позиції кінематичних степперів розташовані в каталозі klippy/chelper/ ("
"наприклад, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."

#~ msgid ""
#~ "The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
#~ "timing of printing actions. The main codepath for a move is: "
#~ "`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
#~ "Move.set_junction() -> ToolHead._process_moves()`."
#~ msgstr ""

#~ msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
#~ msgstr ""

#~ msgid ""
#~ "MoveQueue.flush() determines the start and end velocities of each move."
#~ msgstr ""

#~ msgid ""
#~ "Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
#~ "finding_algorithm) to generate the step times for each stepper. For "
#~ "efficiency reasons, the stepper pulse times are generated in C code. The "
#~ "moves are first placed on a \"trapezoid motion queue\": "
#~ "`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
#~ "The step times are then generated: `ToolHead._process_moves() -> "
#~ "ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
#~ "itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
#~ "klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
#~ "step times given a function that calculates a stepper position from a time. "
#~ "This is done by repeatedly \"guessing\" various times until the stepper "
#~ "position formula returns the desired position of the next step on the "
#~ "stepper. The feedback produced from each guess is used to improve future "
#~ "guesses so that the process rapidly converges to the desired time. The "
#~ "kinematic stepper position formulas are located in the klippy/chelper/ "
#~ "directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
#~ msgstr ""

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
