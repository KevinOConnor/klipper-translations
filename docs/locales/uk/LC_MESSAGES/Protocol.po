# Владислав <vlad.marusenko2000@gmail.com>, 2024.
# Ruslan Kyba <kybargr@gmail.com>, 2024.
# Максим Горпиніч <mgorpinic2005@gmail.com>, 2024.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2024-11-07 00:00+0000\n"
"Last-Translator: Максим Горпиніч <mgorpinic2005@gmail.com>\n"
"Language-Team: Ukrainian <https://hosted.weblate.org/projects/klipper/"
"protocol/uk/>\n"
"Language: uk\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Weblate 5.8.2\n"

msgid ""
"The Klipper messaging protocol is used for low-level communication between "
"the Klipper host software and the Klipper micro-controller software. At a "
"high level the protocol can be thought of as a series of command and "
"response strings that are compressed, transmitted, and then processed at the"
" receiving side. An example series of commands in uncompressed human-"
"readable format might look like:"
msgstr ""
"Протокол оміну повідомленнями Klipper використовується для низькорівневого "
"спілкування між хостовим програмним забезпеченням Klipper та програмним "
"забезпеченням мікро-контроллера Klipper. На вищому рівні протокол можна "
"розглядати як серію команд та рядків відповідей які стиснуті, передані та "
"обробленні на приймаючій стороні. ПРиклад серій команд в нестиснутому "
"зрозщумілому людині форматі може виглядати як:"

msgid ""
"See the [mcu commands](MCU_Commands.md) document for information on "
"available commands. See the [debugging](Debugging.md) document for "
"information on how to translate a G-Code file into its corresponding human-"
"readable micro-controller commands."
msgstr ""
"Дивитися [mcu команди](MCU_Commands.md) документ для інформації про доступні "
"команди. Див. [debugging](Debugging.md) документ для інформації про те, як "
"перевести файл G-Code в його відповідну команду мікроконтролерів."

msgid ""
"This page provides a high-level description of the Klipper messaging "
"protocol itself. It describes how messages are declared, encoded in binary "
"format (the \"compression\" scheme), and transmitted."
msgstr ""
"Ця сторінка забезпечує високий рівень опису протоколу обміну повідомленнями "
"Klipper. Розглянуто, як заявлені повідомлення, закодовані у бінарному "
"форматі (система «компресія», передається."

msgid ""
"The goal of the protocol is to enable an error-free communication channel "
"between the host and micro-controller that is low-latency, low-bandwidth, "
"and low-complexity for the micro-controller."
msgstr ""
"Мета протоколу – увімкнути безпомилковий канал зв’язку між хостом та "
"мікроконтролерами, що є низькою пропускною спроможністю, низькою пропускною "
"здатністю та низькою сумісністю для мікроконтролерів."

msgid "Micro-controller Interface"
msgstr "Мікроконтролер Інтерфейс"

msgid ""
"The Klipper transmission protocol can be thought of as a "
"[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
" micro-controller and host. The micro-controller software declares the "
"commands that the host may invoke along with the response messages that it "
"can generate. The host uses that information to command the micro-controller"
" to perform actions and to interpret the results."
msgstr ""
"Протокол передачі Klipper може бути подуманий як [RPC](https://en.wikipedia."
"org/wiki/Remote_procedure_call) механізму між мікроконтролером і хостом. "
"Програмне забезпечення мікроконтролера заявляє команди, що хост може "
"викликати повідомлення про відповідь, що він може генерувати. Ведуться "
"використання інформації для командування мікроконтролера для виконання дій "
"та інтерпретації результатів."

msgid "Declaring commands"
msgstr "Декларування команд"

msgid ""
"The micro-controller software declares a \"command\" by using the "
"DECL_COMMAND() macro in the C code. For example:"
msgstr ""
"Програмне забезпечення мікроконтролера заявляє «команду» за допомогою "
"макросису DECL_COMMAND() у коді C. Наприклад:"

msgid ""
"The above declares a command named \"update_digital_out\". This allows the "
"host to \"invoke\" this command which would cause the "
"command_update_digital_out() C function to be executed in the micro-"
"controller. The above also indicates that the command takes two integer "
"parameters. When the command_update_digital_out() C code is executed, it "
"will be passed an array containing these two integers - the first "
"corresponding to the 'oid' and the second corresponding to the 'value'."
msgstr ""
"Визначено команду «update_digital_out». Це дозволяє хосту \"вкликати\" цю "
"команду, яка призведе до команди_update_digital_out() Функція C виконується "
"в мікроконтролері. Вказаний вище вказується, що команда приймає два цілих "
"параметри. Коли команда_update_digital_out() Код C виконаний, він буде "
"пропущений масив, що містить ці два цілих - перше відповідне 'oid' і другий "
"відповідне 'value'."

msgid ""
"In general, the parameters are described with printf() style syntax (eg, "
"\"%u\"). The formatting directly corresponds to the human-readable view of "
"commands (eg, \"update_digital_out oid=7 value=1\"). In the above example, "
"\"value=\" is a parameter name and \"%c\" indicates the parameter is an "
"integer. Internally, the parameter name is only used as documentation. In "
"this example, the \"%c\" is also used as documentation to indicate the "
"expected integer is 1 byte in size (the declared integer size does not "
"impact the parsing or encoding)."
msgstr ""
"В цілому параметри описуються з принтом () синтаксисом стилю (наприклад, \"%"
"u\"). Форматування безпосередньо відповідає людському вигляду команд ("
"наприклад, \"update_digital_out oid=7 значення=1). У наведеному вище "
"прикладі \"value=\" є ім'ям параметра і \"%c\" вказує на параметр є цілим. "
"Внутрішня назва параметра використовується тільки як документація. У цьому "
"прикладі \"%c\" також використовується як документація, щоб вказати "
"очікуване ціле 1байт у розмірах (задекларований загальний розмір не впливає "
"на парсінг або кодування)."

msgid ""
"The micro-controller build will collect all commands declared with "
"DECL_COMMAND(), determine their parameters, and arrange for them to be "
"callable."
msgstr ""
"Мікроконтролери збирають всі команди, заявлені DECL_COMMAND(), визначать їх "
"параметри та влаштовують для них, щоб бути прийнятними."

msgid "Declaring responses"
msgstr "Зниження відповіді"

msgid ""
"To send information from the micro-controller to the host a \"response\" is "
"generated. These are both declared and transmitted using the sendf() C "
"macro. For example:"
msgstr ""
"Для надсилання інформації від мікроконтролера до хосту створюється "
"«відповідна». Ці як заявлені, так і передані за допомогою відправника() C "
"макрос. Наприклад:"

msgid ""
"The above transmits a \"status\" response message that contains two integer "
"parameters (\"clock\" and \"status\"). The micro-controller build "
"automatically finds all sendf() calls and generates encoders for them. The "
"first parameter of the sendf() function describes the response and it is in "
"the same format as command declarations."
msgstr ""
"Над передає \"статус\" відповідь повідомлення, що містить два цілих "
"параметри (\"clock\" і \"status\"). Мікроконтролер автоматично знаходить всі "
"дзвінки відправника () і генерує кодатори для них. Перший параметр функції "
"відправника () описує відповідь і він знаходиться в одному форматі, як "
"командні декларації."

msgid ""
"The host can arrange to register a callback function for each response. So, "
"in effect, commands allow the host to invoke C functions in the micro-"
"controller and responses allow the micro-controller software to invoke code "
"in the host."
msgstr ""
"Ведучий може організувати реєстрацію функції зворотного дзвінка для кожного "
"відгуку. Таким чином, в ефекті команди дозволяють хост викликати функції C в "
"мікроконтролері і відповіді дозволяють програмне забезпечення "
"мікроконтролера викликати код в хості."

msgid ""
"The sendf() macro should only be invoked from command or task handlers, and "
"it should not be invoked from interrupts or timers. The code does not need "
"to issue a sendf() in response to a received command, it is not limited in "
"the number of times sendf() may be invoked, and it may invoke sendf() at any"
" time from a task handler."
msgstr ""
"Відправка () макрос повинна бути викликана тільки з командних або завдань "
"обробників, і не повинна бути викликана від перерв або таймерів. Код не "
"потрібно випустити відправника() у відповідь на отриману команду, вона не "
"обмежується в кількості разів відправника () може бути викликана, і це може "
"викликати відправника() в будь-який час від обробника завдання."

msgid "Output responses"
msgstr "Вихідні відповіді"

msgid ""
"To simplify debugging, there is also an output() C function. For example:"
msgstr "Для спрощення відключення є також вихід() Функція C. Наприклад:"

msgid ""
"The output() function is similar in usage to printf() - it is intended to "
"generate and format arbitrary messages for human consumption."
msgstr ""
"Функція виведення () схожа на використання для друкуf() - призначена для "
"створення та форматування довільних повідомлень для споживання людиною."

msgid "Declaring enumerations"
msgstr "Декларування енгенерацій"

msgid ""
"Enumerations allow the host code to use string identifiers for parameters "
"that the micro-controller handles as integers. They are declared in the "
"micro-controller code - for example:"
msgstr ""
"Увімкнення дозволяють хост-коду використовувати ідентифікатори рядків для "
"параметрів, які обробляє мікроконтролер як цілі. Вони заявляють в "
"мікроконтролерному коді - наприклад:"

msgid ""
"If the first example, the DECL_ENUMERATION() macro defines an enumeration "
"for any command/response message with a parameter name of \"spi_bus\" or "
"parameter name with a suffix of \"_spi_bus\". For those parameters the "
"string \"spi\" is a valid value and it will be transmitted with an integer "
"value of zero."
msgstr ""
"Якщо на першому прикладі, то макросика DECL_ENUMERATION() визначає "
"ентуерацію для будь-якого командного/відповідного повідомлення з назвою "
"параметра \"spi_bus\" або ім'ям параметра з суфіксом \"_spi_bus\". Для тих "
"параметрів рядок \"spi\" є дійсним значенням і він буде передаватися з цілим "
"значенням нуля."

msgid ""
"It's also possible to declare an enumeration range. In the second example, a"
" \"pin\" parameter (or any parameter with a suffix of \"_pin\") would accept"
" PC0, PC1, PC2, ..., PC7 as valid values. The strings will be transmitted "
"with integers 16, 17, 18, ..., 23."
msgstr ""
"Також можна задекларувати діапазон винагород. У другому прикладі параметр "
"\"pin\" (або будь-який параметр з суфіксом \"_pin\") приймається PC0, PC1, "
"PC2, ..., PC7 як діє значення. Рядки будуть передаватися з цілими 16, 17, "
"18, ..., 23."

msgid "Declaring constants"
msgstr "Викривлення констанцій"

msgid "Constants can also be exported. For example, the following:"
msgstr "Константи можна також експортувати. Наприклад, наступні:"

msgid ""
"would export a constant named \"SERIAL_BAUD\" with a value of 250000 from "
"the micro-controller to the host. It is also possible to declare a constant "
"that is a string - for example:"
msgstr ""
"експортувати постійну назву \"СERIAL_BAUD\" з значенням 250000 від "
"мікроконтролера до господаря. Також можна заявити про констанцію, яка є "
"рядком - наприклад:"

msgid "Low-level message encoding"
msgstr "Низький рівень кодування повідомлень"

msgid ""
"To accomplish the above RPC mechanism, each command and response is encoded "
"into a binary format for transmission. This section describes the "
"transmission system."
msgstr ""
"Для виконання вищевказаного механізму RPC, кожна команда та відповідь "
"закодовано в бінарний формат для передачі. Цей розділ описує систему "
"передачі."

msgid "Message Blocks"
msgstr "Блоки повідомлень"

msgid ""
"All data sent from host to micro-controller and vice-versa are contained in "
"\"message blocks\". A message block has a two byte header and a three byte "
"trailer. The format of a message block is:"
msgstr ""
"Всі дані, надіслані з хосту до мікроконтролера і сп-вереса, містяться в "
"\"блоках повідомлень\". Блок повідомлення має два заголовки і три причепа. "
"Формат блоку повідомлення:"

msgid ""
"The length byte contains the number of bytes in the message block including "
"the header and trailer bytes (thus the minimum message length is 5 bytes). "
"The maximum message block length is currently 64 bytes. The sequence byte "
"contains a 4 bit sequence number in the low-order bits and the high-order "
"bits always contain 0x10 (the high-order bits are reserved for future use). "
"The content bytes contain arbitrary data and its format is described in the "
"following section. The crc bytes contain a 16bit CCITT "
"[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
"block including the header bytes but excluding the trailer bytes. The sync "
"byte is 0x7e."
msgstr ""
"Довжина байта містить кількість байтів в блокі повідомлень, включаючи "
"заголовок і причепів байтів (на відстані мінімального повідомлення 5 байтів)"
". Максимальна довжина блоку повідомлення в даний час 64 байтів. "
"Послідовність байтів включає в себе 4 біт послідовний номер у бітах низького "
"порядку та біти високого замовлення, які завжди містять 0x10 (приклади "
"високого замовлення, призначені для подальшого використання). Зміст байтів "
"містить довільні дані і його формат описано в наступному розділі. Кришка "
"байтів містить 16bit CCITT [CRC](https://en.wikipedia.org/wiki/"
"Cyclic_redundancy_check) блоку повідомлень, включаючи головки байтів, але "
"крім причепів байтів. The sync байт 0x7e."

msgid ""
"The format of the message block is inspired by "
"[HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) message "
"frames. Like in HDLC, the message block may optionally contain an additional"
" sync character at the start of the block. Unlike in HDLC, a sync character "
"is not exclusive to the framing and may be present in the message block "
"content."
msgstr ""
"Формат блоку повідомлень натхненний [HDLC](https://en.wikipedia.org/wiki/"
"High-Level_Data_Link_Control) рами повідомлення. Як і в HDLC, блок "
"повідомлень може додатково містити додатковий символ синхронізації при "
"запуску блоку. На відміну від HDLC, символ синхронізації не ексклюзивний для "
"обрамлення і може бути присутнім в вмісту блоку повідомлення."

msgid "Message Block Contents"
msgstr "Зміст блоку повідомлення"

msgid ""
"Each message block sent from host to micro-controller contains a series of "
"zero or more message commands in its contents. Each command starts with a "
"[Variable Length Quantity](#variable-length-quantities) (VLQ) encoded "
"integer command-id followed by zero or more VLQ parameters for the given "
"command."
msgstr ""
"Кожен блок повідомлень, відправлений з хосту до мікроконтролера, містить ряд "
"нульових або більше команд повідомлення в його вмісті. Кожна команда "
"починається з [Варіабельна кількість довжини](#variable-length-quantities) "
"(VLQ) закодовано цілу команду-іде з використанням нульових або більше "
"параметрів VLQ для даної команди."

msgid ""
"As an example, the following four commands might be placed in a single "
"message block:"
msgstr ""
"Як приклад, наступні чотири команди можуть бути розміщені в одному блокі "
"повідомлення:"

msgid "and encoded into the following eight VLQ integers:"
msgstr "і закодовано в наступні вісім цілих VLQ:"

msgid ""
"In order to encode and parse the message contents, both the host and micro-"
"controller must agree on the command ids and the number of parameters each "
"command has. So, in the above example, both the host and micro-controller "
"would know that \"id_update_digital_out\" is always followed by two "
"parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
" The host and micro-controller share a \"data dictionary\" that maps the "
"command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
"integer command-ids. When processing the data, the parser will know to "
"expect a specific number of VLQ encoded parameters following a given command"
" id."
msgstr ""
"Для того, щоб закодувати і записати вміст повідомлень, як хост, так і "
"мікроконтролер зобов'язаний погоджуватися на поведінкові поклади і кількість "
"параметрів, які мають кожна команда. Так, в наведеному вище прикладі, як "
"хост, так і мікроконтролер дізнався, що \"id_update_digital_out\" завжди "
"слідувати двома параметрами, а \"id_get_config\" і \"id_get_clock\" мають "
"нульові параметри. Ведучий і мікроконтролер поділяють \"словник даних\", "
"який відображає опис команд (наприклад, \"update_digital_out oid=%c "
"значення=%c\") на їх ціле командно-ids. При обробці даних аналізатор "
"дізнається про те, щоб очікувати конкретної кількості параметрів VLQ "
"закодовано за допомогою даної команди."

msgid ""
"The message contents for blocks sent from micro-controller to host follow "
"the same format. The identifiers in these messages are \"response ids\", but"
" they serve the same purpose and follow the same encoding rules. In "
"practice, message blocks sent from the micro-controller to the host never "
"contain more than one response in the message block contents."
msgstr ""
"Вміст повідомлення для блоків, відправлених з мікроконтролера, щоб зайти до "
"одного формату. Ідентифікатори в цих повідомленнях є \"відповідними "
"потоками\", але вони служать однаковим призначенням і дотримуються однакових "
"правил кодування. На практиці блоки повідомлень, відправлені з "
"мікроконтролера до хосту, ніколи не містять більше одного відгуку у вмісті "
"блоку повідомлень."

msgid "Variable Length Quantities"
msgstr "Варіабельна довжина"

msgid ""
"See the [wikipedia article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity) for more information on the general format of VLQ encoded "
"integers. Klipper uses an encoding scheme that supports both positive and "
"negative integers. Integers close to zero use less bytes to encode and "
"positive integers typically encode using less bytes than negative integers. "
"The following table shows the number of bytes each integer takes to encode:"
msgstr ""
"Дивись [пухлинна стаття](https://en.wikipedia.org/wiki/Variable-"
"length_quantity) для отримання додаткової інформації про загальний формат "
"VLQ закодовано ціле. Klipper використовує схему кодування, яка підтримує як "
"позитивні, так і негативні цілі. Інтегери близько до нуля використовують "
"менше байтів для кодування та позитивних цілих, як правило, кодування, "
"використовуючи менше байтів, ніж негативні цілі. Наступна таблиця показує "
"кількість байтів кожного цілого займає кодування:"

msgid "Integer"
msgstr "Ціле число"

msgid "Encoded size"
msgstr "Закодований розмір"

msgid "-32 .. 95"
msgstr "-32 .. 95"

msgid "1"
msgstr "1"

msgid "-4096 .. 12287"
msgstr "-4096 .. 12287"

msgid "2"
msgstr "2"

msgid "-524288 .. 1572863"
msgstr "-524288 .. 1572863"

msgid "3"
msgstr "3"

msgid "-67108864 .. 201326591"
msgstr "-67108864 .. 201326591"

msgid "4"
msgstr "4"

msgid "-2147483648 .. 4294967295"
msgstr "-2147483648 .. 4294967295"

msgid "5"
msgstr "5"

msgid "Variable length strings"
msgstr "Сортовані довжини рядки"

msgid ""
"As an exception to the above encoding rules, if a parameter to a command or "
"response is a dynamic string then the parameter is not encoded as a simple "
"VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
"encoded integer followed by the contents itself:"
msgstr ""
"Як виняток до вищезазначених правил кодування, якщо параметр до команди або "
"відповідь є динамічним рядком, то параметр не кодується як простий ціле VLQ. "
"Замість його закодовано шляхом передачі довжини як VLQ закодовано ціле число "
"після того, як сам вміст:"

msgid ""
"The command descriptions found in the data dictionary allow both the host "
"and micro-controller to know which command parameters use simple VLQ "
"encoding and which parameters use string encoding."
msgstr ""
"Описи команд, знайдені в словнику даних, дозволяють як господаря, так і "
"мікроконтролеру, щоб дізнатися, які параметри команд використовують простий "
"кодування VLQ і які параметри використовують кодування рядків."

msgid "Data Dictionary"
msgstr "Словник даних"

msgid ""
"In order for meaningful communications to be established between micro-"
"controller and host, both sides must agree on a \"data dictionary\". This "
"data dictionary contains the integer identifiers for commands and responses "
"along with their descriptions."
msgstr ""
"Для того, щоб значущі комунікації були встановлені між мікроконтролером та "
"хостом, обидві сторони повинні погоджуватися на \"словник даних\". Цей "
"словник даних містить цілі ідентифікатори для команд і реагування разом з їх "
"описами."

msgid ""
"The micro-controller build uses the contents of DECL_COMMAND() and sendf() "
"macros to generate the data dictionary. The build automatically assigns "
"unique identifiers to each command and response. This system allows both the"
" host and micro-controller code to seamlessly use descriptive human-readable"
" names while still using minimal bandwidth."
msgstr ""
"Створення мікроконтролерів використовує вміст макросів DECL_COMMAND() та "
"відправників () для створення словника даних. Створення автоматично підписує "
"унікальні ідентифікатори до кожної команди та відповіді. Ця система дозволяє "
"одночасно використовувати декриптивні імена людей, які мають мінімальну "
"пропускну здатність."

msgid ""
"The host queries the data dictionary when it first connects to the micro-"
"controller. Once the host downloads the data dictionary from the micro-"
"controller, it uses that data dictionary to encode all commands and to parse"
" all responses from the micro-controller. The host must therefore handle a "
"dynamic data dictionary. However, to keep the micro-controller software "
"simple, the micro-controller always uses its static (compiled in) data "
"dictionary."
msgstr ""
"Ведучий запитує словник даних, коли він спочатку з'єднується з "
"мікроконтролером. Після того, як хост завантажує словник даних з "
"мікроконтролера, він використовує цей словник даних, щоб зашифрувати всі "
"команди і записати всі відповіді від мікроконтролера. Ведуться динамічний "
"словник даних. Тим не менш, для зберігання мікроконтролерів програмне "
"забезпечення простий, мікроконтролер завжди використовує свій статичний "
"(упорядкований) словник даних."

msgid ""
"The data dictionary is queried by sending \"identify\" commands to the "
"micro-controller. The micro-controller will respond to each identify command"
" with an \"identify_response\" message. Since these two commands are needed "
"prior to obtaining the data dictionary, their integer ids and parameter "
"types are hard-coded in both the micro-controller and the host. The "
"\"identify_response\" response id is 0, the \"identify\" command id is 1. "
"Other than having hard-coded ids the identify command and its response are "
"declared and transmitted the same way as other commands and responses. No "
"other command or response is hard-coded."
msgstr ""
"Словник даних передається шляхом відправки \"ідентифікувати\" команд до "
"мікроконтролера. Мікроконтролер відреагує на кожну команду з повідомленням "
"\"identify_response\". Оскільки ці дві команди потрібні до отримання "
"словника даних, їх ціла кришка і типи параметрів важко закодовані як в "
"мікроконтролері, так і ведучий. \"identify_response\" відповідь id є 0, "
"\"ідентифікувати\" команди id є 1. Крім того, у випадку, якщо у вас виникли "
"труднощі, виявляти команду та її відповідь будуть оголошені та передані "
"таким чином, як інші команди та відповіді. Немає іншої команди або відповідь "
"на жорсткий-код."

msgid ""
"The format of the transmitted data dictionary itself is a zlib compressed "
"JSON string. The micro-controller build process generates the string, "
"compresses it, and stores it in the text section of the micro-controller "
"flash. The data dictionary can be much larger than the maximum message block"
" size - the host downloads it by sending multiple identify commands "
"requesting progressive chunks of the data dictionary. Once all chunks are "
"obtained the host will assemble the chunks, uncompress the data, and parse "
"the contents."
msgstr ""
"Формат переданого словника даних є zlib стисненим рядком JSON. Процес "
"побудови мікроконтролерів генерує рядок, стискає її, зберігає її в "
"текстовому розділі мікроконтролерів спалаху. Словник даних може бути "
"набагато більше, ніж розмір блоку повідомлення - він завантажує його, "
"відправивши кілька команд, які вимагають прогресивних шматків словника "
"даних. Після того, як всі шматки одержують хост, збираються шматки, "
"ненав'язують дані, і припаркують вміст."

msgid ""
"In addition to information on the communication protocol, the data "
"dictionary also contains the software version, enumerations (as defined by "
"DECL_ENUMERATION), and constants (as defined by DECL_CONSTANT)."
msgstr ""
"На додаток до інформації про протокол зв'язку, словник даних також містить "
"версію програмного забезпечення, заохочення (як визначено DECL_ENUMERATION), "
"а також константи (як визначено DECL_CONSTANT)."

msgid "Message flow"
msgstr "Потік повідомлення"

msgid ""
"Message commands sent from host to micro-controller are intended to be "
"error-free. The micro-controller will check the CRC and sequence numbers in "
"each message block to ensure the commands are accurate and in-order. The "
"micro-controller always processes message blocks in-order - should it "
"receive a block out-of-order it will discard it and any other out-of-order "
"blocks until it receives blocks with the correct sequencing."
msgstr ""
"Команди повідомлень, які надсилаються від хосту до мікроконтролю, призначені "
"для того, щоб бути безпомилково. Мікроконтролер перевірить CRC і "
"послідовність чисел в кожному блокі повідомлення, щоб забезпечити команди є "
"точними і в порядку. Мікроконтролер завжди обробляє блоки повідомлень в "
"порядку - повинен він отримувати блок поза замовлення, він буде відкинути "
"його і будь-які інші блоки зовнішнього замовлення, поки він отримує блоки з "
"правильним віджиманням."

msgid ""
"The low-level host code implements an automatic retransmission system for "
"lost and corrupt message blocks sent to the micro-controller. To facilitate "
"this, the micro-controller transmits an \"ack message block\" after each "
"successfully received message block. The host schedules a timeout after "
"sending each block and it will retransmit should the timeout expire without "
"receiving a corresponding \"ack\". In addition, if the micro-controller "
"detects a corrupt or out-of-order block it may transmit a \"nak message "
"block\" to facilitate fast retransmission."
msgstr ""
"У низькому рівні хост-код реалізується автоматична система ретрансмісії для "
"втрачених і пошкоджених блоків повідомлень, відправлених на мікроконтролер. "
"Щоб полегшити це, мікроконтролер передає \"блок повідомлення\" після кожного "
"успішно отримав блок повідомлень. Після відправки кожного блоку, він буде "
"переадресувати, щоб часовий платіж без отримання відповідного \"прибрати\". "
"Крім того, якщо мікроконтролер виявляє пошкоджений або позакореневий блок, "
"він може передавати \"блок повідомлень\" для спрощення перепередачі."

msgid ""
"An \"ack\" is a message block with empty content (ie, a 5 byte message "
"block) and a sequence number greater than the last received host sequence "
"number. A \"nak\" is a message block with empty content and a sequence "
"number less than the last received host sequence number."
msgstr ""
"\"не\" - блок повідомлень з порожнім змістом (тобто блоком повідомлення 5) і "
"числом послідовності більше, ніж останній отриманий номер послідовності. A "
"\"nak\" являє собою блок повідомлень з порожнім вмістом і числом "
"послідовності менше останнього отриманого номер послідовності."

msgid ""
"The protocol facilitates a \"window\" transmission system so that the host "
"can have many outstanding message blocks in-flight at a time. (This is in "
"addition to the many commands that may be present in a given message block.)"
" This allows maximum bandwidth utilization even in the event of transmission"
" latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
" by similar mechanisms in "
"[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
msgstr ""
"Протокол полегшує систему передачі \"window\" таким чином, що хост може мати "
"багато видатних блоків повідомлень в діапазоні часу. (Це додаток до багатьох "
"команд, які можуть бути присутніми в даній блокі повідомлень.) Це дозволяє "
"використовувати максимальну пропускну здатність навіть у разі затримки "
"передачі. Відправлення часу, перепередача, підвіконня, а також механізм ack "
"натхненні аналогічними механізмами [TCP](https://en.wikipedia.org/wiki/"
"Transmission_Control_Protocol)."

msgid ""
"In the other direction, message blocks sent from micro-controller to host "
"are designed to be error-free, but they do not have assured transmission. "
"(Responses should not be corrupt, but they may go missing.) This is done to "
"keep the implementation in the micro-controller simple. There is no "
"automatic retransmission system for responses - the high-level code is "
"expected to be capable of handling an occasional missing response (usually "
"by re-requesting the content or setting up a recurring schedule of response "
"transmission). The sequence number field in message blocks sent to the host "
"is always one greater than the last received sequence number of message "
"blocks received from the host. It is not used to track sequences of response"
" message blocks."
msgstr ""
"У іншому напрямку блоки повідомлень, відправлені з мікроконтролера, "
"призначені для того, щоб бути безпомилковими, але вони не мають обов'язкової "
"передачі. (Відповідачі не повинні бути пошкоджені, але вони можуть бути "
"відсутніми.) Це робиться для забезпечення реалізації мікроконтролерів "
"простим. Не існує автоматичної ретрансмісійної системи для реагування - код "
"високого рівня очікується, що може бути здатний працювати з періодичним "
"відсутнім відгуком (зазвичай шляхом перезапитування вмісту або налаштування "
"графіка рефлекторної передачі). Послідовне поле номеру в блоках повідомлень, "
"які надсилаються господареві, завжди один більше, ніж останній отриманий "
"послідовний номер блоків повідомлень, отриманих від господаря. Не "
"використовується для відстеження послідовностей блоків повідомлень відповіді."

msgid ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"
msgstr ""
"set_digital_out pin=PA3 значення=1\n"
"set_digital_out pin=PA7 значення=1\n"
"Графік роботи_Digital_out oid=8 годин=4000000 значення=0\n"
"string_step oid=7 інтервал=7458 count=10 add=331\n"
"string_step oid=7 інтервал=11717 count=4 add=1281\n"

msgid ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"
msgstr ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c value=%"
"c\");\n"

msgid ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"
msgstr ""
"sendf(\"годинник статусу=%u статус=%c\", sched_read_time(), "
"sched_is_shutdown());\n"

msgid "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"
msgstr "output(\"Значення %u дорівнює %s із розміром %u.\", x, buf, buf_len);\n"

msgid ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"
msgstr ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
" DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"

msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
msgstr "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"

msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
msgstr "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"

msgid ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"
msgstr "<1 byte length><1 byte end><n-byte content><2 byte crc><1 byte sync>\n"

msgid ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"
msgstr ""
"update_digital_out oid=6 значення=1\n"
" update_digital_out oid=5 значення=0\n"
" get_config\n"
" get_clock\n"

msgid ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"
msgstr ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_"
"get_clock>\n"

msgid "<VLQ encoded length><n-byte contents>\n"
msgstr "<VLQ encoded length><n-byte contents>\n"

#: docs/Protocol.md:block 1 (header)
msgid "Protocol"
msgstr "Протокол"
