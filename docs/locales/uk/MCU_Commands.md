# Команди МКУ

Цей документ надає інформацію про команди мікроконтролерів низького рівня, які надсилаються з програмного забезпечення Klipper "host" та обробляються програмним забезпеченням мікроконтролера Klipper. Цей документ не є авторитетним посиланням для цих команд, а не є ексклюзивним переліком всіх доступних команд.

Цей документ може бути корисним для розробників, які зацікавлені у розумінні команди мікроконтролерів низького рівня.

Перегляд [protocol](Protocol.md) документа для отримання додаткової інформації про формат команд та їх передачу. Командами тут описуються за допомогою синтаксису стилю «printf» - для тих, хто не знайомий з цим форматом, просто зауважити, що де «%...» побачить, що його потрібно замінити на власне ціле. Наприклад, опис з "count=%c" можна замінити текстом "count=10". Зауважте, що параметри, які вважаються "генераціями" (див. вище протокол документа) приймають значення рядка, яка автоматично перетворюється на ціле значення для мікроконтролера. Це поширене з параметрами «pin» (або які мають суфікс «_pin»).

## Команди стартапів

Щоб налаштувати мікроконтролер і його периферію, необхідно приймати певні одноразові дії. Цей розділ містить загальні команди, доступні для цього. На відміну від більшості команд мікроконтролера, ці команди працюють, як тільки вони отримують, і вони не вимагають певного налаштування.

Загальні команди стартапів:

* `set_digital_out pin=%u значення=%c` : Ця команда відразу налаштовує задану шпильку як цифровий від GPIO, і вона встановлює її як низький рівень (значення=0) або високий рівень (значення=1). Ця команда може бути корисною для налаштування початкового значення світлодіодів і для налаштування початкового значення крокової драйвера мікрокропінгових штифтів.
* `set_pwm_out pin=%u циклу_ticks=%u значення=%hu` : Ця команда відразу налаштовує дана шпилька, щоб використовувати апаратні на основі пульс-width-модуляції (PWM) з заданою кількістю циклів_ticks. "cycle_ticks" - це кількість годинників МКУ, які повинні тривати потужність і відключити цикл. Цикл_ticks значення 1 може бути використана для того, щоб запросити найбільш оптимальний час циклу. Параметри "значення" між 0 і 255 з 0, що вказує на повну стан і 255, що вказують на стан. Ця команда може бути корисною для забезпечення вентиляторів охолодження процесора та сопла.

## Мікроконтролер низького рівня

Більшість команд в мікроконтролері вимагають початкового налаштування, перш ніж вони можуть бути успішно викликані. Цей розділ надає огляд процесу конфігурації. Цей розділ і наступні розділи, швидше за все, тільки проценти розробникам, які цікавляться внутрішніми деталями Klipper.

При першому підключенні до мікроконтролера завжди починається отримання словника даних (див. [protocol](Protocol.md) для отримання додаткової інформації). Після отримання словника даних ведучий перевірить, якщо мікроконтролер знаходиться в "настроченому" стані і налаштовує його, якщо ні. Конфігурація передбачає наступні етапи:

* `get_config` : Ведуться перевірки, якщо вже налаштований мікроконтролер. Micro-controller реагує на цю команду з повідомленням "config". Мікроконтролерне програмне забезпечення завжди починається в неналаштуваному стані на електромережі. Залишається в цьому стані до моменту завершення конфігураційних процесів (виписавши команду endize_config). Якщо мікроконтролер вже налаштований з попереднього сеансу (і налаштовується з бажаними налаштуваннями) після чого не потрібно подальшої дії за допомогою хосту і процесу налаштування успішно завершується.
* `allocate_oids count=%c` : Ця команда видається, щоб повідомити мікроконтролеру максимальної кількості об'єктів-їдів (недійсним), що має місце. Це тільки дійсний, щоб випустити цю команду один раз. oid є цілим ідентифікатором, виділеним кожному степперу, кожен кінець, і кожен schedulable gpio pin. Ведучий визначає завчасно кількість оїдів, які потрібно буде виконувати апаратне забезпечення і переходить до мікроконтролера, щоб вона може виділяти достатню пам'ять для зберігання картографування від недійсного до внутрішнього об'єкта.
* `config_XXX oid=%c ...` : За умовчанням будь-якої команди, починаючи з попередньогофікса "config_", створює новий об'єкт мікроконтролера і призначає даної недійсності. Наприклад, команда config_digital_out налаштовує зазначений штифт як цифровий вихід GPIO і створить внутрішній об'єкт, який може використовуватися для розкладу змін до даної GPIO. Ім'я користувача, що надходить в команду конфігурацій, вибирається хостом, і має бути між нуль і максимальним числом, що надходить в команду виділених_oids. Команди налаштування можуть працювати лише тоді, коли мікроконтролер не знаходиться в налаштованому стані (тобто перед тим, як користувач надсилає остаточне налаштування_config) і після відправки виділених_oids.
* `finalize_config crc=%u` : Заключення_config команди переходить мікроконтролер від неконфігурованого стану до настроюваного стану. параметр crc, що надходить до мікроконтролера, зберігається і наданий назад до хосту в повідомленнях "config" відповідь. За конвенцією, господар приймає 32bit CRC конфігурації, яку він буде запитати і при старті наступних сеансів зв'язку перевірить, що CRC зберігається в мікроконтролері точно відповідає бажаному CRC. Якщо КРТ не відповідає, то хост знає мікроконтролер не був налаштований в стані, бажаному хостом.

### Загальні мікроконтролери

Цей розділ містить деякі часто використовувані команди налаштування.

* `config_digital_out oid=%c pin=%u значення=%c default_value=%c max_duration=%u` : Ця команда створює внутрішній мікроконтролерний об'єкт для даного GPIO 'pin'. Пиріг буде налаштований в режимі цифрового виходу і встановлюється на початкове значення, вказане значенням 'value' (0 для низьких, 1 для високої). Створення об'єкту цифрового_out дозволяє розмістити оновлення GPIO для заданого штифта в зазначені часи (див. команду чергу_digital_out описано нижче). Якщо програмне забезпечення micro-controller перейде в режим вимкнення, то всі налаштовані об'єкти цифрових_out будуть встановлені до 'default_value'. Параметри параметра 'max_duration' використовується для здійснення перевірки безпеки - якщо це не камеро, то це максимальна кількість годинникових кліщів, які хост може встановити дану GPIO до недефектного значення без подальших оновлень. Наприклад, якщо значення за замовчуванням_значення є нульовим і максимальною_duration є 16000, то якщо ведучий встановлює gpio до значення одного, то він повинен розкладати інший оновлення до gpio pin (до нуль або один) в 16000 годинних тик. Ця функція безпеки може бути використана з нагрівачами, щоб забезпечити хост не увімкнути нагрівач, а потім вимкнути лінію.
* `config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u`: ця команда створює внутрішній об’єкт для апаратних штирів PWM, для яких хост може планувати оновлення. Його використання аналогічне config_digital_out - дивіться опис команд 'set_pwm_out' і 'config_digital_out' для опису параметрів.
* `config_analog_in oid=%c pin=%u` : Ця команда використовується для налаштування шпильки в аналоговому режимі відбору вхідних даних. Після настроювання шпилька може бути зразкований з інтервалом за допомогою команди query_analog_in (див. нижче).
* `config_stepper oid=%c Крок_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u` : Ця команда створює об'єкт внутрішнього кроку. Параметри 'step_pin' і 'dir_pin' вкажіть крок і напрямні шпильки відповідно; ця команда налаштує їх в режимі цифрового виведення. параметр 'invert_step' визначає, чи відбувається крок на висхідному краю (invert_step=0) або падіння краю (invert_step=1). параметр 'step_pulse_ticks' визначає мінімальну тривалість імпульсу кроку. Якщо мку вивозить постійний 'STEPPER_BOTH_EDGE=1' потім встановивши крок_пульс_ticks=0 і invert_step=-1 буде налаштовуватися як на вирості, так і знизу країв крокової шпильки.
* `config_endstop oid=%c pin=%c pull_up=%c stepper_count=%c` : Ця команда створює об'єкт внутрішнього "endstop". Використовується для уточнення шпильок торцевої панелі і для включення "попередня" операції (див. команду endstop_home нижче). Команда налаштує зазначений шпильок в режимі цифрового введення. Параметри параметра 'pull_up' визначає, чи буде ввімкнено апаратне забезпечення резисторів для шпильки (в наявності). параметр 'stepper_count' визначає максимальну кількість кроків, які цей кінець може знадобитися для загартування під час операції хміння (див. endstop_home нижче).
* `config_spi oid=%c bus=%u pin=%u mode=%u enddown_msg=%s` : Ця команда створює внутрішній об'єкт SPI. Використовується з Spi_transfer і spi_send команди (див. нижче). "автобус" визначає автобус SPI для використання (якщо мікроконтролер має більше одного автобуса SPI). "pin" визначає вибір чіпа (CS) для пристрою. "mode" - режим SPI (дозволяє бути між 0 і 3). параметр "rate" визначає курс SPI (в циклах на другий). Нарешті, "shutdown_msg" - це команда SPI, яка надсилається на даній пристрої, повинна переходити в стан відключення.
* `config_spi_без_cs oid=%c автобус=%u mode=%u enddown_msg=%s` : Ця команда схожа на config_spi, але без визначення шпильок CS. Корисно для пристроїв SPI, які не мають мікросхеми вибору лінії.

## Загальні команди

Цей розділ містить деякі часто використовувані команди, що працюють. Ми можемо самі зателефонувати одержувачу.

* `set_digital_out_pwm_cycle oid=%c цикл_ticks=%u` : Ця команда налаштовує цифровий вихідний штифт (як створений config_digital_out) для використання "software PWM". «циклопедика» - це кількість годинникових кліщів для циклу PWM. Оскільки вихідний комутації реалізується в програмному забезпеченні мікроконтролера, рекомендується, щоб «циклопедика» відповідала часу 10 м або більше.
* `queue_digital_out oid=%c годин=%u on_ticks=%u` : Ця команда буде розкладати зміни в цифровий вихід GPIO шпильки за вказаний час. Щоб використовувати цю команду, команда "config_digital_out" з тим самим параметром 'oid' повинна бути випущена під час конфігурації мікроконтролера. Якщо 'set_digital_out_pwm_cycle' було викликано після того, як 'on_ticks' є тривалістю (у годинникових клітках) для цикла pwm. В іншому випадку, "on_ticks" повинен бути або 0 (для низької напруги) або 1 (для високої напруги).
* `queue_pwm_out oid=%c годин=%u value=%hu` : Графік зміни до апаратного PWM вихідного штифта. Переглядайте команди 'queue_digital_out' і 'config_pwm_out' для отримання додаткової інформації.
* `query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu`: ця команда встановлює повторюваний розклад аналогових вхідних зразків. Щоб використовувати цю команду, під час конфігурації мікроконтролера повинна бути видана команда 'config_analog_in' з тим самим параметром 'oid'. Вибірки починаються з часу 'clock', він звітуватиме про отримане значення кожні такти 'rest_ticks', він перевищуватиме вибірку 'sample_count' кількість разів і призупиняти 'sample_ticks' кількість тактів годинника між понад - зразки зразків. Параметри «min_value» і «max_value» реалізують функцію безпеки — програмне забезпечення мікроконтролера перевірить, що вибіркове значення (після будь-якої надмірної вибірки) завжди знаходиться в межах наданого діапазону. Це призначено для використання зі штифтами, прикріпленими до термісторів, що керують нагрівачами - його можна використовувати, щоб перевірити, чи нагрівач знаходиться в межах діапазону температур.
* `get_clock` : Ця команда викликає мікроконтролер, щоб генерувати "розблокувати" відповідь повідомлення. Ведучий передає цю команду один раз на секунду, щоб отримати значення мікроконтролера годинника і оцінити дрейф між хостами і мікроконтролерами. Ми можемо самі зателефонувати одержувачу.

### Покрокові команди

* `queue_step oid=%c interval=%u count=%hu add=%hi` : ця команда планує «підрахувати» кількість кроків для даного степера з «інтервалом» кількості тактів між кожним кроком. Першим кроком буде «інтервал» кількості тактів годинника з моменту останнього запланованого кроку для даного степера. Якщо «add» не дорівнює нулю, інтервал буде коригуватися на суму «add» після кожного кроку. Ця команда додає заданий інтервал/підрахунок/додавання послідовності до черги кожного кроку. Під час нормальної роботи в черзі можуть бути сотні таких послідовностей. Нова послідовність додається в кінець черги, і коли кожна послідовність завершує «підрахунок» кількості кроків, вона висувається з початку черги. Ця система дозволяє мікроконтролеру поставити в чергу потенційно сотні тисяч кроків - усі з надійним і передбачуваним розкладом.
* `set_next_step_dir oid=%c dir=%c` : Ця команда визначає значення dir_pin, що використовується наступний чергу_step.
* `reset_step_clock oid=%c годин=%u` : Нормально, step timing є відносно останнього кроку для даної stepper. Ця команда скидає годинник так, щоб наступний крок був відносно поставленого часу 'clock'. Ведуться зазвичай тільки надсилає цю команду на старті друку.
* `stepper_get_position oid=%c` : Ця команда викликає мікроконтролер, щоб генерувати повідомлення про відповідь "степпер_положення". Позиція - загальна кількість кроків, створених за допомогою dr=1 minus загальна кількість кроків, створених за допомогою dir=0.
* `endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c` : ця команда використовується під час крокових операцій "наведення". Щоб використовувати цю команду, під час конфігурації мікроконтролера має бути видано команду 'config_endstop' з тим самим параметром 'oid'. Коли ця команда викликається, мікроконтролер буде пробувати кінцевий висновок кожні такти 'rest_ticks' і перевіряти, чи має воно значення, рівне 'pin_value'. Якщо значення збігається (і воно продовжує збігатися для додаткових семплів 'sample_count', рознесених 'sample_ticks'), то чергу руху для пов'язаного степера буде очищено, а степпер негайно зупиниться. Хост використовує цю команду для реалізації самонаведення — хост дає вказівку кінцевій зупинці здійснити вибірку для тригера кінцевої зупинки, а потім видає серію команд queue_step для переміщення крокового кроку до кінцевої зупинки. Коли степпер торкається кінцевого упору, тригер буде виявлено, рух зупинено, а хост буде повідомлено.

### Перемістити чергу

Кожна черга_покрокова команда використовує запис в мікроконтролері "переміщення черг". Ця черга виділяється, коли вона отримує команду "finalize_config", і вона повідомляє про кількість доступних записів черги в повідомленнях "config" відповідь.

Це відповідальність хосту, щоб забезпечити, що є доступним простір в черзі перед відправкою команди. Ведуться це шляхом обчислення, коли кожна черга_покрокова команда завершує і scheduling нових команд чергування відповідно.

### Команди SPI

* `spi_transfer oid=%c data=%*s` : Ця команда викликає мікроконтролер для надсилання "даних" до пристрою спі, зазначеного "недійсним" і генерує повідомлення "spi_transfer_response" з даними, що повернулися під час передачі.
* `spi_send oid=%c data=%*s` : Ця команда схожа на "spi_transfer", але вона не генерує повідомлення "spi_transfer_response".
