# Вимірювання Резонансів

Klipper має вбудовану підтримку сумісних акселерометрів ADXL345, MPU-9250, LIS2DW і LIS3DH, які можна використовувати для вимірювання резонансних частот принтера для різних осей і автоматичного налаштування [формувальників вхідних даних](Resonance_Compensation.md) для компенсації резонансів. Зауважте, що використання акселерометрів потребує пайки та обтиску. ADXL345 можна підключити до інтерфейсу SPI плати Raspberry Pi або MCU (він має бути достатньо швидким). Сімейство MPU можна підключити безпосередньо до інтерфейсу I2C Raspberry Pi або до інтерфейсу I2C плати MCU, яка підтримує 400 Кбіт/с *швидкий режим* у Klipper. LIS2DW і LIS3DH можна підключити до SPI або I2C з тими ж міркуваннями, що й вище.

При стисканні акселерометрів слід розуміти, що існують різні зразки друкованої плати та різні клони їх. Якщо він буде підключений до принтера 5V MCU, щоб він має регулятор напруги та перемикачі рівня.

Для ADXL345 переконайтеся, що плата підтримує режим SPI (невелика кількість плат, здається, жорстко налаштована для I2C шляхом підтягування SDO до GND).

Для MPU-9250/MPU-9255/MPU-6515/MPU-6050/MPU-6500s і LIS2DW/LIS3DH також є різноманітні дизайни плат і клони з різними підтягуючими резисторами I2C, які потребують доповнення.

## MCU з Klipper I2C *fast-mode* Підтримка

| МКУ Сім'я | MCU(s) Тестовані | MCU(s) з підтримкою |
| :-: | :-- | :-- |
| Малина Пі | 3B+, Піко | 3А, 3А+, 3Б, 4 |
| АВР АМПА | A Tmega328p | ATmega 32u4, ATmega128, ATmega168, ATmega328, ATmega644p, ATmega1280, ATmega1284, ATmega2560 |
| ВІДЕОРЕЄСТРАТОР AT90 | - | AT90 usb646, AT90usb1286 |
| SAMD | SAMC21G18 | SAMC21G18, SAMD21G18, SAMD21E18, SAMD21J18, SAMD21E15, SAMD51G19, SAMD51J19, SAMD51N19, SAMD51P20, SAME51J19, SAME51N19, SAME54P20 |

## Інструкція по монтажу

### Прованс

Кабель ethernet з щитоподібними закрученими парами (кат5e або краще) рекомендується для цілісності сигналу на віддаленій відстані. Якщо ви все ще відчуваєте питання про цілісність сигналів (SPI/I2C):

- Подвійний контроль проводки з цифровим мультиметром для:
   - Правильні з'єднання при вимкненні (константильність)
   - Правильна потужність і напруги
- I2C тільки:
   - Перевірити стійкість SCL і SDA ліній до 3.3V в діапазоні 900 ом до 1.8K
   - Для отримання повної технічної інформації [chapter 7 специфікації та посібник користувача UM10204](https://www.pololu.com/file/0J435/UM10204.pdf) для *fast-mode*
- Скорочення кабелю

Підключення електромережі тільки до плати МКУ/Пі мелені.

***Подвійний контроль перед живленням, щоб запобігти знешкодженню MCU/Raspberry Pi або акселерометра.***

### SPI Акселерометри

Найяскравіший закручений парний порядок для трьох закручених пар:

```
ГНД+МІСО
3.3В+МОСИ
СКЛК+КС
```

Зверніть увагу, що на відміну від кабельного щита, GND повинен бути підключений як на кінцях.

#### АДСЛ345

##### Пряма до Малина Пі

**Примітка: Багато MCUs буде працювати з ADXL345 в режимі SPI (наприклад, Pico), електропроводка і конфігурація будуть відрізнятися відповідно до вашої конкретної дошки і доступні шпильки **

Вам потрібно підключити ADXL345 до Raspberry Pi через SPI. Зауважте, що підключення I2C, що пропонується документацією ADXL345, має занадто низький пропускний зв'язок і ** не працювати**. Рекомендована схема підключення:

| ADXL345 шпилька | RPI шпильки | Назва RPi |
| :-: | :-: | :-: |
| 3V3 (або VCC) | 01 мар | 3.3V DC потужність |
| ГНД | 06 мар | Головна |
| Р | 24 | GPIO08 (SPI0_CE0_N) |
| СДО | 21 мар | GPIO09 (SPI0_MISO) |
| СДА | 19 мар | GPIO10 (SPI0_MOSI) |
| СКЛ | 23 мар | GPIO11 (SPI0_SCLK) |

Фрицтінг схем електропроводки для деяких плат ADXL345:

![ADXL345-Rpi](IMG/adxl345-fritzing.png)

##### Використання Raspberry Pico

Ви можете підключити ADXL345 до вашого Raspberry Pico, а потім підключити Pico до вашого Малина Пі через USB. Це дозволяє легко використовувати акселерометр на інших пристроях Klipper, оскільки ви можете підключити через USB замість GPIO. Піко не має багатої потужності обробки, тому переконайтеся, що це тільки працює акселерометр і не виконує ніяких інших обов'язків.

Для того, щоб уникнути пошкодження RPi переконайтеся, що підключення ADXL345 до 3.3V тільки. В залежності від макета дошки може бути присутнім перехідник рівня, що робить 5V небезпечним для вашого RPi.

| ADXL345 шпилька | Піко шпильки | Назва поштового штифта Pico |
| :-: | :-: | :-: |
| 3V3 (або VCC) | 36 | 3.3V DC потужність |
| ГНД | 38 хв | Головна |
| Р | 2 | GP1 (SPI 0_CSn) |
| СДО | 1 | GP0 (SPI0_RX) |
| СДА | 5 | GP3 (SPI0_TX) |
| СКЛ | 4 | GP2 (SPI0_SCK) |

Схема підключення для деяких плат ADXL345:

![ADXL345-Pico](img/adxl 345-pico.png)

### I2C Акселерометри

Найяскравіший закручений парний порядок для трьох пар (попередньо):

```
3.3В+ГНК
СДА+GND
СКЛ+GND
```

або для двох пар:

```
3.3В+СД
ГНД+СКЛ
```

Зауважте, що на відміну від кабельного щита, будь-які GND(s) повинні бути підключені до обох кінців.

#### МПУ-9250/МПУ-9255/МПУ-6515/МПУ-6050/МПУ-6500

Ці акселерометри були протестовані для роботи над I2C на RPi, RP2040 (Pico) та AVR на 400kbit/s (*fast mode*). Деякі модулі акселерометра МПУ включають витяги, але деякі занадто великі на 10K і повинні бути змінені або доповнені меншими паралельними резисторами.

Рекомендована схема підключення I2C на Малина Пі:

| МПУ-9250 шпилька | RPI шпильки | Назва RPi |
| :-: | :-: | :-: |
| ВКЦ | 01 мар | 3.3v DC потужність |
| ГНД | 09 мар | Головна |
| СДА | 03 мар | GPIO02 (SDA1) |
| СКЛ | 05 мар | GPIO03 (SCL1) |

RPi має buit-in 1.8K тяги на обох SCL і SDA.

![MPU-9250 підключений до Pi](img/mpu9250-PI-fritzing.png)

Рекомендована схема підключення до I2C (i2c0a) на RP2040:

| МПУ-9250 шпилька | RP2040 шпилька | RP2040 Назва штифта |
| :-: | :-: | :-: |
| ВКЦ | 36 | 3в3 |
| ГНД | 38 хв | Головна |
| СДА | 01 мар | GP0 (I2C0 SDA) |
| СКЛ | 02 мар | GP1 (I2C0 SCL) |

Піко не включає в себе будь-які вбудовані резистори I2C.

![MPU-9250 підключений до Pico](img/mpu9250-PICO-fritzing.png)

##### Рекомендована схема підключення до I2C(TWI) на AVR ATmega328P Ардуїно Nano:

| МПУ-9250 шпилька | Atmega328P TQFP32 шпилька | Атмега328П контактна назва | Arduino Нано шпилька |
| :-: | :-: | :-: | :-: |
| ВКЦ | 39 хв | - | - |
| ГНД | 38 хв | Головна | ГНД |
| СДА | 27 | СДА | A4 |
| СКЛ | 28 | СКЛ | A5 |

Arduino Nano не включає в себе будь-які вбудовані резистори витяжки, ані 3.3V силовий штифт.

### Монтаж акселерометра

Акселерометр повинен бути прикріплений до панелі інструментів. Для оформлення правильної кріплень, яка підходить для власних принтерів 3D. Краще вирівняти осі акселерометра з осями принтера (але якщо він робить його більш зручним, токси можуть бути опуклими - тобто не потрібно вирівняти вісь X з X і так далі - це повинно бути відмінно навіть якщо вісь акселерометра X осі принтера і т.д.).

Приклад монтажу ADXL345 на SmartEffector:

![ADXL345 на SmartEffector](img/adxl345-mount.jpg)

Зауважте, що на станковому стропальному принтері необхідно розробити 2 кріплення: одне для інструментальної головки та інше для станини, а також виконати вимірювання двічі. Додаткову інформацію див. у відповідному [розділі](#bed-slinger-printers).

**Вміст:** переконайтеся, що акселерометр і будь-які гвинти, які тримати його в місці, не доторкнутися до будь-яких металевих деталей принтера. В основному, кріплення повинні бути розроблені таким чином, щоб забезпечити електричну ізоляцію акселерометра з коробки принтера. Включаючи для того, щоб створити заземну петлю в системі, яка може пошкодити електроніку.

### Встановлення програмного забезпечення

Зверніть увагу, що резонансні вимірювання та автоматичне калібрування формувача вимагають додаткових залежностей програмного забезпечення, не встановлених за замовчуванням. Спочатку запустіть на Raspberry Pi наступні команди:

```
sudo apt оновлення
sudo apt встановити python3-numpy python3-matplotlib libatlas-base-dev libopenblas-dev
```

Далі, щоб встановити NumPy в середовищі Klipper, запустити команду:

```
~/klippy-env/bin/pip install -v "numpy<1.26"
```

Зауважте, що, залежно від продуктивності ЦП, це може зайняти *багато* часу, до 10-20 хвилин. Запасіться терпінням і дочекайтеся завершення установки. У деяких випадках, якщо на платі занадто мало оперативної пам’яті, інсталяція може завершитися помилкою, і вам потрібно буде ввімкнути обмін. Також зверніть увагу на примусову версію, оскільки нові версії NumPY мають вимоги, які можуть не виконуватись у деяких середовищах klipper python.

Після встановлення переконайтеся, що команда не відображає помилки:

```
~/klippy-env/bin/python -c 'import numpy;'
```

Правильний вихід має бути просто новим рядком.

#### Налаштування ADXL345 з RPi

По-перше, перевірте та дотримуйтесь інструкцій в [RPi Microcontroller документ](RPi_microcontroller.md) для налаштування "linux mcu" на Raspberry Pi. Це налаштує другий екземпляр кліппера, який працює на Пі.

Переконайтеся, що драйвер Linux SPI працює `sudo raspi-config` і дозволяє SPI під меню «Інфракційні параметри».

Додати наступний до файлу принтера.cfg:

```
[mcu rpi]
/tmp/klipper_host_mcu

[adxl345]
JavaScript licenses API Веб-сайт Go1.13.8

[resonance_tester]
accel_chip: adxl345
Теги:
100, 100, 20 # приклад
```

Повідомляємо про початок з 1 точки зору, в середині принту, трохи вище.

#### Налаштування ADXL345 з Pico

##### Прошивка Pico

На Raspberry Pi, компіляція прошивки для Pico.

```
cd ~ / клиппер
чистий
налаштування меню
```

![Pico менюconfig](img/klipper_pico_menuconfig.png)

Тепер, утримуючи `BOOTSEL` кнопка на Піко, підключіть Піко до Малини Пі через USB. Прошивка і прошивка.

```
зробити флеш FLASH_DEVICE=перший
```

Якщо ви не змогли, ви сказали, що `FLASH_DEVICE` для використання. У цьому прикладі, що ` змія флеш FLASH_DEVICE=2e8a:0003`. ![Визначення флеш-пристрою](img/flash_rp2040_FLASH_DEVICE.png)

##### Налаштування підключення

Піко тепер перезавантажить нову прошивку і повинен показати як серійний пристрій. Знайдіть послідовний пристрій піко з `ls /dev/serial/by-id/*`. Тепер можна додати файл `adxl.cfg` з наступними налаштуваннями:

```
[mcu adxl]
Нема Змініть <mySerial>, щоб дізнатися вище. Наприклад,
# usb-Klipper_rp2040_E661640843545B2E-if00
/dev/serial/by-id/usb-Klipper_rp2040_<mySerial>

[adxl345]
cs_pin: adxl:gpio1
spi_bus: spi0a
JavaScript licenses API Веб-сайт Go1.13.8

[resonance_tester]
accel_chip: adxl345
Теги:
# Десь трохи вище середини вашого принту ліжко
147,154, 20

[вихід_pin power_mode] # Підвищення стабільності потужності
шпилька: adxl:gpio23
```

Якщо налаштування конфігурації ADXL345 в окремому файлі, як показано вище, ви також хочете змінити файл `printer.cfg`, щоб включити цей:

```
[включає adxl.cfg] # Comment this out, коли ви відключите акселерометр
```

Рештарт Кліппер через команду `RESTART`.

#### Налаштуйте серію LIS2DW через SPI

```
[mcu lis]
Нема Змініть <mySerial>, щоб дізнатися вище. Наприклад,
# usb-Klipper_rp2040_E661640843545B2E-if00
/dev/serial/by-id/usb-Klipper_rp2040_<mySerial>

[lis2dw]
cs_pin: lis:gpio1
spi_bus: spi0a
JavaScript licenses API Веб-сайт Go1.13.8

[resonance_tester]
accel_chip: lis2dw
Теги:
# Десь трохи вище середини вашого принту ліжко
147,154, 20
```

#### Налаштування серії MPU-6000/9000 з RPi

Переконайтеся, що драйвер Linux I2C ввімкнено, а курс baud встановлюється до 400000 (див. [Включення I2C](RPi_microcontroller.md#optional-enabling-i2c) для більш детальної інформації). Потім додайте наступний до принтера.cfg:

```
[mcu rpi]
/tmp/klipper_host_mcu

[mpu9250]
i2c_mcu: свінгери
i2c_bus: i2c.1

[resonance_tester]
accel_chip: mpu9250
теги:
100, 100, 20 # приклад
```

#### Налаштування MPU-9520 Сумісний з Pico

Pico I2C встановлюється до 400000 за замовчуванням. Просто додайте наступний до принтера.cfg:

```
[mcu pico]
послідовність: /dev/serial/by-id/<your Серійний ID Pico>

[mpu9250]
i2c_mcu: pico
i2c_bus: i2c0a

[resonance_tester]
accel_chip: mpu9250
Теги:
100, 100, 20 # приклад

[static_digital_вихід pico_3V3pwm] # Підвищення стабільності потужності
шпильки: pico:gpio23
```

#### Налаштування MPU-9520 Сумісний з AVR

AVR I2C буде встановлена до 400000 по параметру mpu9250. Просто додайте наступний до принтера.cfg:

```
[mcu нано]
послідовність: /dev/serial/by-id/<your нано послідовний ідентифікатор>

[mpu9250]
i2c_mcu: нано

[resonance_tester]
accel_chip: mpu9250
Теги:
100, 100, 20 # приклад
```

Рештарт Кліппер через команду `RESTART`.

## Вимірювання резонансів

### Перевірка налаштування

Тепер можна перевірити підключення.

- Для «не постільних речей» (наприклад, один акселерометр), в Octoprint, введіть `ACCELEROMETER_QUERY`
- Для "дягачів" (наприклад, більше одного акселерометра), введіть `ACCELEROMETER_QUERY CHIP=<chip>`, де `<chip>` є ім'ям чіпа, як-вхідний, наприклад, `CHIP=bed` (див.: [bed-slinger](#bed-slinger-printers) для всіх встановлених акселерометрових чіпів.

Ви повинні бачити поточні вимірювання від акселерометра, включаючи прискорення вільного падіння, наприклад.

```
Рев: // ADxl345 значення (x, y, z): 470.719200, 941.438400, 9728.196800
```

Якщо ви отримуєте помилку, як `Invalid adxl345 id (got xx vs e5)`, де `xx` є інший ID, негайно спробуйте знову. Питання ініціалізації SPI. Якщо ви все ще отримуєте помилку, це індексує проблему з'єднання з ADXL345 або датчиком несправності. Подвійне зчепити потужність, електропроводка (тобто вона відповідає схемі, не зламаний дріт або пухкий і т.д.), і якість пайки.

**Якщо ви використовуєте сумісний акселерометр MPU-9250 і він показує як `mpu-unknown```, скористайтеся обережністю! Вони, ймовірно, відремонтовані чіпси! **

Далі намагатися бігти `MEASURE_AXES_NOISE` в Октопринті, ви повинні отримати деякі базові номери для шуму акселерометра на осі (зварити десь в діапазоні ~1-100). Занадто високий шум осі (наприклад, 1000 і більше) можна індексувати проблеми датчика, проблеми зі своєю потужністю, або занадто незбалансовані вентилятори на 3D принтері.

### Вимірювання резонансів

Тепер ви можете запустити деякі реальні тести. Запустіть команду:

```
TEST_RESONANCES AXIS=X
```

Зверніть увагу, що він створить вібрації на осі X. Він також буде відключити формулювання введення, якщо він був включений раніше, оскільки він не є дійсним для запуску резонансного тестування з ввімкненою формою введення.

**Пригода!** Обов'язково дотримуватися принтера вперше, щоб переконатися, що коливання не стали занадто жорстокими (`M112` команди можна використовувати для видалення тесту в разі надзвичайної ситуації, сподіваємось, що це не прийде до цього. Якщо вібрація є занадто сильною, ви можете намагатися вказати нижче значення за замовчуванням для параметра `accel_per_hz` у розділі `[resonance_tester]`, наприклад.

```
[resonance_tester]
 accel_chip: adxl345
 accel_per_hz: 50 # за замовчуванням 75
 точки_зонду: ...
```

Якщо він працює для осі X, запустіть для осі Y:

```
TEST_RESONANCES AXIS=Y
```

Це генерує файли 2 CSV (`/tmp/resonances_x_*.csv` та `/tmp/resonances_y_*.csv`). Ці файли можна обробити за допомогою стаціонарного сценарію на Raspberry Pi. Цей скрипт призначений для запуску з одним файлом CSV для кожної осі вимірюється, хоча він може використовуватися з декількома файлами CSV, якщо ви хочете в середньому результати. Результати дослідження можуть бути корисними, наприклад, якщо резонансні тести були зроблені на декількох тестових точках. Видалення додаткових файлів CSV, якщо ви не бажаєте в середньому їх.

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png
 ~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png
```

Цей скрипт буде генерувати діаграми `/tmp/shaper_calibrate_x.png` і `/tmp/shaper_calibrate_y.png` з частотними відгуками. Ви також отримаєте запропоновані частоти для кожного ідентифікатора вводу, а також які вводні форми рекомендується для налаштування. Наприклад:

![Резонанси](img/calibrate-y.png)

```
В'язана формар 'zv' частота = 34.4 Hz (vibrations = 4.0%, розгладжування ~= 0.132)
Щоб уникнути занадто багато розгладжування з 'zv', запропонував макс_accel <= 4500 мм/сек^2
В'язана формар 'mzv' частота = 34.6 Hz (vibrations = 0.0%, розгладжування ~= 0.170)
Щоб уникнути занадто багато плавлення з 'mzv', запропонував макс_accel <= 3500 мм/сек^2
В'язана формар 'е' частота = 41.4 Hz (vibrations = 0.0%, розгладжування ~= 0.188)
Щоб уникнути занадто багато розгладжування з 'ei', запропонував макс_accel <= 3200 мм/сек^2
В'язана формар '2hump_ei' частота = 51.8 Hz (vibrations = 0.0%, розгладжування ~= 0.201)
Щоб уникнути занадто багато розгладжування з '2hump_ei', запропонував макс_accel <= 3000 мм/сек^2
В'язана формар '3hump_ei' частота = 61.8 Hz (vibrations = 0.0%, розгладжування ~= 0.215)
Щоб уникнути занадто багато розгладжування з '3hump_ei', запропонував макс_accel <= 2800 мм/сек^2
Рекомендований форматор - mzv @ 34.6 ХХз
```

У розділі `printer.cfg`, наприклад:

```
[input_shaper]
JavaScript licenses API Веб-сайт Go1.13.8
JavaScript licenses API Веб-сайт Go1.13.8
JavaScript licenses API Веб-сайт Go1.13.8
JavaScript licenses API Веб-сайт Go1.13.8

[принтер]
max_accel: 3000 # не повинен перевищувати оцінений макс_accel для X і Y осі
```

або ви можете вибрати іншу конфігурацію самостійно на основі створених графіків: піків в потужності спектральної щільності на діаграмах відповідають резонансним частотам принтера.

Зауважте, що альтернативно ви можете запустити вводну формувальну автоматичну калібрацію з Klipper [прямо](#input-shaper-auto-calibration), яка може бути зручною, наприклад, для вхідної форми [re-calibration](#input-shaper-re-calibration).

### Принтери постільної білизни

Якщо ваш принтер являє собою плащовий принтер, потрібно буде змінити місце розташування акселерометра між вимірюваннями для X і Y осі: вимірювати резонанси осі X з акселерометром, прикріпленим до панелі інструментів і резонансами осі Y - до ліжка (звичайне налаштування постільної білизни).

Тим не менш, ви також можете підключити два акселерометри одночасно, хоча ADXL345 повинні бути підключені до різних дощок (програш, до плати RPi і принтера MCU), або до двох різних фізичних інтерфейсів SPI на одній дошці (тільки доступні). Далі вони можуть бути налаштовані таким чином:

```
[adxl345 hotend]
 # Припустимо, що мікросхему `hotend` підключено до RPi
 cs_pin: rpi: немає

 [adxl345 ліжко]
 # Припустимо, що мікросхему `bed` підключено до плати MCU принтера
 cs_pin: ... # Вибір мікросхеми SPI плати принтера (CS).

 [resonance_tester]
 # Припустимо типове налаштування принтера bed sling
 accel_chip_x: adxl345 hotend
 accel_chip_y: ліжко adxl345
 точки_зонду: ...
```

Два MPU можуть поділитися одним автобусом I2C, але вони **cannot** вимірювати одночасно як 400kbit/s I2C автобус не дуже швидко. Потрібно мати шпильку AD0 до 0V (адреса 104) і інші її шпильки AD0 до 3.3V (адреса 105):

```
[mpu9250 hotend]
 i2c_mcu: rpi
 i2c_bus: i2c.1
 i2c_address: 104 # Цей MPU має низький рівень контакту AD0

 [ліжко mpu9250]
 i2c_mcu: rpi
 i2c_bus: i2c.1
 i2c_address: 105 # Цей MPU має високий висновок AD0

 [resonance_tester]
 # Припустимо типове налаштування принтера bed sling
 accel_chip_x: mpu9250 hotend
 accel_chip_y: ліжко mpu9250
 точки_зонду: ...
```

[Тест з кожним МПУ в індивідуальному порядку перед підключенням до автобуса для легкого знеболювання.]

Потім команди `TEST_RESONANCES AXIS=X` і `TEST_RESONANCES AXIS=Y` використовувати правильний акселерометр для кожної осі.

### Макс плавлення

Враховуйте, що вводний формувач може створити деякий розгладжування деталей. Автоматичне тюнінг вхідної форми, що виконується `calibrate_shaper.py` скрипт або `SHAPER_CALIBRATE` команда намагається не згасити плавлення, але в той же час вони намагаються мінімізувати отримані вібрації. Іноді вони можуть зробити субоптимальний вибір частоти фігури, або, можливо, ви просто віддаєте перевагу менше розгладжування деталей за рахунок більшої решти коливань. У цих випадках ви можете запитувати, щоб обмежити максимальне згладжування від вхідної форми.

Давайте розглянемо наступні результати з автоматичного тюнінгу:

![Резонанси](img/calibrate-x.png)

```
В'язана формар 'zv' частота = 57.8 Hz (vibrations = 20.3%, розгладжування ~= 0.053)
Щоб уникнути занадто багато розгладжування з 'zv', запропонував макс_accel <= 13000 мм/сек^2
В'язана формар 'mzv' частота = 34.8 Hz (vibrations = 3.6%, розгладжування ~= 0.168)
Щоб уникнути занадто багато плавлення з 'mzv', запропонував макс_accel <= 3600 мм/сек^2
В'язана формар 'е' частота = 48.8 Hz (vibrations = 4.9%, розгладжування ~= 0.135)
Щоб уникнути занадто багато розгладжування з 'ei', запропонував макс_accel <= 4400 мм/сек^2
В'язана формар '2hump_ei' частота = 45.2 Hz (vibrations = 0.1%, розгладжування ~= 0.264)
Щоб уникнути занадто багато розгладжування з '2hump_ei', запропонував макс_accel <= 2200 мм/sec^2
В'язана формар '3hump_ei' частота = 48.0 Hz (vibrations = 0.0%, розгладжування ~= 0.356)
Щоб уникнути занадто багато плавлення з '3hump_ei', запропонував макс_accel <= 1500 мм/сек^2
Рекомендований форматор 2hump_ei @ 45.2 ХХз
```

Зверніть увагу, що повідомлені значення «згладжування» є деякими абстрактними прогнозованими значеннями. Ці значення можна використовувати для порівняння різних конфігурацій: чим вище значення, тим більше згладжування створить шейпер. Однак ці показники згладжування не представляють реальної міри згладжування, оскільки фактичне згладжування залежить від параметрів [`max_accel`](#selecting-max-accel) і `square_corner_velocity`. Тому вам слід надрукувати кілька пробних відбитків, щоб побачити, наскільки згладжування створює саме вибрана конфігурація.

На прикладі вище запропоновані параметри формера не погані, але що якщо ви хочете отримати менше розгладжування на осі X? Ви можете намагатися обмежити максимальне вирівнювання фігури за допомогою наступної команди:

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png --max_smoothing=0,2
```

яка обмежує розгладжування до 0,2 балу. Тепер ви можете отримати наступний результат:

![Резонанси](img/calibrate-x-max-smoothing.png)

```
В'язана формар 'zv' частота = 55.4 Hz (vibrations = 19.7%, розгладжування ~= 0.057)
Щоб уникнути занадто багато розгладжування з 'zv', запропонував макс_accel <= 12000 мм/сек^2
В'язана формар 'mzv' частота = 34.6 Hz (vibrations = 3.6%, розгладжування ~= 0.170)
Щоб уникнути занадто багато плавлення з 'mzv', запропонував макс_accel <= 3500 мм/сек^2
В'язана формар 'е' частота = 48.2 Hz (vibrations = 4.8%, розгладжування ~= 0.139)
Щоб уникнути занадто багато розгладжування з 'ei', запропонував макс_accel <= 4300 мм/сек^2
В'язана формар '2hump_ei' частота = 52.0 Hz (vibrations = 2.7%, розгладжування ~= 0.200)
Щоб уникнути занадто багато розгладжування з '2hump_ei', запропонував макс_accel <= 3000 мм/сек^2
В'язана формар '3hump_ei' частота = 72.6 Hz (vibrations = 1,4%, розгладжування ~= 0.155)
Щоб уникнути занадто багато розгладжування з '3hump_ei', запропонував макс_accel <= 3900 мм/сек^2
Рекомендований формар 3hump_ei @ 72.6 ХХз
```

Якщо порівняти раніше запропоновані параметри, коли коливання трохи більше, але плавлення значно менше, ніж раніше, що дозволяє збільшити максимальне прискорення.

При вирішенні, які `max_smoothing` параметр вибрати, ви можете використовувати пробний і-error підхід. Спробуйте кілька різних значень, які ви отримуєте. Зверніть увагу, що фактичне згладжування, вироблене за допомогою вхідного формера залежить, в першу чергу, на найнижчій частоті резонансу принтера: чим вище частота найнижчого резонансу - тим менша плавка. Таким чином, якщо ви запитуєте сценарій, щоб знайти конфігурацію вхідної форми з нереально малим розгладжуванням, це буде за рахунок збільшення кільця за найнижчими частотами резонансу (які, як правило, також більш помітні в друку). Таким чином, завжди подвійна точка проекту, що залишилися коливання, які повідомляються скриптом і переконайтеся, що вони не занадто високі.

Зверніть увагу, що якщо ви вибрали добре `max_smoothing` значення для обох ваших осей, ви можете зберігати його в `printer.cfg` як

```
[resonance_tester]
accel_chip: ...
теги: ...
max_smoothing: 0.25 # приклад
```

Потім, якщо ви [rerun](#input-shaper-re-calibration) за допомогою вхідної форми за допомогою `SHAPER_CALIBRATE` Команда Klipper в майбутньому, вона буде використовувати збережені `max_smoothing` значення як посилання.

### Вибір макс_accel

Оскільки вводний форматор може створити деяке розгладжування деталей, особливо при високих прискореннях, вам все ще потрібно вибрати `max_accel` значення, яке не створює занадто багато розгладжування в друкованих частинах. Скрипт калібрування забезпечує оцінку параметра `max_accel`, який не повинен створювати занадто багато згладжування. Зауважте, що `max_accel`, як показано сценарій калібрування, є лише теоретичним, максимальним, при якому відповідний формар все ще здатний працювати без отримання занадто багато згладжування. Не можна рекомендувати для встановлення цього прискорення для друку. Максимальне прискорення вашого принтера дозволяє залишатися в залежності від механічних властивостей і максимального крутного моменту використовуваних крокових двигунів. Отже, пропонується встановити `max_accel` в розділі `[printer]`, яка не перевищує оцінені значення для X і Y осі, ймовірно, з деякими консервативними запасами безпеки.

Крім того, слідувати [this](Resonance_Compensation.md#selecting-max_accel) частини інструкції з налаштування вводу та друку тестової моделі для вибору `max_accel` експериментально.

Те ж повідомлення відноситься до вхідного формера [auto-calibration](#input-shaper-auto-calibration) з `SHAPER_CALIBRATE` команда: вона все ще потрібно вибрати правильний `max_accel` значення після автоматичного калібрування, і запропоновані обмеження прискорення не будуть застосовуватися автоматично.

Враховуйте, що максимальне прискорення без зайвих зусиль залежить від `square_corner_velocity`. Загальні рекомендації не можна змінити його з його значення за замовчуванням 5.0, і це значення, яке використовується за замовчуванням `calibrate_shaper.py` скрипт. Якщо ви змінили його, ви повинні повідомити скрипт про це, пройшовши `-square_corner_velocity=...` параметр, наприклад.

```
~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calib rate_x.png --square_corner_velocity=10.0
```

таким чином, можна правильно розрахувати максимальні рекомендації прискорення. Зауважте, що `SHAPER_CALIBRATE` команда вже приймає налаштовувані `square_corner_velocity` параметр враховується, і немає необхідності уточнювати його явно.

Якщо ви виконуєте рекалібрацію формувача і повідомляється розгладжування за запропонованою конфігурацією формера практично таким же, що ви отримали під час попереднього калібрування, цей крок можна пропустити.

### Ненадійні вимірювання резонансних частот

Іноді резонансні вимірювання можуть давати фальшиві результати, що призводить до неправильних пропозицій для формувачів вхідних даних. Це може бути викликано різними причинами, зокрема роботою вентиляторів на інструментальній головці, неправильним положенням або нежорстким кріпленням акселерометра або механічними проблемами, як-от ослаблені ремені або закручування чи нерівність осі. Майте на увазі, що всі вентилятори мають бути відключені для перевірки резонансу, особливо галасливі, і що акселерометр має бути жорстко встановлений на відповідній рухомій частині (наприклад, на самій платформі для стропальника ліжка або на самому екструдері принтера, а не на каретці; деякі люди отримують кращі результати, встановлюючи акселерометр на самому соплі). Що стосується механічних проблем, користувач повинен перевірити, чи є якась несправність, яку можна усунути за допомогою рухомої осі (наприклад, лінійні напрямні рейки очищені та змащені, а натяг коліс із V-подібним пазом відрегульовано правильно). Якщо нічого з цього не допомагає, користувач може спробувати інші формувачі зі створеного списку, окрім рекомендованого за замовчуванням.

### Тестування користувальницьких осей

`TEST_RESONANCES` команда підтримує користувацькі осі. В той час як це не дуже корисно для калібрування вводу, його можна використовувати для вивчення резонансів принтера глибоко і для перевірки, наприклад, натяг стрічки.

Для перевірки натягу стрічки на принтерах CoreXY, виконання

```
TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data
TEST_RESONANCES AXIS=1,-1 OUT PUT=raw_data
```

`graph_accelerometer.py` для обробки створених файлів, наприклад.

```
~/klipper/scripts/graph_accelero meter.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png
```

`/tmp/resonances.png` порівняння резонансів.

Для принтерів Delta з розміщенням за замовчуванням (підтримка A ~= 210 градусів, B ~=330 градусів, а C ~= 90 градусів), виконання

```
TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data
TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data
TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data
```

а потім використовувати однакову команду

```
~/klipper/scripts/graph_accelero meter.py -c /tmp/raw_data_axis*.csv -o /tmp/resonances.png
```

щоб створити `/tmp/resonances.png` для порівняння резонансів.

## Вхідний шейпер автоматичного калібрування

Крім ручного вибору відповідних параметрів для функції вводу, можна також запустити автовизначення для вхідної форми безпосередньо від Klipper. Запустіть команду за допомогою терміналу Octoprint:

```
SHAPER_CALIBRATE
```

Це буде запустити повну тест для обох осей і генерувати вихід csv (`/tmp/calibration_data_*.csv` за замовчуванням) для відповіді частоти і запропонованих форм введення. Ви також отримаєте запропоновані частоти для кожного ідентифікатора вводу, а також який вводний формувач рекомендується для налаштування, на Octoprint консолі. Наприклад:

```
Розрахунок кращих параметрів вводу для осі я
В'язана формар 'zv' частота = 39.0 Hz (vibrations = 13.2%, розгладжування ~= 0.105)
Щоб уникнути занадто багато розгладжування з 'zv', запропонував макс_accel <= 5900 мм/сек^2
В'язана формар 'mzv' частота = 36.8 Hz (vibrations = 1.7%, розгладжування ~= 0.150)
Щоб уникнути занадто багато розгладжування з 'mzv', запропонував макс_accel <= 4000 мм/сек^2
В'язана формар 'я' частота = 36.6 Hz (vibrations = 2.2%, розгладжування ~= 0.240)
Щоб уникнути занадто багато розгладжування з 'ei', запропонував макс_accel <= 2500 мм/сек^2
В'язана формар '2hump_ei' частота = 48.0 Hz (vibrations = 0.0%, розгладжування ~= 0.234)
Щоб уникнути занадто багато розгладжування з '2hump_ei', запропонував макс_accel <= 2500 мм/сек^2
В'язана формар '3hump_ei' частота = 59.0 Hz (vibrations = 0.0%, розгладжування ~= 0.235)
Щоб уникнути занадто багато розгладжування з '3hump_ei', запропонував макс_accel <= 2500 мм/сек^2
Рекомендований форматор_type_y = mzv, формаr_freq_y = 36.8 ХХз
```

Якщо ви погоджуєтесь з запропонованими параметрами, ви можете виконувати `SAVE_CONFIG`, щоб зберегти їх і перезапустити Klipper. Зверніть увагу, що це не буде оновлено `max_accel` значення в розділі `[printer]`. Ви повинні оновити її вручну за розглядами в розділі [Виберіть максимальну кількість_accel](#selecting-max_accel).

Якщо ваш принтер являє собою плащовий принтер, ви можете вказати яку віссю для тестування, так що ви можете змінити точку кріплення акселерометра між тестами (за замовчуванням тест виконується як для обох осей):

```
SHAPER_CALIBRATE AXIS=Y
```

Ви можете виконувати `SAVE_CONFIG` двічі - після калібрування кожної осі.

Тим не менш, якщо ви підключені два акселерометри одночасно, ви просто запустіть `SHAPER_CALIBRATE`, не вказавши вісь, щоб калібрувати вводну форму для обох осі в одному ходу.

### Вхідний шейпер re-calibration

`SHAPER_CALIBRATE` команда також може використовуватися для повторного калібрування вхідного форматора в майбутньому, особливо якщо деякі зміни принтера, які можуть вплинути на його кінематику. Один може або перебіг повного калібрування за допомогою `SHAPER_CALIBRATE`, або обмежити автоматичне калібрування на одну вісь, подаючи `AXIS=` параметр, як і

```
SHAPER_CALIBRATE AXIS=X
```

**Налаштування!** Не доцільно запустити автоматичну калібрацію фігурки дуже часто (наприклад, перед кожним друком або кожним днем). Для визначення резонансних частот автокальібрація створює інтенсивні коливання на кожному з осей. Зазвичай принтери 3D не призначені для витримки тривалого впливу коливань біля резонансних частот. Дозування може збільшити знос компонентів принтера і зменшити термін служби. Також є підвищений ризик виникнення певних частин, що незламні або стають пухкими. Завжди перевірте, що всі частини принтера (в тому числі тих, які можуть зазвичай не переходити) надійно зафіксовані в місці після кожного автовиїзду.

Крім того, через деякий шум при вимірюванні, можливо, що результати тюнінга будуть трохи відрізнятися від одного калібрування за один до одного. Тим не менш, не очікується, що шум впливає на якість друку занадто багато. Тим не менш, він ще радий подвійним вирізом запропонованих параметрів і друкувати деякі тестові відбитки, перш ніж використовувати їх, щоб підтвердити, що вони добре.

## Офлайн обробки даних акселерометра

Генерувати дані акселерометра і обробляти її автономно (наприклад, на хост-машину), наприклад, для пошуку резонансів. Для того, щоб зробити це, запустіть наступні команди через термінал Octoprint:

```
СЕТ_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0
TEST_RESONANCES AXIS=X OUTPUT=raw_data
```

ігнорування будь-яких помилок `SET_INPUT_SHAPER` команди. Для `TEST_RESONANCES` команда, вкажіть бажану вісь тесту. Сирі дані будуть записані в каталог `/tmp` на RPi.

Сирі дані також можуть бути отримані за допомогою запуску команди `ACCELEROMETER_MEASURE` команди двічі під час нормальної активності принтера - спочатку почати вимірювання, а потім зупинити їх і написати вихідний файл. [G-Codes](G-Codes.md#adxl345) Детальніше.

`scripts/graph_accelerometer.py` і `scripts/calibrate_shaper.py`. Обидва вони приймають один або кілька сирих CSV файлів, як вхід в залежності від режиму. Граф_accelerometer.py скрипт підтримує кілька режимів роботи:

* побудова необроблених даних акселерометра (використовуйте параметр `-r`), підтримується лише 1 вхід;
* позначення періодичної реакції (не обов’язкові параметри), якщо вказані кілька вводів, комп’ютерна реакція середньої частоти;
* порівняння частотної реакції між декількома входами (користування `-c` параметра); можна додатково вказати, яку осі акселерометра, щоб розглянути через `-a x`, `-a y` або `-a z` (якщо не вказано, сума вібрацій для всіх осей використовується);
* розділяє спектрограму (використання `-s` параметра), підтримується тільки 1 вхід; можна додатково вказати, яку осі акселерометра, щоб розглянути за допомогою `-a x`, `-a y` або `-a z` (якщо не вказано, сума вібрацій для всіх осей використовується).

Зауважте, що граф_accelerometer.py скрипт підтримує лише сиру_data\*.csv файли і не резонанси\*. JavaScript licenses API Веб-сайт Go1.13.8.

Наприклад,

```
javascript licenses api веб-сайт go1.13.8 javascript licenses api веб-сайт go1.13.8
```

розділить порівняння кількох `/tmp/raw_data_x_*.csv` файлів для осі Z до `/tmp/resonances_x.png` файл.

Скрипт формаr_calibrate.py приймає 1 або кілька вводів і може запустити автоматичне налаштування вхідної форми і запропонувати кращі параметри, які добре працюють для всіх наданих вводів. Друковано запропоновані параметри до консолі, а також може додатково генерувати діаграму, якщо параметр `-o вихід.png` надається, або файл CSV, якщо `-c вихід.csv`.

Надання декількох входів до форматора_calibrate.py скрипт може бути корисний, якщо запустити деякі розширені настройки вхідної форми, наприклад:

* Запуск `TEST_RESONANCES AXIS=X OUTPUT=raw_data` (і `Y`) для одноосьового вісь двічі на прибиральному принтері з акселерометром, прикріпленим до інструментального керівника першого разу, а акселерометр прикріплюється до ліжка другий раз для виявлення осей крос-резонансів і спроб скасування їх вводними форматорами.
* `TEST_ RESONANCES AXIS=Y OUTPUT=raw_data` двічі на вкладній шляпці зі скляним ліжком та магнітними поверхнями (який легше) знайти параметри вводу, які добре працюють для будь-якої конфігурації поверхні друку.
* Поєднання резонансних даних з декількох тестових точок.
* Комбінація резонансних даних з осі 2 (наприклад, на постільному принтері для налаштовування вводу X-і осі X-резонансних резонансів для скасування вібрацій *bed* у випадку, якщо насадка 'catches' друку при переході в осі X).
