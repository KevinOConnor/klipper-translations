# Протокол

Протокол оміну повідомленнями Klipper використовується для низькорівневого спілкування між хостовим програмним забезпеченням Klipper та програмним забезпеченням мікро-контроллера Klipper. На вищому рівні протокол можна розглядати як серію команд та рядків відповідей які стиснуті, передані та обробленні на приймаючій стороні. ПРиклад серій команд в нестиснутому зрозщумілому людині форматі може виглядати як:

```
set_digital_out pin=PA3 значення=1
set_digital_out pin=PA7 значення=1
Графік роботи_Digital_out oid=8 годин=4000000 значення=0
string_step oid=7 інтервал=7458 count=10 add=331
string_step oid=7 інтервал=11717 count=4 add=1281
```

Дивитися [mcu команди](MCU_Commands.md) документ для інформації про доступні команди. Див. [debugging](Debugging.md) документ для інформації про те, як перевести файл G-Code в його відповідну команду мікроконтролерів.

Ця сторінка забезпечує високий рівень опису протоколу обміну повідомленнями Klipper. Розглянуто, як заявлені повідомлення, закодовані у бінарному форматі (система «компресія», передається.

Мета протоколу – увімкнути безпомилковий канал зв’язку між хостом та мікроконтролерами, що є низькою пропускною спроможністю, низькою пропускною здатністю та низькою сумісністю для мікроконтролерів.

## Мікроконтролер Інтерфейс

Протокол передачі Klipper може бути подуманий як [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) механізму між мікроконтролером і хостом. Програмне забезпечення мікроконтролера заявляє команди, що хост може викликати повідомлення про відповідь, що він може генерувати. Ведуться використання інформації для командування мікроконтролера для виконання дій та інтерпретації результатів.

### Декларування команд

Програмне забезпечення мікроконтролера заявляє «команду» за допомогою макросису DECL_COMMAND() у коді C. Наприклад:

```
DECL_COMMAND(command_update_digital_out, "update_digital_out oid=%c value=%c");
```

Визначено команду «update_digital_out». Це дозволяє хосту "вкликати" цю команду, яка призведе до команди_update_digital_out() Функція C виконується в мікроконтролері. Вказаний вище вказується, що команда приймає два цілих параметри. Коли команда_update_digital_out() Код C виконаний, він буде пропущений масив, що містить ці два цілих - перше відповідне 'oid' і другий відповідне 'value'.

В цілому параметри описуються з принтом () синтаксисом стилю (наприклад, "%u"). Форматування безпосередньо відповідає людському вигляду команд (наприклад, "update_digital_out oid=7 значення=1). У наведеному вище прикладі "value=" є ім'ям параметра і "%c" вказує на параметр є цілим. Внутрішня назва параметра використовується тільки як документація. У цьому прикладі "%c" також використовується як документація, щоб вказати очікуване ціле 1байт у розмірах (задекларований загальний розмір не впливає на парсінг або кодування).

Мікроконтролери збирають всі команди, заявлені DECL_COMMAND(), визначать їх параметри та влаштовують для них, щоб бути прийнятними.

### Зниження відповіді

Для надсилання інформації від мікроконтролера до хосту створюється «відповідна». Ці як заявлені, так і передані за допомогою відправника() C макрос. Наприклад:

```
sendf("годинник статусу=%u статус=%c", sched_read_time(), sched_is_shutdown());
```

Над передає "статус" відповідь повідомлення, що містить два цілих параметри ("clock" і "status"). Мікроконтролер автоматично знаходить всі дзвінки відправника () і генерує кодатори для них. Перший параметр функції відправника () описує відповідь і він знаходиться в одному форматі, як командні декларації.

Ведучий може організувати реєстрацію функції зворотного дзвінка для кожного відгуку. Таким чином, в ефекті команди дозволяють хост викликати функції C в мікроконтролері і відповіді дозволяють програмне забезпечення мікроконтролера викликати код в хості.

Відправка () макрос повинна бути викликана тільки з командних або завдань обробників, і не повинна бути викликана від перерв або таймерів. Код не потрібно випустити відправника() у відповідь на отриману команду, вона не обмежується в кількості разів відправника () може бути викликана, і це може викликати відправника() в будь-який час від обробника завдання.

#### Вихідні відповіді

Для спрощення відключення є також вихід() Функція C. Наприклад:

```
output("Значення %u дорівнює %s із розміром %u.", x, buf, buf_len);
```

Функція виведення () схожа на використання для друкуf() - призначена для створення та форматування довільних повідомлень для споживання людиною.

### Декларування енгенерацій

Увімкнення дозволяють хост-коду використовувати ідентифікатори рядків для параметрів, які обробляє мікроконтролер як цілі. Вони заявляють в мікроконтролерному коді - наприклад:

```
DECL_ENUMERATION("spi_bus", "spi", 0);

 DECL_ENUMERATION_RANGE("pin", "PC0", 16, 8);
```

Якщо на першому прикладі, то макросика DECL_ENUMERATION() визначає ентуерацію для будь-якого командного/відповідного повідомлення з назвою параметра "spi_bus" або ім'ям параметра з суфіксом "_spi_bus". Для тих параметрів рядок "spi" є дійсним значенням і він буде передаватися з цілим значенням нуля.

Також можна задекларувати діапазон винагород. У другому прикладі параметр "pin" (або будь-який параметр з суфіксом "_pin") приймається PC0, PC1, PC2, ..., PC7 як діє значення. Рядки будуть передаватися з цілими 16, 17, 18, ..., 23.

### Викривлення констанцій

Константи можна також експортувати. Наприклад, наступні:

```
DECL_CONSTANT("SERIAL_BAUD", 250000);
```

експортувати постійну назву "СERIAL_BAUD" з значенням 250000 від мікроконтролера до господаря. Також можна заявити про констанцію, яка є рядком - наприклад:

```
DECL_CONSTANT_STR("MCU", "pru");
```

## Низький рівень кодування повідомлень

Для виконання вищевказаного механізму RPC, кожна команда та відповідь закодовано в бінарний формат для передачі. Цей розділ описує систему передачі.

### Блоки повідомлень

Всі дані, надіслані з хосту до мікроконтролера і сп-вереса, містяться в "блоках повідомлень". Блок повідомлення має два заголовки і три причепа. Формат блоку повідомлення:

```
<1 byte length><1 byte end><n-byte content><2 byte crc><1 byte sync>
```

Довжина байта містить кількість байтів в блокі повідомлень, включаючи заголовок і причепів байтів (на відстані мінімального повідомлення 5 байтів). Максимальна довжина блоку повідомлення в даний час 64 байтів. Послідовність байтів включає в себе 4 біт послідовний номер у бітах низького порядку та біти високого замовлення, які завжди містять 0x10 (приклади високого замовлення, призначені для подальшого використання). Зміст байтів містить довільні дані і його формат описано в наступному розділі. Кришка байтів містить 16bit CCITT [CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) блоку повідомлень, включаючи головки байтів, але крім причепів байтів. The sync байт 0x7e.

Формат блоку повідомлень натхненний [HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) рами повідомлення. Як і в HDLC, блок повідомлень може додатково містити додатковий символ синхронізації при запуску блоку. На відміну від HDLC, символ синхронізації не ексклюзивний для обрамлення і може бути присутнім в вмісту блоку повідомлення.

### Зміст блоку повідомлення

Кожен блок повідомлень, відправлений з хосту до мікроконтролера, містить ряд нульових або більше команд повідомлення в його вмісті. Кожна команда починається з [Варіабельна кількість довжини](#variable-length-quantities) (VLQ) закодовано цілу команду-іде з використанням нульових або більше параметрів VLQ для даної команди.

Як приклад, наступні чотири команди можуть бути розміщені в одному блокі повідомлення:

```
update_digital_out oid=6 значення=1
 update_digital_out oid=5 значення=0
 get_config
 get_clock
```

і закодовано в наступні вісім цілих VLQ:

```
<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>
```

Для того, щоб закодувати і записати вміст повідомлень, як хост, так і мікроконтролер зобов'язаний погоджуватися на поведінкові поклади і кількість параметрів, які мають кожна команда. Так, в наведеному вище прикладі, як хост, так і мікроконтролер дізнався, що "id_update_digital_out" завжди слідувати двома параметрами, а "id_get_config" і "id_get_clock" мають нульові параметри. Ведучий і мікроконтролер поділяють "словник даних", який відображає опис команд (наприклад, "update_digital_out oid=%c значення=%c") на їх ціле командно-ids. При обробці даних аналізатор дізнається про те, щоб очікувати конкретної кількості параметрів VLQ закодовано за допомогою даної команди.

Вміст повідомлення для блоків, відправлених з мікроконтролера, щоб зайти до одного формату. Ідентифікатори в цих повідомленнях є "відповідними потоками", але вони служать однаковим призначенням і дотримуються однакових правил кодування. На практиці блоки повідомлень, відправлені з мікроконтролера до хосту, ніколи не містять більше одного відгуку у вмісті блоку повідомлень.

#### Варіабельна довжина

Дивись [пухлинна стаття](https://en.wikipedia.org/wiki/Variable-length_quantity) для отримання додаткової інформації про загальний формат VLQ закодовано ціле. Klipper використовує схему кодування, яка підтримує як позитивні, так і негативні цілі. Інтегери близько до нуля використовують менше байтів для кодування та позитивних цілих, як правило, кодування, використовуючи менше байтів, ніж негативні цілі. Наступна таблиця показує кількість байтів кожного цілого займає кодування:

| Ціле число | Закодований розмір |
| --- | --- |
| -32 .. 95 | 1 |
| -4096 .. 12287 | 2 |
| -524288 .. 1572863 | 3 |
| -67108864 .. 201326591 | 4 |
| -2147483648 .. 4294967295 | 5 |

#### Сортовані довжини рядки

Як виняток до вищезазначених правил кодування, якщо параметр до команди або відповідь є динамічним рядком, то параметр не кодується як простий ціле VLQ. Замість його закодовано шляхом передачі довжини як VLQ закодовано ціле число після того, як сам вміст:

```
<VLQ encoded length><n-byte contents>
```

Описи команд, знайдені в словнику даних, дозволяють як господаря, так і мікроконтролеру, щоб дізнатися, які параметри команд використовують простий кодування VLQ і які параметри використовують кодування рядків.

## Словник даних

Для того, щоб значущі комунікації були встановлені між мікроконтролером та хостом, обидві сторони повинні погоджуватися на "словник даних". Цей словник даних містить цілі ідентифікатори для команд і реагування разом з їх описами.

Створення мікроконтролерів використовує вміст макросів DECL_COMMAND() та відправників () для створення словника даних. Створення автоматично підписує унікальні ідентифікатори до кожної команди та відповіді. Ця система дозволяє одночасно використовувати декриптивні імена людей, які мають мінімальну пропускну здатність.

Ведучий запитує словник даних, коли він спочатку з'єднується з мікроконтролером. Після того, як хост завантажує словник даних з мікроконтролера, він використовує цей словник даних, щоб зашифрувати всі команди і записати всі відповіді від мікроконтролера. Ведуться динамічний словник даних. Тим не менш, для зберігання мікроконтролерів програмне забезпечення простий, мікроконтролер завжди використовує свій статичний (упорядкований) словник даних.

Словник даних передається шляхом відправки "ідентифікувати" команд до мікроконтролера. Мікроконтролер відреагує на кожну команду з повідомленням "identify_response". Оскільки ці дві команди потрібні до отримання словника даних, їх ціла кришка і типи параметрів важко закодовані як в мікроконтролері, так і ведучий. "identify_response" відповідь id є 0, "ідентифікувати" команди id є 1. Крім того, у випадку, якщо у вас виникли труднощі, виявляти команду та її відповідь будуть оголошені та передані таким чином, як інші команди та відповіді. Немає іншої команди або відповідь на жорсткий-код.

Формат переданого словника даних є zlib стисненим рядком JSON. Процес побудови мікроконтролерів генерує рядок, стискає її, зберігає її в текстовому розділі мікроконтролерів спалаху. Словник даних може бути набагато більше, ніж розмір блоку повідомлення - він завантажує його, відправивши кілька команд, які вимагають прогресивних шматків словника даних. Після того, як всі шматки одержують хост, збираються шматки, ненав'язують дані, і припаркують вміст.

На додаток до інформації про протокол зв'язку, словник даних також містить версію програмного забезпечення, заохочення (як визначено DECL_ENUMERATION), а також константи (як визначено DECL_CONSTANT).

## Потік повідомлення

Команди повідомлень, які надсилаються від хосту до мікроконтролю, призначені для того, щоб бути безпомилково. Мікроконтролер перевірить CRC і послідовність чисел в кожному блокі повідомлення, щоб забезпечити команди є точними і в порядку. Мікроконтролер завжди обробляє блоки повідомлень в порядку - повинен він отримувати блок поза замовлення, він буде відкинути його і будь-які інші блоки зовнішнього замовлення, поки він отримує блоки з правильним віджиманням.

У низькому рівні хост-код реалізується автоматична система ретрансмісії для втрачених і пошкоджених блоків повідомлень, відправлених на мікроконтролер. Щоб полегшити це, мікроконтролер передає "блок повідомлення" після кожного успішно отримав блок повідомлень. Після відправки кожного блоку, він буде переадресувати, щоб часовий платіж без отримання відповідного "прибрати". Крім того, якщо мікроконтролер виявляє пошкоджений або позакореневий блок, він може передавати "блок повідомлень" для спрощення перепередачі.

"не" - блок повідомлень з порожнім змістом (тобто блоком повідомлення 5) і числом послідовності більше, ніж останній отриманий номер послідовності. A "nak" являє собою блок повідомлень з порожнім вмістом і числом послідовності менше останнього отриманого номер послідовності.

Протокол полегшує систему передачі "window" таким чином, що хост може мати багато видатних блоків повідомлень в діапазоні часу. (Це додаток до багатьох команд, які можуть бути присутніми в даній блокі повідомлень.) Це дозволяє використовувати максимальну пропускну здатність навіть у разі затримки передачі. Відправлення часу, перепередача, підвіконня, а також механізм ack натхненні аналогічними механізмами [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol).

У іншому напрямку блоки повідомлень, відправлені з мікроконтролера, призначені для того, щоб бути безпомилковими, але вони не мають обов'язкової передачі. (Відповідачі не повинні бути пошкоджені, але вони можуть бути відсутніми.) Це робиться для забезпечення реалізації мікроконтролерів простим. Не існує автоматичної ретрансмісійної системи для реагування - код високого рівня очікується, що може бути здатний працювати з періодичним відсутнім відгуком (зазвичай шляхом перезапитування вмісту або налаштування графіка рефлекторної передачі). Послідовне поле номеру в блоках повідомлень, які надсилаються господареві, завжди один більше, ніж останній отриманий послідовний номер блоків повідомлень, отриманих від господаря. Не використовується для відстеження послідовностей блоків повідомлень відповіді.
